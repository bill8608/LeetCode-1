{
  "title": "Selection",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "1. Solution\n    1.1 Define a HashMap<String, List<ScheduleRequest>> idScheduleMap,\n        the Key is content id, the value is the location list of same id content\n    1.2 定义一个idArr数组，长度为所有不同id的content个数，将所有的content id存进去\n        作用是用来遍历所有content的location。\n    1.3 对HashMap的所有value List 进行dfs，寻找一切可能的组合，我们注意到同一个id的content，在一个时刻\n        只能出现在一个location，这就是我们为什么用id作为key，content location作为value的原因，这样我们每一个\n        id只会选取一次。\n        \n        public static void dfs(List<List<ScheduleRequest>> res, List<ScheduleRequest> item, String[] idArr,               int index, HashMap<String, List<ScheduleRequest>> idScheduleMap) {\n\t\t        if (index == idArr.length) {\n\t\t            res.add(new ArrayList<>(item));\n\t\t\t          return;\n\t\t        }\n\t\t        String contentId = idArr[index];\n        \t\tfor (int i = 0; i < idScheduleMap.get(contentId).size(); i++) {\n          \t\t\tScheduleRequest ad = idScheduleMap.get(contentId).get(i);\n          \t\t\tif (!checkSameIdContent(item, ad)) {\n          \t\t\t\t  continue;\n          \t\t\t} else {\n          \t\t\t\titem.add(ad);\n          \t\t\t\tdfs(res, item, idArr, index + 1, idScheduleMap);\t\t\t\t\n          \t\t\t\titem.remove(item.size() - 1);\n          \t\t\t}\t\t\t\n        \t\t}\n        }\n        \n        //Use to check Same Id Content, we only retain unique id content\n        public static boolean checkSameIdContent(List<ScheduleRequest> list, ScheduleRequest sr1) {\n        \t\tfor (ScheduleRequest sr : list) {\n        \t\t\tif (sr.getId().equals(sr1.getId())) {\n        \t\t\t\treturn false;\n        \t\t\t}\n        \t\t}\n        \t\treturn true;\n      \t}\n  //Since when we using dfs, if two different id have same location,there will lead to duplicate location content, how to avoid that, we just compare all the same location value, and select the maximum weight value from the contentScoreMap.\n  public static List<List<ScheduleRequest>> removeDuplicate(List<List<ScheduleRequest>> selectionListRes,           final HashMap<String, Integer> contentScoreMap) {\n    \t\tList<List<ScheduleRequest>> res = new ArrayList<>();\n    \t\tfor (List<ScheduleRequest> list : selectionListRes) {\n    \t\t\tHashMap<String, ScheduleRequest> map = new HashMap<>();\n    \t\t\tfor (ScheduleRequest req : list) {\n    \t\t\t\tif (!map.containsKey(req.getLocation())) {\n    \t\t\t\t\tmap.put(req.getLocation(), req);\n    \t\t\t\t} else {\n    \t\t\t\t\tif (contentScoreMap.get(req.getId()) >= contentScoreMap.get(map.get(req.getLocation()).getId())) {\n    \t\t\t\t\t\tmap.put(req.getLocation(), req);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tList<ScheduleRequest> newRes = new ArrayList<>();\n    \t\t\tfor (ScheduleRequest sr : map.values()) {\n    \t\t\t\tnewRes.add(sr);\n    \t\t\t}\n    \t\t\tres.add(newRes);\n    \t\t}\n    \t\treturn res;\n\t}\n\t\n\t"
    }
  ]
}