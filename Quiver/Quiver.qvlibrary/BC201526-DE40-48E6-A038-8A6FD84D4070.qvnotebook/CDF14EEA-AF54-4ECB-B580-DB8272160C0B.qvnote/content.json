{
  "title": "Interfaces",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"font-family: Helvetica;\">Java includes a concept called&nbsp;<i>interfaces</i>. A Java interface is a bit like a class, except a Java interface can only contain method signatures and fields. An Java interface cannot contain an implementation of the methods, only the signature (name, parameters and exceptions) of the method.</p><p style=\"font-family: Helvetica;\">You can use interfaces in Java as a way to achieve polymorphism. I will get back to polymorphism later in this text.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Java Interface Example</h2><p style=\"font-family: Helvetica;\">Here is a simple Java interface example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MyInterface {\n\n    public String hello = \"Hello\";\n\n    public void sayHello();\n}\n</pre><p style=\"font-family: Helvetica;\">As you can see, an interface is declared using the Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">interface</code>&nbsp;keyword. Just like with classes, a Java interface can be declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;or package scope (no access modifier).</p><p style=\"font-family: Helvetica;\">The interface example above contains one variable and one method. The variable can be accessed directly from the interface, like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">System.out.println(MyInterface.hello);\n</pre><p style=\"font-family: Helvetica;\">As you can see, accessing a variable from an interface is very similar to accessing a static variable in a class.</p><p style=\"font-family: Helvetica;\">The method, however, needs to be implemented by some class before you can access it. The next section will explain how that is done.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Implementing an Interface</h2><p style=\"font-family: Helvetica;\">Before you can really use an interface, you must implement that interface in some Java class. Here is a class that implements the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;interface shown above:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class MyInterfaceImpl implements MyInterface {\n\n    public void sayHello() {\n        System.out.println(MyInterface.hello);\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">implements MyInterface</code>&nbsp;part of the above class declaration. This signals to the Java compiler that the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterfaceImpl</code>&nbsp;class implements the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;interface.</p><p style=\"font-family: Helvetica;\">A class that implements an interface must implement all the methods declared in the interface. The methods must have the exact same signature (name + parameters) as declared in the interface. The class does not need to implement (declare) the variables of an interface. Only the methods.</p><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Interface Instances</h3><p style=\"font-family: Helvetica;\">Once a Java class implements an Java interface you can use an instance of that class as an instance of that interface. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">MyInterface myInterface = new MyInterfaceImpl();\n\nmyInterface.sayHello();\n</pre><p style=\"font-family: Helvetica;\">Notice how the variable is declared to be of the interface type&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;while the object created is of type&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterfaceImpl</code>. Java allows this because the class&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterfaceImpl</code>&nbsp;implements the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;interface. You can then reference instances of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterfaceImpl</code>&nbsp;class as instances of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;interface.</p><p style=\"font-family: Helvetica;\">You cannot create instances of a Java interface by itself. You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Implementing Multiple Interfaces</h2><p style=\"font-family: Helvetica;\">A Java class can implement multiple Java interfaces. In that case the class must implement all the methods declared in all the interfaces implemented. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class MyInterfaceImpl\n    implements MyInterface, MyOtherInterface {\n\n    public void sayHello() {\n        System.out.println(\"Hello\");\n    }\n\n    public void sayGoodbye() {\n        System.out.println(\"Goodbye\");\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">This class implements two interfaces called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterface</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyOtherInterface</code>. You list the names of the interfaces to implement after the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">implements</code>&nbsp;keyword, separated by a comma.</p><p style=\"font-family: Helvetica;\">If the interfaces are not located in the same packages as the implementing class, you will also need to import the interfaces. Java interfaces are imported using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">import</code>&nbsp;instruction just like Java classes. For instance:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">import com.jenkov.package1.MyInterface;\nimport com.jenkov.package2.MyOtherInterface;\n\npublic class MyInterfaceImpl implements MyInterface, MyOtherInterface {\n    ...\n}\n</pre><p style=\"font-family: Helvetica;\">Here are the two Java interfaces implemented by the class above:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MyInterface {\n\n    public void sayHello();\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MyOtherInterface {\n\n    public void sayGoodbye();\n}\n</pre><p style=\"font-family: Helvetica;\">As you can see, each interface contains one method. These methods are implemented by the class&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyInterfaceImpl</code>.</p><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Overlapping Method Signatures</h3><p style=\"font-family: Helvetica;\">If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces may contain methods with the same signature (name + parameters). Since a Java class can only implement at method with a given signature once, this could potentially lead to some problems.</p><p style=\"font-family: Helvetica;\">The Java specification does not give any solution to this problem. It is up to you to decide what to do in that situation.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Interface Variables</h2><p style=\"font-family: Helvetica;\">A Java interface can contain both variables and constants. However, often it does not makes sense to place variables in an interface. In some cases it can make sense to define constants in an interface. Especially if those constants are to be used by the classes implementing the interface, e.g. in calculations, or as parameters to some of the methods in the interface. However, my advice to you is to avoid placing variables in Java interfaces if you can.</p><p style=\"font-family: Helvetica;\">All variables in an interface are public, even if you leave out the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;keyword in the variable declaration.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Interface Methods</h2><p style=\"font-family: Helvetica;\">A Java interface can contain one or more method declarations. As mentioned earlier, the interface cannot specify any implementation for these methods. It is up to the classes implementing the interface to specify an implementation.</p><p style=\"font-family: Helvetica;\">All methods in an interface are public, even if you leave out the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;keyword in the method declaration.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Interface Default Methods</h2><p style=\"font-family: Helvetica;\">Before Java 8 Java interfaces could not contain an implementation of the methods, but only contain the method signatures. However, this results in some problems when an API needs to add a method to one of its interfaces. If the API just adds the method to the desired interface, all classes that implements the interface must implement that new method. That is fine if all implementing classes are located within the API. But if some implementing classes are located in client code of the API (the code that uses the API), then that code breaks.</p><p style=\"font-family: Helvetica;\">Let me illustrate this with an example. Look at this interface and imagine that it is part of e.g. an open source API which many applications are using internally:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface ResourceLoader {\n\n    Resource load(String resourcePath);\n\n}\n</pre><p style=\"font-family: Helvetica;\">Now imagine that a project uses this API and has implemented the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">ResourceLoader</code>&nbsp;interface like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class FileLoader implements ResourceLoader {\n\n    public Resource load(String resourcePath) {\n        // in here is the implementation +\n        // a return statement.\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">If the developer of the API wants to add one more method to the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">ResourceLoader</code>&nbsp;interface, then the<code style=\"font-family: Courier; font-size: 1em;\">FileLoader</code>&nbsp;class will be broken when that project upgrades to the new version of the API.</p><p style=\"font-family: Helvetica;\">To alleviate this Java interface evolution problem, Java 8 has added the concept of&nbsp;<i>interface default methods</i>&nbsp;to Java interfaces. An interface default method can contain a default implementation of that method. Classes that implement the interface but which contain no implementation for the default interface will then automatically get the default method implementation.</p><p style=\"font-family: Helvetica;\">You mark a method in an interface as a default method using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">default</code>&nbsp;keyword. Here is an example of adding a default method to the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">ResourceLoader</code>&nbsp;interface:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface ResourceLoader {\n\n    Resource load(String resourcePath);\n\n    default Resource load(Path resourcePath) {\n        // provide default implementation to load\n        // resource from a Path and return the content\n        // in a Resource object.\n    }\n\n}\n</pre><p style=\"font-family: Helvetica;\">This example adds the default method&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">load(Path)</code>. The example leaves out the actual implementation (inside the method body) because this is not really interesting. What matters is how you declare the interface default method.</p><p style=\"font-family: Helvetica;\">A class can override the implementation of a default method simply by implementing that method explicitly, as is done normally when implementing a Java interface. Any implementation in a class takes precedence over interface default method implementations.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Interfaces and Inheritance</h2><p style=\"font-family: Helvetica;\">It is possible for a Java interface to inherit from another Java interface, just like classes can inherit from other classes. You specify inheritance using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">extends</code>&nbsp;keyword. Here is a simple interface inheritance example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MySuperInterface {\n\n    public void saiHello();\n\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MySubInterface <b>extends MySuperInterface</b> {\n\n    public void sayGoodbye();\n}\n</pre><p style=\"font-family: Helvetica;\">The interface&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySubInterface</code>&nbsp;extends the interface&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySuperInterface</code>. That means, that the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySubInterface</code>&nbsp;inherits all field and methods from&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySuperInterface</code>. That then means, that if a class implements&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySubInterface</code>, that class has to implement all methods defined in both&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySubInterface</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySuperInterface</code>.</p><p style=\"font-family: Helvetica;\">It is possible to define methods in a subinterface with the same signature (name + parameters) as methods defined in a superinterface, should you find that desirable in your design, somehow.</p><p style=\"font-family: Helvetica;\">Unlike classes, interfaces can actually inherit from multiple superinterfaces. You specify that by listing the names of all interfaces to inherit from, separated by comma. A class implementing an interface which inherits from multiple interfaces must implement all methods from the interface and its superinterfaces.</p><p style=\"font-family: Helvetica;\">Here is an example of a Java interface that inherits from multiple interfaces:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MySubInterface extends\n    SuperInterface1, SuperInterface2 {\n\n    public void sayItAll();\n}\n</pre><p style=\"font-family: Helvetica;\">As when implementing multiple interfaces, there are no rules for how you handle the situation when multiple superinterfaces have methods with the same signature (name + parameters).</p><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Inheritance and Default Methods</h3><p style=\"font-family: Helvetica;\">Interface default methods add a bit complexity to the rules of interface inheritance. While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods. In other words, if two interfaces contain the same method signature (name + parameters) and one of the interfaces declare this method as a default method, a class cannot automatically implement both interfaces.</p><p style=\"font-family: Helvetica;\">The situation is the same if an interface extends (inherits from) multiple interfaces, and one or more of these interfaces contain methods with the same signature, and one of the superinterfaces declare the overlapping method as a default method.</p><p style=\"font-family: Helvetica;\">In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem. That way there is no doubt about which implementation the class will have. The implementation in the class takes precedence over any default implementations.</p><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Interfaces and Polymorphism</h2><p style=\"font-family: Helvetica;\">Java interfaces are a way to achieve polymorphism. Polymorphism is a concept that takes some practice and thought to master. Basically, polymorphism means that an instance of an class (an object) can be used as if it were of different types. Here, a type means either a class or an interface.</p><p style=\"font-family: Helvetica;\">Look at this simple class diagram:</p><table class=\"diagram\" style=\"margin: 20px 0px 30px; font-family: Helvetica;\"><tbody><tr><td align=\"center\"><img src=\"quiver-image-url/CE082B8DEFE70E62EC81D666FC4BC001.png\" alt=\"Two parallel class hierarchies used in the same application.\"></td></tr><tr><td align=\"center\"><b>Two parallel class hierarchies used in the same application.</b></td></tr></tbody></table><p style=\"font-family: Helvetica;\">The classes above are all parts of a model representing different types of vehicles and drivers, with fields and methods. That is the responsibility of these classes - to model these entities from real life.</p><p style=\"font-family: Helvetica;\">Now imagine you needed to be able to store these objects in a database, and also serialize them to XML, JSON, or other formats. You want that implemented using a single method for each operation, available on each&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>,&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;or&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;object. A&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">store()</code>&nbsp;method, a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">serializeToXML()</code>&nbsp;method and a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">serializeToJSON()</code>&nbsp;method.</p><p style=\"font-family: Helvetica;\">Please forget for a while, that implementing this functionality as methods directly on the objects may lead to a messy class hierarchy. Just imagine that this is how you want the operations implemented.</p><p style=\"font-family: Helvetica;\">Where in the above diagram would you put these three methods, so they are accessible on all classes?</p><p style=\"font-family: Helvetica;\">One way to solve this problem would be to create a common superclass for the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Driver</code>class, which has the storage and serialization methods. However, this would result in a conceptual mess. The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage and serialization mechanisms used in your application.</p><p style=\"font-family: Helvetica;\">A better solution would be to create some interfaces with the storage and serialization methods on, and let the classes implement these interfaces. Here are examples of such interfaces:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface Storable {\n\n    public void store();\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface Serializable {\n    public void serializeToXML(Writer writer);\n    public void serializeToJSON(Writer writer);\n}\n</pre><p style=\"font-family: Helvetica;\">When each class implements these two interfaces and their methods, you can access the methods of these interfaces by casting the objects to instances of the interface types. You don't need to know exactly what class a given object is of, as long as you know what interface it implements. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car car = new Car();\n\nStorable storable = (Storable) car;\nstorable.store();\n\nSerializable serializable = (Serializable) car;\nserializable.serializeToXML (new FileWriter(\"car.xml\"));\nserializable.serializeToJSON(new FileWriter(\"car.json\"));\n</pre><p style=\"font-family: Helvetica;\"><a name=\"java-interface-example\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"implementating-an-interface\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interface-instances\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"implementing-multiple-interfaces\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"overlapping-method-signatures\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interface-variables\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interface-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interface-default-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interfaces-and-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"inheritance-and-default-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a><a name=\"interfaces-and-polymorphism\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a></p><p style=\"font-family: Helvetica;\">As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting functionality in classes than inheritance.</p>"
    }
  ]
}