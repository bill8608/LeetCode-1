{
  "title": "Java Nested Classes",
  "cells": [
    {
      "type": "text",
      "data": "<div><p style=\"font-family: Helvetica;\">In Java nested classes are classes that are defined inside another class.</p><p style=\"font-family: Helvetica;\"><b>The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together. Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.</b></p><p style=\"font-family: Helvetica;\">Java developers often refer to&nbsp;<i>nested classes</i>&nbsp;as&nbsp;<i>inner classes</i>, but inner classes (non-static nested classes) are only one out of several different types of nested classes in Java.</p><p style=\"font-family: Helvetica;\">In Java nested classes are considered members of their enclosing class. Thus, a nested class can be declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>,&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">package</code>&nbsp;(no access modifier),&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">private</code>&nbsp;(see&nbsp;<a href=\"http://tutorials.jenkov.com/java/access-modifiers.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">access modifiers</a>&nbsp;for more info). Therefore nested classes in Java can also be inherited by subclasses as explained in my tutorial about&nbsp;<a href=\"http://tutorials.jenkov.com/java/inheritance.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">Java inheritance</a>.</p><p style=\"font-family: Helvetica;\">You can create several different types of nested classes in Java. The different Java nested class types are:</p><ul style=\"font-family: Helvetica;\"><li>Static nested classes</li><li>Non-static nested classes</li><li>Local classes</li><li>Anonymous classes</li></ul><p style=\"font-family: Helvetica;\">All these types of nested classes will be covered in the following sections.</p></div>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">1. Static Nested Classes</h2><p style=\"font-family: Helvetica;\">Static nested classes are declared in Java like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Outer {\n\n  public static class Nested {\n\n  }\n\n}\n</pre><p style=\"font-family: Helvetica;\">In order to create an instance of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Nested</code>&nbsp;class you must reference it by prefixing it with the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer</code>class name, like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Outer.Nested instance = new Outer.Nested();\n</pre><p style=\"font-family: Helvetica;\">In Java a static nested class is essentially a normal class that has just been nested inside another class. Being static, a static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class.</p>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">Non-static Nested Classes (Inner Classes)</h2><p style=\"font-family: Helvetica;\">Non-static nested classes in Java are also called&nbsp;<i>inner classes</i>. Inner classes are associated with an instance of the enclosing class. Thus, you must first create an instance of the enclosing class to create an instance of an inner class. Here is an example inner class definition:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Outer {\n\n  public class Inner {\n  }\n\n}\n</pre><p style=\"font-family: Helvetica;\">Here is how you create an instance of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner</code>&nbsp;class:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Outer outer = new Outer();\nOuter.Inner inner = outer.new Inner();\n</pre><p style=\"font-family: Helvetica;\">Notice how you put&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">new</code>&nbsp;after the reference to the outer class in order to create an instance of the inner class.</p><p style=\"font-family: Helvetica;\">Non-static nested classes (inner classes) have access to the fields of the enclosing class, even if they are declared private. Here is an example of that:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Outer {\n\n    private String text = \"I am private!\";\n\n    public class Inner {\n\n        public void printText() {\n            System.out.println(text);\n        }\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">printText()</code>&nbsp;method of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner</code>&nbsp;class references the private&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>&nbsp;field of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer</code>class. This is perfectly possible. Here is how you would call the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">printText()</code>&nbsp;method:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Outer outer = new Outer();\nOuter.Inner inner = outer.new Inner();\n<b>inner.printText();</b>\n</pre><a name=\"inner-class-shadowing\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Inner Class Shadowing</h3><p style=\"font-family: Helvetica;\">If a Java inner class declares fields or methods with the same names as field or methods in its enclosing class, the inner fields or methods are said to&nbsp;<i>shadow</i>&nbsp;over the outer fields or methods. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Outer {\n\n    private String text = \"I am Outer private!\";\n\n    public class Inner {\n\n        private String text = \"I am Inner private\";\n\n        public void printText() {\n            System.out.println(text);\n        }\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">In the above example both the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner</code>&nbsp;class contains a field named&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>. When the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner</code>class refers to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>&nbsp;it refers to its own field. When&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer</code>&nbsp;refers to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>&nbsp;it also refers to its own field.</p><p style=\"font-family: Helvetica;\">Java makes it possible though, for the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner</code>&nbsp;class to refer to the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>&nbsp;field of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer</code>&nbsp;class. To do so it has to prefix the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">text</code>&nbsp;field reference with&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer.this.</code>&nbsp;(the outer class name +&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">.this.</code>&nbsp;+ field name) like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Outer {\n\n    private String text = \"I am Outer private!\";\n\n    public class Inner {\n\n        private String text = \"I am Inner private\";\n\n        public void printText() {\n            System.out.println(text);\n            System.out.println(<b>Outer.this.text</b>);\n        }\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Now the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner.printText()</code>&nbsp;method will print both the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Inner.text</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Outer.text</code>&nbsp;fields.</p><a name=\"local-classes\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Local Classes</h2><p style=\"font-family: Helvetica;\">Local classes in Java are like inner classes (non-static nested classes) that are defined inside a method or scope block (<code style=\"font-family: Courier; font-size: 1em;\">{ ... }</code>) inside a method. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">class Outer {\n\n    public void printText() {\n\n        class Local {\n\n        }\n\n        Local local = new Local();\n    }\n\n}\n</pre><p style=\"font-family: Helvetica;\">Local classes can only be accessed from inside the method or scope block in which they are defined.</p><p style=\"font-family: Helvetica;\">Local classes can access members (fields and methods) of its enclosing class just like regular inner classes.</p><p style=\"font-family: Helvetica;\">Local classes can also access local variables inside the same method or scope block, provided these variables are declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">final</code>.</p><p style=\"font-family: Helvetica;\">From Java 8 local classes can also access local variables and parameters of the method the local class is declared in. The parameter will have to be declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">final</code>&nbsp;or be&nbsp;<i>effectually final</i>. Effectually final means that the variable is never changed after it is initialized. Method parameters are often effectually final.</p><p style=\"font-family: Helvetica;\">Local classes can also be declared inside static methods. In that case the local class only has access to the static parts of the enclosing class. Local classes cannot contain all kinds of static declarations (constants are allowed - variables declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">static final</code>), because local classes are non-static in nature - even if declared inside a static method.</p><p style=\"font-family: Helvetica;\">The same shadowing rules apply for local classes as for inner classes.</p><a name=\"anonymous-classes\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Anonymous Classes</h2><p style=\"font-family: Helvetica;\">Anonymous classes in Java are nested classes without a class name. They are typically declared as either subclasses of an existing class, or as implementations of some&nbsp;<a href=\"http://tutorials.jenkov.com/java/interfaces.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">interface</a>.</p><p style=\"font-family: Helvetica;\">Anonymous classes are defined when they are instantiated. Here is an example that declares an anonymous subclass of a superclass called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">SuperClass</code>:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class SuperClass {\n\n  public void doIt() {\n    System.out.println(\"SuperClass doIt()\");\n  }\n\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">SuperClass instance = new SuperClass() {\n\n    public void doIt() {\n        System.out.println(\"Anonymous class doIt()\");\n    }\n};\n\ninstance.doIt();\n</pre><p style=\"font-family: Helvetica;\">Running this Java code would result in&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Anonymous class doIt()</code>&nbsp;being printed to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">System.out</code>. The anonymous class subclasses (extends)&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">SuperClass</code>&nbsp;and overrides the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">doIt()</code>&nbsp;method.</p><p style=\"font-family: Helvetica;\">A Java anonymous class can also implement an interface instead of extending a class. Here an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface MyInterface {\n\n  public void doIt();\n\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">MyInterface instance = new MyInterface() {\n\n    public void doIt() {\n        System.out.println(\"Anonymous class doIt()\");\n    }\n};\n\ninstance.doIt();\n</pre><p style=\"font-family: Helvetica;\">As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.</p><p style=\"font-family: Helvetica;\">An anonymous class can access members of the enclosing class. It can also access local variables which are declared final or effectively final (since Java 8).</p><p style=\"font-family: Helvetica;\">You can declare fields and methods inside an anonymous class, but you cannot declare a constructor. You can declare a static initializer for the anonymous class instead, though. Here is an example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">final Strint textToPrint = \"Text...\";\n\nMyInterface instance = new MyInterface() {\n\n    private String text;\n\n    //static initializer\n    {  this.text = textToPrint;  }\n\n    public void doIt() {\n        System.out.println(this.text);\n    }\n};\n\ninstance.doIt();\n</pre><p style=\"font-family: Helvetica;\">The same shadowing rules apply to anonymous classes as to inner classes.</p><a name=\"nested-classes-benefits\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Nested Class Benefits</h2><p style=\"font-family: Helvetica;\">The benefits of Java nested classes are that you can group classes together that belong together. You could do so already by putting them in the same package, but putting one class inside another makes an even stronger grouping.</p><p style=\"font-family: Helvetica;\">A nested class is typically only used&nbsp;<i>by</i>&nbsp;or&nbsp;<i>with</i>&nbsp;its enclosing class. Sometimes a nested class is only visible to the enclosing class, is only used internally, and is thus never visible outside the enclosing class. Other times the nested class is visible outside its enclosing class, but can only be used in conjunction with the enclosing class.</p><p style=\"font-family: Helvetica;\">An example would be a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class. Inside the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class you might declare a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">CacheEntry</code>&nbsp;class which can contain information about a specific cache entry (cached value, time inserted, number of times accessed etc.). Users of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class may never see the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">CacheEntry</code>&nbsp;class, if they have no need to obtain information about the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">CacheEntry</code>&nbsp;itself, but only the cached value. However, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class may choose to make the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">CacheEntry</code>&nbsp;class visible to the outside world, so they can access more than just the cached value (for instance information about when the value was last refreshed etc.).</p><p style=\"font-family: Helvetica;\">Here are two&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;implementation skeletons illustrating the points:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Cache {\n\n    private Map&lt;String, CacheEntry&gt; cacheMap = new HashMap&lt;String, CacheEntry&gt;();\n\n    private class CacheEntry {\n        public long   timeInserted = 0;\n        public object value        = null;\n    }\n\n    public void store(String key, Object value){\n        CacheEntry entry = new CacheEntry();\n        entry.value = value;\n        entry.timeInserted = System.currentTimeMillis();\n        this.cacheMap.put(key, entry);\n    }\n\n    public Object get(String key) {\n        CacheEntry entry = this.cacheMap.get(key);\n        if(entry == null) return null;\n        return entry.value;\n    }\n\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Cache {\n\n    private Map&lt;String, CacheEntry&gt; cacheMap = new HashMap&lt;String, CacheEntry&gt;();\n\n    <b>public</b> class CacheEntry {\n        public long   timeInserted = 0;\n        public object value        = null;\n    }\n\n    public void store(String key, Object value){\n        CacheEntry entry = new CacheEntry();\n        entry.value = value;\n        entry.timeInserted = System.currentTimeMillis();\n        this.cacheMap.put(key, entry);\n    }\n\n    public Object get(String key) {\n        CacheEntry entry = this.cacheMap.get(key);\n        if(entry == null) return null;\n        return entry.value;\n    }\n\n    <b>public CacheEntry getCacheEntry(String key) {\n        return this.cacheMap.get(key);\n        }</b>\n\n}\n</pre><p style=\"font-family: Helvetica;\">The first&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class hides its&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">CacheEntry</code>&nbsp;nested class while the second&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Cache</code>&nbsp;class exposes it.</p>"
    }
  ]
}