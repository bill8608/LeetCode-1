{
  "title": "Abstract Classes",
  "cells": [
    {
      "type": "text",
      "data": "<span style=\"font-family: Helvetica;\">A&nbsp;</span><i style=\"font-family: Helvetica;\">Java abstract class</i><span style=\"font-family: Helvetica;\">&nbsp;is a class which cannot be instantiated, meaning you cannot create new instances of an abstract class. <b>The purpose of an abstract class is to function as a base for subclasses.</b> This Java abstract class tutorial explains how abstract classes are created in Java, what rules apply to them. This tutorial gets into the purpose of abstract classes in Java in more detail towards the end of this text.</span>"
    },
    {
      "type": "text",
      "data": "<div><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Declaring an Abstract Class in Java</h2><p style=\"font-family: Helvetica;\">In Java you declare that a class is abstract by adding the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;keyword to the class declaration. Here is a Java abstract class example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public abstract class MyAbstractClass {\n\n}\n</pre><p style=\"font-family: Helvetica;\">That is all there is to declaring an abstract class in Java. Now you cannot create instances of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractClass</code>. Thus, the following Java code is no longer valid:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">MyAbstractClass myClassInstance = \n    new MyAbstractClass();  //not valid\n</pre><p style=\"font-family: Helvetica;\">If you try to compile the code above the Java compiler will generate an error, saying that you cannot instantiate&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractClass</code>&nbsp;because it is an abstract class.</p><a name=\"abstract-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Abstract Methods</h2><p style=\"font-family: Helvetica;\">An abstract class can have abstract methods. You declare a method abstract by adding the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>keyword in front of the method declaration. Here is a Java abstract method example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public abstract class MyAbstractClass {\n\n    public abstract void abstractMethod();\n}\n</pre><p style=\"font-family: Helvetica;\">An abstract method has no implementation. It just has a method signature. Just like methods in a&nbsp;<a href=\"http://tutorials.jenkov.com/java/interfaces.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">Java interface</a>.</p><p style=\"font-family: Helvetica;\">If a class has an abstract method, the whole class must be declared abstract. Not all methods in an abstract class have to be abstract methods. An abstract class can have a mixture of abstract and non-abstract methods.</p><p style=\"font-family: Helvetica;\">Subclasses of an abstract class must implement (override) all abstract methods of its abstract superclass. The non-abstract methods of the superclass are just inherited as they are. They can also be overridden, if needed.</p><p style=\"font-family: Helvetica;\">Here is an example subclass of the abstract class&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractClass</code>:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class MySubClass extends MyAbstractClass {\n\n    public void abstractMethod() {\n        System.out.println(\"My method implementation\");\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MySubClass</code>&nbsp;has to implement the abstract method&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstractMethod()</code>&nbsp;from its abstract superclass&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractClass</code>.</p><p style=\"font-family: Helvetica;\">The only time a subclass of an abstract class is not forced to implement all abstract methods of its superclass, is if the subclass is also an abstract class.</p><a name=\"the-purpose-of-abstract-classes\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">The Purpose of Abstract Classes</h2><p style=\"font-family: Helvetica;\">The purpose of abstract classes is to function as base classes which can be extended by subclasses to create a full implementation. For instance, imagine that a certain process requires 3 steps:</p><ol style=\"margin: 30px 20px; font-family: Helvetica;\"><li>The step before the action.</li><li>The action.</li><li>The step after the action.</li></ol><p style=\"font-family: Helvetica;\">If the steps before and after the action are always the same, the 3-step process could be implemented in an abstract superclass with this Java code:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public abstract class MyAbstractProcess {\n\n    public void process() {\n        stepBefore();\n        action();\n        stepAfter();\n    }\n\n    public void stepBefore() {\n        //implementation directly in abstract superclass\n    }\n\n    public abstract void action(); // implemented by subclasses\n\n    public void stepAfter() {\n        //implementation directly in abstract superclass\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">action()</code>&nbsp;method is abstract. Subclasses of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractProcess</code>&nbsp;can now extend&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractProcess</code>&nbsp;and just override the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">action()</code>&nbsp;method.</p><p style=\"font-family: Helvetica;\">When the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">process()</code>&nbsp;method of the subclass is called, the full process is executed, including the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">stepBefore()</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">stepAfter()</code>&nbsp;of the abstract superclass, and the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">action()</code>&nbsp;method of the subclass.</p><p style=\"font-family: Helvetica;\">Of course, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyAbstractProcess</code>&nbsp;did not have to be an abstract class to function as a base class. Nor did the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">action()</code>&nbsp;method have to be abstract either. You could have just used an ordinary class. However, by making the method to implement abstract, and thus the class too, you signal clearly to users of this class that this class should not be used as it is. Instead it should be used as a base class for a subclass, and that the abstract method should be implemented in the subclass.</p><p style=\"font-family: Helvetica;\">The above example did not have a default implementation for the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">action()</code>&nbsp;method. In some cases your superclass might actually have a default implementation for the method that subclasses are supposed to override. In that case, you cannot make the method abstract. You can still make the superclass abstract though, even if it contains no abstract methods.</p><p style=\"font-family: Helvetica;\">Here is a more concrete example that opens a URL, processes it and closes the connection to the URL afterwards.</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public abstract class URLProcessorBase {\n\n    public void process(URL url) throws IOException {\n        URLConnection urlConnection = url.openConnection();\n        InputStream input = urlConnection.getInputStream();\n\n        try{\n            processURLData(input);\n        } finally {\n            input.close();\n        }\n    }\n\n    protected abstract void processURLData(InputStream input)\n        throws IOException;\n\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">processURLData()</code>&nbsp;is an abstract method, and that&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>&nbsp;is an abstract class. Subclasses of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>&nbsp;have to implement the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">processURLData()</code>&nbsp;method because it is an abstract method.</p><p style=\"font-family: Helvetica;\">Subclasses of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>&nbsp;abstract class can process data downloaded from URLs without worrying about opening and closing the network connection to the URL. This is done by the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>. Subclasses only need to worry about processing the data from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">InputStream</code>passed to the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">processURLData()</code>&nbsp;method. This makes it easier to implement classes that processes data from URLs.</p><p style=\"font-family: Helvetica;\">Here is an example subclass:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class URLProcessorImpl extends URLProcessorBase {\n\n    @Override\n    protected void processURLData(InputStream input) throws IOException {\n        int data = input.read();\n        while(data != -1){\n            System.out.println((char) data);\n            data = input.read();\n        }\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how the subclass only implements the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">processURLData()</code>&nbsp;method, and nothing more. The rest of the code is inherited from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>&nbsp;superclass.</p><p style=\"font-family: Helvetica;\">Here is an example of how to use the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorImpl</code>&nbsp;class:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">URLProcessorImpl urlProcessor = new URLProcessorImpl();\n\nurlProcessor.process(new URL(\"http://jenkov.com\"));\n</pre><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">process()</code>&nbsp;method is called, which is implemented in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>&nbsp;superclass. This method in turn calls the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">processURLData()</code>&nbsp;in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorImpl</code>&nbsp;class.</p></div>"
    }
  ]
}