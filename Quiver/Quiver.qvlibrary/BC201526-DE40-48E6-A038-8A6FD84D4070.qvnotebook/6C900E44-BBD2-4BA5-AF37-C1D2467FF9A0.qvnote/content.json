{
  "title": "Java Interfaces vs. Abstract Classes",
  "cells": [
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": "<div><div id=\"articleBody\" style=\"font-family: Helvetica;\"><p>A question I get a lot is what the difference is between Java interfaces and abstract classes, and when to use each. Having answered this question by email multiple times, I decided to write this tutorial about Java interfaces vs abstract classes.</p><p>Java interfaces are used to decouple the interface of some component from the implementation. In other words, to make the classes using the interface independent of the classes implementing the interface. Thus, you can exchange the implementation of the interface, without having to change the class using the interface.</p><p>Abstract classes are typically used as base classes for extension by subclasses. Some programming languages use abstract classes to achieve polymorphism, and to separate interface from implementation, but in Java you use interfaces for that. Remember, a Java class can only have 1 superclass, but it can implement multiple interfaces. Thus, if a class already has a different superclass, it can implement an interface, but it cannot extend another abstract class. Therefore interfaces are a more flexible mechanism for exposing a common interface.</p><p>If you need to separate an interface from its implementation, use an interface. If you also need to provide a base class or default implementation of the interface, add an abstract class (or normal class) that implements the interface.</p><p>Here is an example showing a class referencing an interface, an abstract class implementing that interface, and a subclass extending the abstract class.</p><table class=\"diagram\" style=\"margin: 20px 0px 30px;\"><tbody><tr><td align=\"center\"><img src=\"quiver-image-url/62C5707F689BC24B3B2BC1374E6A4C21.png\" alt=\"The blue class knows only the interface. The abstract class implements the interface, and the subclass inherits from the abstract class.\"></td></tr><tr><td align=\"center\"><b>The blue class knows only the interface. The abstract class implements the interface, and the subclass inherits from the abstract class.</b></td></tr></tbody></table><p>Below are the code examples from the text on&nbsp;<a href=\"http://tutorials.jenkov.com/java/abstract-classes.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">Java Abstract Classes</a>, but with an interface added which is implemented by the abstract base class. That way it resembles the diagram above.</p><p>First the interface:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public interface URLProcessor {\n\n    public void process(URL url) throws IOException;\n}\n</pre><p>Second, the abstract base class:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public abstract class URLProcessorBase implements URLProcessor {\n\n    public void process(URL url) throws IOException {\n        URLConnection urlConnection = url.openConnection();\n        InputStream input = urlConnection.getInputStream();\n\n        try{\n            processURLData(input);\n        } finally {\n            input.close();\n        }\n    }\n\n    protected abstract void processURLData(InputStream input)\n        throws IOException;\n\n}\n</pre><p>Third, the subclass of the abstract base class:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class URLProcessorImpl extends URLProcessorBase {\n\n    @Override\n    protected void processURLData(InputStream input) throws IOException {\n        int data = input.read();\n        while(data != -1){\n            System.out.println((char) data);\n            data = input.read();\n        }\n    }\n}\n</pre><p>Fourth, how to use the interface&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessor</code>&nbsp;as variable type, even though it is the subclass&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">UrlProcessorImpl</code>&nbsp;that is instantiated.</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">URLProcessor urlProcessor = new URLProcessorImpl();\n\nurlProcessor.process(new URL(\"http://jenkov.com\"));\n</pre><p>Using both an interface and an abstract base class makes your code more flexible. It possible to implement simple URL processors simply by subclassing the abstract base class. If you need something more advanced, your URL processor can just implement the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessor</code>&nbsp;interface directly, and not inherit from&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">URLProcessorBase</code>.</p><div><br></div></div></div>"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}