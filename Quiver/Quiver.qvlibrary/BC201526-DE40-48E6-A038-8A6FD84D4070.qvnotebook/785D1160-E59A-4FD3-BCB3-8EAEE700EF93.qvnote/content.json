{
  "title": "Inheritance",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"font-family: Helvetica;\"><a href=\"http://tutorials.jenkov.com/java/inheritance.html\">http://tutorials.jenkov.com/java/inheritance.html</a><i><br></i></p><p style=\"font-family: Helvetica;\"><i>Java inheritance</i>&nbsp;refers to the ability in Java for one class to inherit from another class. In Java this is also called extending a class. One class can&nbsp;<i>extend</i>&nbsp;another class and thereby&nbsp;<i>inherit</i>&nbsp;from that class.</p><p style=\"font-family: Helvetica;\">When one class inherits from another class in Java, the two classes take on certain roles. The class that extends (inherits from another class) is the&nbsp;<i>subclass</i>&nbsp;and the class that is being extended (the class being inherited from) is the&nbsp;<i>superclass</i>&nbsp;. In other words, the subclass extends the superclass. Or, the subclass inherits from the superclass.</p><p style=\"font-family: Helvetica;\">Another commonly used term for inheritance is&nbsp;<i>specialization</i>&nbsp;and&nbsp;<i>generalization</i>. A subclass is a specialization of a superclass, and a superclass is a generalization of one or more subclasses.</p>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">Inheritance is a Method of Code Reuse</h2><p style=\"font-family: Helvetica;\">Inheritance can be an effective method to share code between classes that have some traits in common, yet allowing the classes to have some parts that are different.</p><p style=\"font-family: Helvetica;\">Here is diagram illustrating a class called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>, which has two subclasses called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>.</p><p style=\"font-family: Helvetica;\"><img src=\"quiver-image-url/CE3EE98E3D799818A47971BBD5CD9A41.jpg\"><br></p><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class is the superclass of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>.&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;are subclasses of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>. The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class can contain those fields and methods that all&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>s need (e.g. a license plate, owner etc.), whereas&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;can contain the fields and methods that are specific to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>s and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>s.</p><p style=\"font-family: Helvetica;\">Note: Some people will claim that inheritance is a way to categorize your classes based on what they are. A&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>is a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>. A&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;is a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>. In practice, however, that is not how you determine which superclasses and subclasses your application needs to have. This is typically determined by how you need to work with them in the application.</p><p style=\"font-family: Helvetica;\">For instance, do you need to refer to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;objects as&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;objects? Do you need to process both&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;objects uniformly? Then it makes sense to have a common&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;superclass for the two classes. If you never process&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;objects in the same way, there is no point in having a common superclass for them, except perhaps to share code between them (to avoid writing duplicate code).</p>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">Class Hierarchies</h2><p style=\"font-family: Helvetica;\">Superclasses and subclasses form an inheritance structure which is also called a&nbsp;<i>class hierarchy</i>. At the top of the class hierarchy you have the superclasses. At the bottom of the class hierarchy you have the subclasses.</p><p style=\"font-family: Helvetica;\">A class hierarchy may have multiple levels, meaning multiple levels of superclasses and subclasses. A subclass may itself be a superclass of other subclasses etc.</p><a name=\"java-inheritance-basics\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Java Inheritance Basics</h2><p style=\"font-family: Helvetica;\">When a class inherits from a superclass, it inherits parts of the superclass methods and fields. The subclass can also override (redefine) the inherited methods. Fields cannot be overridden, but can be \"shadowed\" in subclasses. How all this works is covered later in this text.</p><h3 style=\"margin-top: 30px; font-family: Helvetica;\">What is Inherited?</h3><p style=\"font-family: Helvetica;\">When a subclass extends a superclass in Java, all&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;fields and methods of the superclass are inherited by the subclass. By&nbsp;<i>inherited</i>&nbsp;is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;fields can be called and referenced just like the methods declared directly in the subclass.</p><p style=\"font-family: Helvetica;\">Fields and methods with default (package) access modifiers can be accessed by subclasses only if the subclass is located in the same package as the superclass. Private fields and methods of the superclass can never be referenced directly by subclasses. They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package),&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>&nbsp;methods).</p><p style=\"font-family: Helvetica;\">Constructors are not inherited by subclasses, but a subclass constructor must call a constructor in the superclass. This will be explained in detail in a later section.</p><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Java Only Supports Singular Inheritance</h3><p style=\"font-family: Helvetica;\"><a name=\"java-only-supports-singular-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700;\"></a></p><p style=\"font-family: Helvetica;\">The Java inheritance mechanism only allows a Java class to inherit from a single superclass (singular inheritance). In some programming languages, like C++, it is possible for a subclass to inherit from multiple superclasses (multiple inheritance). Since multiple inheritance can create some weird problems, if e.g. the superclasses contain methods with the same names and parameters, multiple inheritance was left out in Java.</p>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">Declaring Inheritance in Java</h2><p style=\"font-family: Helvetica;\">In Java inheritance is declared using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">extends</code>&nbsp;keyword. You declare that one class&nbsp;<i>extends</i>&nbsp;another class by using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">extends</code>&nbsp;keyword in the class definition. Here is Java inheritance example using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">extends</code>keyword:</p>"
    },
    {
      "type": "code",
      "language": "java",
      "data": "public class Vehicle {\n    protected String licensePlate = null;\n\n    public void setLicensePlate(String license) {\n        this.licensePlate = license;\n    }\n}\npublic class Car extends Vehicle {\n    int numberOfSeats = 0;\n\n    public String getNumberOfSeats() {\n        return this.numberOfSeats;\n    }\n}"
    },
    {
      "type": "text",
      "data": "<p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class in this example extends the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class, meaning the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class inherits from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>class.</p><p style=\"font-family: Helvetica;\">Because the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class extends the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;field&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>class is inherited by the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class. When the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field is inherited, it is accessible inside a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>instance.</p><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field is not actually being referenced from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class in the code above, but it could if we wanted to. Here is an example that shows how that could look:</p>"
    },
    {
      "type": "code",
      "language": "java",
      "data": "public class Car extends Vehicle {\n    int numberOfSeats = 0;\n\n    public String getNumberOfSeats() {\n        return this.numberOfSeats;\n    }\n\n    public String getLicensePlate() {\n        return this.licensePlate;\n    }\n}"
    },
    {
      "type": "text",
      "data": "<p style=\"font-family: Helvetica;\">The referencing happens inside the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">getLicensePlate()</code>&nbsp;method.</p><p style=\"font-family: Helvetica;\">In many cases it would have made sense to place the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">getLicensePlate()</code>&nbsp;method in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class where the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field is located. I just placed the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">getLicensePlate()</code>&nbsp;method in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class to show that it is possible.</p>"
    },
    {
      "type": "text",
      "data": "<h2 style=\"margin-top: 30px; font-family: Helvetica;\">Inheritance and Type Casting</h2><p style=\"font-family: Helvetica;\">It is possible to reference a subclass as an instance of one of its superclasses. For instance, using the class definitions from the example in the previous section it is possible to reference an instance of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class as an instance of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class. Because the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class extends (inherits from) the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class, it is also said to&nbsp;<b>be</b>&nbsp;a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>.</p><p style=\"font-family: Helvetica;\"></p><p style=\"font-family: Helvetica;\">Here is a Java code example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car     car     = new Car();\nVehicle vehicle = car;\n</pre><p style=\"font-family: Helvetica;\">First a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;instance is created. Second, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;instance is assigned to a variable of type&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>. Now the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;variable (reference) points to the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;instance. This is possible because the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class inherits from the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">As you can see, it is possible to use an instance of some subclass as if it were an instance of its superclass. That way, you don't need to know exactly what subclass the object is an instance of. You could treat e.g. both&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;instances as&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;instances.</p><p style=\"font-family: Helvetica;\">The process of referencing an object of class as a different type than the class itself is called type casting. You cast an object from one type to another.</p><a name=\"upcasting-and-downcasting\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Upcasting and Downcasting</h3><p style=\"font-family: Helvetica;\">You can always cast an object of a subclass to one of its superclasses. This is referred to as&nbsp;<i>upcasting</i>&nbsp;(from a subclass type to a superclass type).</p><p style=\"font-family: Helvetica;\">It may also be possible to cast an object from a superclass type to a subclass type, but only if the object really is an instance of that subclass (or an instance of a subclass of that subclass). This is referred to as&nbsp;<i>downcasting</i>(from a superclass type to a subclass type). Thus, this example of downcasting is valid:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car     car     = new Car();\n\n// upcast to Vehicle\nVehicle vehicle = car;\n\n// downcast to car again\nCar     car2    =  (Car) vehicle;\n</pre><p style=\"font-family: Helvetica;\">However, the following downcast example is not valid. The Java compiler will accept it, but at runtime when this code is executed the code will throw a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">ClassCastException</code>.</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Truck   truck   = new Truck();\n\n// upcast to Vehicle\nVehicle vehicle = truck;\n\n// downcast to car again\nCar     car     =  (Car) vehicle;\n</pre><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;object can be upcast to a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;object, but it cannot be downcast to a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;object later. This will result in a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">ClassCastException</code>.</p><a name=\"overriding-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Overriding Methods</h2><p style=\"font-family: Helvetica;\">In a subclass you can override (redefine) methods defined in the superclass. Here is a Java method override example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Vehicle {\n\n    String licensePlate = null;\n\n    public void setLicensePlate(String licensePlate) {\n        this.licensePlate = licensePlate;\n    }\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle {\n\n    public void setLicensePlate(String license) {\n        this.licensePlate = license.toLowerCase();\n    }\n\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how both the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class and the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class defines a method called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>. Now, whenever the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;method is called on a Car object, it is the method defined in the Car class that is called. The method in the superclass is ignored.</p><p style=\"font-family: Helvetica;\">To override a method the method signature in the subclass must be the same as in the superclass. That means that the method definition in the subclass must have exactly the same name and the same number and type of parameters, and the parameters must be listed in the exact same sequence as in the superclass. Otherwise the method in the subclass will be considered a separate method.</p><p style=\"font-family: Helvetica;\">In Java you cannot override private methods from a superclass. If the superclass calls a private method internally from some other method, it will continue to call that method from the superclass, even if you create a private method in the subclass with the same signature.</p><a name=\"the-override-annotation\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h3 style=\"margin-top: 30px; font-family: Helvetica;\">The @override Annotation</h3><p style=\"font-family: Helvetica;\">If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass. But how do you know? It would be nice if the compiler could tell you that the method being overridden no longer overrides a method in the superclass, right?</p><p style=\"font-family: Helvetica;\">This is what the Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">@override</code>&nbsp;annotation is for. You place the Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">@override</code>&nbsp;annotation above the method that overrides a method in a superclass. Here is Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">@override</code>&nbsp;example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle {\n\n    @Override\n    public void setLicensePlate(String license) {\n        this.licensePlate = license.toLowerCase();\n    }\n\n}\n</pre><a name=\"calling-super-class-methods\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h3 style=\"margin-top: 30px; font-family: Helvetica;\">Calling Superclass Methods</h3><p style=\"font-family: Helvetica;\">If you override a method in a subclass, but still need to call the method defined in the superclass, you can do so using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">super</code>&nbsp;reference, like this:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle {\n\n    public void setLicensePlate(String license) {\n        <b>super.setLicensePlate(license);</b>\n    }\n\n}\n</pre><p style=\"font-family: Helvetica;\">In the above code example the method&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class, calls the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;method in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">You can call superclass implementations from any method in a subclass, like above. It does not have to be from the overridden method itself. For instance, you could also have called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">super.setLicensePlate()</code>&nbsp;from a method in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class called&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">updateLicensePlate()</code>&nbsp;which does not override the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>method.</p><a name=\"the-instanceof-instruction\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">The instanceof Instruction</h2><p style=\"font-family: Helvetica;\">Java contains an instruction named&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>. The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;instruction can determine whether a given object is an instance of some class. Here is a Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car car = new Car();\n\nboolean isCar = car instanceof Car;\n</pre><p style=\"font-family: Helvetica;\">After this code has been executed the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">isCar</code>&nbsp;variable will contain the value&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">true</code>.</p><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;instruction can also be used determine if an object is a instance of a superclass of its class. Here is an&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;example that checks if a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;object is an instance of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car car = new Car();\n\nboolean isVehicle = car instanceof Vehicle;\n</pre><p style=\"font-family: Helvetica;\">Assuming that the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class extends (inherits from) the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">isVehicle</code>&nbsp;variable will contain the value&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">true</code>&nbsp;after this code is executed. A&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;object is also a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;object because&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;is a subclass of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>.</p><p style=\"font-family: Helvetica;\">As you can see, the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;instruction can be used to explore the inheritance hierarchy.</p><p style=\"font-family: Helvetica;\">The variable type used with the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;instruction does not affect its outcome. Look at this&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car car = new Car();\n\nVehicle vehicle = car;\n\nboolean isCar = vehicle instanceof Car;\n</pre><p style=\"font-family: Helvetica;\">Even though the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">vehicle</code>&nbsp;variable is of type&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>, the object it ends up pointing to in this example is a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>object. Therefore the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">vehicle instanceof Car</code>&nbsp;instruction will evaluate to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">true</code>.</p><p style=\"font-family: Helvetica;\">Here is the same&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">instanceof</code>&nbsp;example, but using a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;object instead of a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;object:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Truck truck = new Truck();\n\nVehicle vehicle = truck;\n\nboolean isCar = vehicle instanceof Car;\n</pre><p style=\"font-family: Helvetica;\">After executing this code the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">isCar</code>&nbsp;will contain the value&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">false</code>. The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Truck</code>&nbsp;object is not a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;object.</p><a name=\"fields-and-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Fields and Inheritance</h2><p style=\"font-family: Helvetica;\">As mentioned earlier, in Java fields cannot be overridden in a subclass. If you define a field in a subclass with the same name as a field in the superclass, the field in the subclass will hide (shadow) the field in the superclass. If the subclass tries to access the field, it will access the field in the subclass.</p><p style=\"font-family: Helvetica;\">If, however, the subclass calls up into a method in the superclass, and that method accesses the field with the same name as in the subclass, it is the field in the superclass that is accessed.</p><p style=\"font-family: Helvetica;\">Here is Java inheritance example that illustrates how fields in subclasses shadow (hides) fields in superclasses:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Vehicle {\n\n    String licensePlate = null;\n\n    public void setLicensePlate(String licensePlate) {\n        this.licensePlate = licensePlate;\n    }\n\n    public String getLicensePlate() {\n        return licensePlate;\n    }\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle {\n\n    protected String licensePlate = null;\n\n    @Override\n    public void setLicensePlate(String license) {\n        super.setLicensePlate(license);\n    }\n\n    @Override\n    public String getLicensePlate() {\n        return super.getLicensePlate();\n    }\n\n    public void updateLicensePlate(String license){\n        this.licensePlate = license;\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how both classes have a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field defined.</p><p style=\"font-family: Helvetica;\">Both the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class has the methods&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;and&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">getLicensePlate()</code>. The methods in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class calls the corresponding methods in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class. The result is, that eventually both set of methods access the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">updateLicensePlate()</code>&nbsp;method in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class however, accesses the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field directly. Thus, it accesses the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class. Therefore, you will not get the same result if you call&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;as when you call the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">updateLicense()</code>&nbsp;method.</p><p style=\"font-family: Helvetica;\">Look at the following lines of Java code:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">Car car = new Car();\n\ncar.setLicensePlate(\"123\");\ncar.updateLicensePlate(\"abc\");\n\nSystem.out.println(\"license plate: \"\n        + car.getLicensePlate());\n</pre><p style=\"font-family: Helvetica;\">This Java code will print out the text&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">123</code>.</p><p style=\"font-family: Helvetica;\">The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">updateLicensePlate()</code>&nbsp;method sets the license plate value on the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>class. The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">getLicensePlate()</code>&nbsp;method, however, returns the value of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class. Therefore, the value&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">123</code>&nbsp;which is set as value for the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">licensePlate</code>&nbsp;field in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>class via the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">setLicensePlate()</code>&nbsp;method, is what is printed out.</p><a name=\"constructors-and-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Constructors and Inheritance</h2><p style=\"font-family: Helvetica;\">The Java inheritance mechanism does not include constructors. In other words, constructors of a superclass are not inherited by subclasses. Subclasses can still call the constructors in the superclass using the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">super()</code>contruct. In fact, a subclass constructor is required to call one of the constructors in the superclass as the very first action inside the constructor body. Here is how that looks:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Vehicle {\n\n    public Vehicle() {\n    }\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle{\n\n    public Car() {\n        super();\n\n        //perform other initialization here\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice the call to&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">super()</code>&nbsp;inside the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;constructor. This&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">super()</code>&nbsp;call executes the constructor in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">You may have seen Java classes where the subclass constructors did not seem to call the constructors in the superclass. Maybe the superclass did not even have a constructor. However, the subclass constructors have still called superclass constructors in those case. You just could not see it. Let me explain why:</p><p style=\"font-family: Helvetica;\">If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor. Thus, a class always has a constructor. Therefore the following version of&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;is equivalent to the version shown just above:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Vehicle {\n}\n</pre><p style=\"font-family: Helvetica;\">Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass. That means that the following version of the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class is actually equivalent to the version shown earlier:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle{\n\n    public Car() {\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass. This is how the two classes would look then:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Vehicle {\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class Car extends Vehicle{\n}\n</pre><p style=\"font-family: Helvetica;\">Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class will call the no-arg constructor in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">If the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class did not have a no-arg constructor, but had another constructor which takes parameters, the Java compiler would complain. The&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Car</code>&nbsp;class would then be required to declare a constructor, and inside that constructor call the constructor in the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">Vehicle</code>&nbsp;class.</p><a name=\"nested-classes-and-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Nested Classes and Inheritance</h2><p style=\"font-family: Helvetica;\">The same Java inheritance rules apply to&nbsp;<a href=\"http://tutorials.jenkov.com/java/nested-classes.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">nested classes</a>. Nested classes which are declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">private</code>&nbsp;are not inherited. Nested classes with the default (package) access modifier are only accessible to subclasses if the subclass is located in the same package as the superclass. Nested classes with the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">protected</code>&nbsp;or&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">public</code>access modifier are always inherited by subclasses.</p><p style=\"font-family: Helvetica;\">Here is a nested class inheritance example:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">class MyClass {\n\n    class MyNestedClass {\n\n    }\n}\n</pre><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public class MySubclass extends MyClass {\n\n    public static void main(String[] args) {\n        MySubclass subclass = new MySubclass();\n\n        MyNestedClass nested =  subclass.new MyNestedClass();\n    }\n}\n</pre><p style=\"font-family: Helvetica;\">Notice how it is possible to create an instance of the nested class&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">MyNestedClass</code>&nbsp;which is defined in the superclass (<code style=\"font-family: Courier; font-size: 1em;\">MyClass</code>) via a reference to the subclass (<code style=\"font-family: Courier; font-size: 1em;\">MySubclass</code>).</p><a name=\"final-classes\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Final Classes and Inheritance</h2><p style=\"font-family: Helvetica;\">A class can be declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">final</code>. Here is now that looks:</p><pre class=\"codeBox\" style=\"background-color: rgb(240, 240, 240); color: rgb(0, 0, 0); border: 1px solid rgb(204, 204, 204); font-family: Courier; font-size: 0.8em; padding: 10px; margin-top: 20px; margin-bottom: 20px; max-width: 100%; overflow-x: auto;\">public final class MyClass {\n\n}\n</pre><p style=\"font-family: Helvetica;\">A&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">final</code>&nbsp;class cannot be extended. In other words, you cannot inherit from a&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">final</code>&nbsp;class in Java.</p><a name=\"abstract-classes-and-inheritance\" style=\"color: rgb(85, 26, 139); font-weight: 700; font-family: Helvetica;\"></a><span style=\"font-family: Helvetica;\"></span><h2 style=\"margin-top: 30px; font-family: Helvetica;\">Abstract Classes and Inheritance</h2><p style=\"font-family: Helvetica;\">In Java a class can be declared&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>. I have explained&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;classes in more detail in my&nbsp;<a href=\"http://tutorials.jenkov.com/java/abstract-classes.html\" style=\"color: rgb(85, 26, 139); text-decoration: none; font-weight: 700;\">Java abstract classes tutorial</a>.</p><p style=\"font-family: Helvetica;\">An&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;class is a class that does not contain the full implementation of whatever the&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;class should do. Thus, it cannot be instantiated. In other words, you cannot create objects of an&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;class.</p><p style=\"font-family: Helvetica;\">In Java&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;classes are intended to be extended to create a full implementation. Thus, it is fully possible to extend an&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;class. The Java inheritance rules are the same for&nbsp;<code style=\"font-family: Courier; font-size: 1em;\">abstract</code>&nbsp;classes as for non-abstract classes.</p>"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}