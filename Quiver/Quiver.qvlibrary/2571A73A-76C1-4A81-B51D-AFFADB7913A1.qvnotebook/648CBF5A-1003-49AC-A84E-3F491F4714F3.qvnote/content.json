{
  "title": "Wayfair Final Round Technical",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "1.OA2\nAt first,I create a ArrayList to store the result.\nAnd then I check the input list, if equals null or the size equals zero, we just return result list.\n\nNext step, I add a empty string to initialize the result list.\n\nAnd then I traverse the input list.\nand we are creating a tempRes arraylist to store the combination which are previous level combination words.\n\nand then I reset the result list, since we use result list to store the current level combination words.\n\nWe use list to get the i th input string list.\n\nand these two for loop is using to combine the previous combination with the new string from ith input list.\n\nwe notice that , if i equals zero, which means the previous combination word equals empty string, so we just add the word from list into to the result, but if i doesn't equals zero, which means we can get the previous word and combine to the word from input list.\n\nso we repeat these steps, util we traveser all the input string list.\n\nthen the result already have all the combination words.\n\n\nFor example the input string list  like :\ninput = {{a, b}, {c, d}, {e, f}},\n\n\ni = 0, tempRes = {\"\"};  res = {}, list = input.get(0) = {a,b},\n     we just add a and b to the res, res = {a, b};\n     \ni = 1, tempRes = {a, b}, res = {}, list = input.get(1) = {c, d};\n    a + c = ac,\n    a + d = ad,\n    b + c = bc,\n    b + d = bd,\n    res = {ac, ad, bc, bd};\n    \n    we repeat this steps util traverse all the input\ni = 2,  tempRes = {ac, ad, bc, bd}, res = {},  list = input.get(2) = {e, f}\n    ac + e = ace,\n    ac + f = acf,\n    ad + e = ade.\n    bc + e = bce,\n    bc + f = bcf,\n    bd + e = bde,\n    bd + f = bdf,\n    \n    res = {ace, acf, ade, bce, bcf, bde, bdf};\n\nand the time complextity, we assume the size of input list equals n, and every string list from input equals(len1, len2..lenN) \n\nO(n *  len1 * len1 * len2 * len2 * len3 * len3 * len4....lenN-1 * lenN)\n\nSpace complexity is equals the size of the  \n    \n    \n    \n    \n    \n    "
    },
    {
      "type": "code",
      "language": "java",
      "data": "2. Move Positive And Negative\n\n1. Question:\n    (1)How about the number zero? We regard the zero as negative number or positive number?\n    (2)Shoud we matain the orginal order?\n\n\n\n2. Solution1: \nO(n) space, O(n) time\nWe can have another array of same size and navigate the input array, in first scan we place all the negative numbers to the new array ,and in second scan we place all the positive numbers to new array. \n\nIdea:\nI think we can use a extra space, we traverse the input array two times, in the first scan, when we meet negative number, and we just put it to the new array, and then we set a counter to record the numbers of negative number. And then, we start a next loop, in second loop, when we meet positive number, we just assign it to the new array. So after two traverse, we get a new array which is partition by the negative number and positive number, the order still doesn't change, Does it make sense?\n\nAnalysis: since we only need 2times scan, so the time complexity is O(n)\n          we need to use a same size new Array, so the space complexity is O(n)\n\n3. Solution2: \nO(1) space, O(n*n) time\nQuestion: O(1) space , so we can not use any extra space,right? But how about the time complexity?Is there any limited for the time complexity?\n\nIdea:\nCan we use the idea similar with the bubble sort right? We use two pointer, one pointer record the first positive number's position, use another pointer to travese the array, when we meet a number which is less than zero, we continually swap it from the end and stop to the position of first positive number. \n\nAnalysis:\nthe time complexity in worst case will be O(n*n): like bubble sort, right, the positive number in the left part, the negative number in the right part.\nthe best case is O(n) for example, if all  the number is positive number, we don't  need to swap any number\n\n3. Solution3:\nO(1) space, O(nlogn) time\n\nIdea: \n    We can use a approach which is similar to merge sort.\n    Divide the array into two half, and solve them individually and merge them.\n    Merging: (Negative on left side and positives on the right side)\n\nAt first, we navigate the left half of array utill we don’t find a positive integer and reverse the array after that point.(Say that part is called ‘A’)\n\nand then we navigate the right half of array utill we don’t find a positive integer and reverse the array before that point. (Say that part is called ‘B’)\n\nNow reverse the those parts from both the array (A and B), See example for better explanation\n\n\nC: -1,-2,1,2, -3,-4,5,6 \nA: -1, -2, 2, 1\nB: -4, -3, 5, 6\n\n-1, -2, -3, -4, 1, 2, 5, 6\n"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "3. Random generate K number\n\nMay I use the java Random API?\nAre those selected number need to be unique\n\n1. Solution1: randomly generate one number\n\nWe can just use the random api to generate a number, the number's value from zero to the input array'length - 1. and We just return this number from array.\n\n2. Solution2: \nthe time complexity is O(n)\nMay I use a HashSet?\nUsing a hashset, the key is integer, we use the random API to generate the index of input array, and then put the item into the hashset, when the size of hashset equals K, and we stop the loop, and return this hashset.\n\n\n3. Solution3 reservior sampling change the array:\n\nthe time complexity is O(k), the space complexity also is O(k)\n\nWe can use a extra array, the size of array equals K.\nwe randomly generate a index, and get the value of this array index to the res array, and swap this value to the end of array,\n\nnext time we continue randomly generate another index from 0 to len - 1, and put it to the result array, and swap it to the penultimate [pi'nʌltimit] position, we repeat do that util we already select k number.\n\nThe probability of every number will be  selected is same. \nFor example we have array contains 6 number from 1 to 6, [1, 2, 3, 4, 5, 6],\nat first time we randomly pickup 3, and we swap 3 to the end of array, [1,2,6,4,5,3],\nand next time we randomly pick up number 1, and we swap 1 to the  penultimate [pi'nʌltimit] of array, [5, 2, 6, 4, 1, 3]\nwe do this uitl k times, so the probability that the first number will be selected equals one in six, 1/6\nthe second number will be selected equals five in six  mutiply one in 5, 5/6 * 1/5 equals one in six.\n\nso the probabilty of every number will be picked up equals one in six(1/6) in this process.\n\n\n4.Solution4 reservior sampling without change the array\nthe time complexity is O(n - k), the space complexity is O(k)\n\n1) Create an array the size equals k, we call it result array,and copy first k items of input array[] to it.\n2) Now one by one consider all items from (k+1)th item to nth item in the input array\n\n…a) Generate a random number from 0 to i where i is index of current item in input array[]. Let the generated random number is j.\n…b) If j is in range 0 to k-1, replace result arr[j] with input arr[i]\n\n\nfor example if the array is [1, 2, 3, 4, 5] and k equals 3, at first we pick up [1, 2, 3] to the result array\n\nand then we randomly generate a number from 0 to 3, if the random number range is in 0 to 2, wo just swap 4 to the random position,otherwise 4 still in the orginal position.\nin next time, we randomly generate a number from 0 to 4,  if the random number is in 0 to 3,  we swap 5 to the index, otherwise it still in the original position\n\n\n\n\n\n"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}