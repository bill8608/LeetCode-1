{
  "title": "Schedule",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "1.Question:\n    (1)Is there any unvalid input such as the end time is no larger than start time?\n    (2)Does a content will appear more than once?If yes, if they in same location, how to define which one is valid?, if they in different  location, if they are all valid in their location, will it work?\n    (3)How to define the valid sequence? Which content come first and the later content if has overlap, so it will be unvalid content?\n"
    },
    {
      "type": "code",
      "language": "java",
      "data": "2. Solution1: \n    1. 首先对输入进行筛选，只有valid的time(startTime < endTime)才可以加入List\n    2. 构造一个HashMap<String, List<ScheduleRequest>> locationMap; key是location， value是所有同一个location的schedule\n    3. 创建一个comparator，按照startTime，从小到大排序\n    4. 遍历locationMap的values：\n      \n      for (String location : locationMap.keySet()) {\n  \t\t\tHashSet<String> set = new HashSet<>();//用来去重同一个地区的多个相同id的content\n  \t\t\tList<ScheduleRequest> sameLocationReq = locationMap.get(location);\n  \t\t\tCollections.sort(sameLocationReq, comp);//按照startTime 排序\n  \t\t\tint index = 0;\n  \t\t\tScheduleRequest pre = sameLocationReq.get(index);\n  \t\t\tset.add(pre.getId());\n  \t\t\tindex++;\n  \t\t\t/*\n  \t\t\t   将相邻的两个content进行对比，因为按照start进行排序，只要对比cur的startTime是否大于pre的                                                            endTime,(1)如果不大于，则是冲突的schedule，加入unValidReq List,并从原先的List里remove掉这个                                                     schedule。(2)如果大于，则说明是一个有效的schedule，将其Id加入set记录以避免以后的重复，并将pre = cur,inde++，进行下一次对比\n  \t\t\t*/\n  \t\t\twhile (index < sameLocationReq.size()) {\n  \t\t\t\tScheduleRequest cur = sameLocationReq.get(index);\n  \t\t\t\tif (set.contains(cur.getId()) || !checkTwoReqTime(pre, cur)) {\n  \t\t\t\t\tunValidReq.add(cur);\n  \t\t\t\t\tsameLocationReq.remove(cur);\n  \t\t\t\t} else {\n  \t\t\t\t\tset.add(cur.getId());\n  \t\t\t\t\tpre = cur;\n  \t\t\t\t\tindex++;\n  \t\t\t\t} \n  \t\t\t}\n  \t\t}\n"
    },
    {
      "type": "code",
      "language": "java",
      "data": "Solution2:\npackage schedule;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class ScheduleVersion5 {\n\tpublic static List<List<ScheduleRequest>> schedule(List<ScheduleRequest> requests, HashMap<String, Integer> contentScoreMap, HashMap<String, Double> locationValueMap) {\n\t\tList<List<ScheduleRequest>> res = new ArrayList<>();\n\t\tif (requests == null || requests.size() == 0) {\n\t\t\treturn res;\n\t\t}\n\t\tList<ScheduleRequest> unValidReq = new ArrayList<>();\n\t\tList<ScheduleRequest> validReq = new ArrayList<>();\n\t\tfor (int i = 0; i < requests.size(); i++) {\n\t\t\tif (isValidTime(requests.get(i))) {\n\t\t\t\tvalidReq.add(requests.get(i));\n\t\t\t} else {\n\t\t\t\tunValidReq.add(requests.get(i));\n\t\t\t}\n\t\t}\n\t\tList<ScheduleRequest> validRes = new ArrayList<>();\n\t\tList<ScheduleRequest> unvalidRes = new ArrayList<>();\n\t\tComparator<ScheduleRequest> comp = new Comparator<ScheduleRequest>() {\n\t\t\t@Override\n\t\t\tpublic int compare(ScheduleRequest o1, ScheduleRequest o2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn o1.getStartTime() - o2.getStartTime();\n\t\t\t}\t\t\n\t\t};\n\t\tCollections.sort(validReq, comp);\n\t\tHashMap<String, HashMap<Integer, String>> locationMap = new HashMap<>();\n\t\tfor (ScheduleRequest request : validReq) {\n\t\t\tString location = request.getLocation();\n\t\t\tString id = request.getId();\n\t\t\tif (!locationMap.containsKey(location)) {\n\t\t\t\tlocationMap.put(location, new HashMap<Integer, String>());\n\t\t\t\tfor (int i = 0; i <= 23; i++) {\n\t\t\t\t\tlocationMap.get(location).put(i, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startTime = request.getStartTime();\n\t\t\tint endTime = request.getEndTime();\n\t\t\t\n\t\t\tif (checkTime(locationMap.get(location), startTime, endTime, id)) {\n\t\t\t\tfor (int i = startTime; i <= endTime; i++) {\n\t\t\t\t\tlocationMap.get(location).put(i, id);\n\t\t\t\t}\n\t\t\t\tvalidRes.add(request);\n\t\t\t} else {\n\t\t\t\tif (!unValidReq.contains(request)) {\n\t\t\t\t\tunValidReq.add(request);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres.add(new ArrayList<ScheduleRequest>());\n\t\tres.add(new ArrayList<ScheduleRequest>());\n\t\tres.get(0).addAll(validRes);\n\t\tres.get(1).addAll(unValidReq);\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean checkTime(HashMap<Integer, String> timeMap, int startTime, int endTime, String id) {\n\t\tfor (int i = startTime; i <= endTime; i++) {\n\t\t\tif (!(timeMap.get(i).equals(\"\")) || timeMap.get(i).equals(id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isValidTime(ScheduleRequest request) {\n\t\tif (request == null) {\n\t\t\treturn false;\n\t\t}\n\t\tint startTime = request.getStartTime();\n\t\tint endTime = request.getEndTime();\n\t\n\t\tif (startTime >= endTime) { \n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"
    }
  ]
}