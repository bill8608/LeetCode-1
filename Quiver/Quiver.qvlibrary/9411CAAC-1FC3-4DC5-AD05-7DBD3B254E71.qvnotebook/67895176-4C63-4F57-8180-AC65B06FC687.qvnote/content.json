{
  "title": "String",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "/*\n\tString \n*/\n\n\n\n1. Math, Alphabet, Game, Other\n\t\t1.1 Game Proble\n\t\t\t1.1.1 Flip Game I\n\t\t\t\t/*\n\t\t\t\t\tFor example, given s = \"++++\", after one move, it may become one of the following states:\n\t\t\t\t\t[\n\t\t\t\t\t  \"--++\",\n\t\t\t\t\t  \"+--+\",\n\t\t\t\t\t  \"++--\"\n\t\t\t\t\t]\n\t\t\t\t\tT(N) = T(N-2) + T(N-3) + [T(2) + T(N-4)] + [T(3) + T(N-5)] + ... \n\t\t\t\t\t        [T(N-5) + T(3)] + [T(N-4) + T(2)] + T(N-3) + T(N-2)\n\t\t\t\t\t     = 2 * sum(T[i])  (i = 3..N-2)\n\t\t\t\t*/\n\t\t\t\t//I\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> generatePossibleNextMoves(String s) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (s == null || s.length() < 2) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t\t            if (s.startsWith(\"++\", i)) {\n\t\t\t\t                res.add(s.substring(0, i) + \"--\" + s.substring(i + 2));\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.1.2 Flip Game II\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean canWin(String s) {\n\t\t\t\t        if (s == null || s.length() < 2) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < s.length() - 1; i++) {\n\t\t\t\t            if (s.startsWith(\"++\", i)) {\n\t\t\t\t                String item = s.substring(0, i) + \"--\" +s.substring(i + 2);\n\t\t\t\t                //If the opponent can't win, then we win,recursively check the result\n\t\t\t\t                if (!canWin(item)) {\n\t\t\t\t                    return true;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t1.2 Alphabet Convert Problem\n\t\t\t1.2.1 Integer To Roman\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic static String intToRoman(int num) {\n\t\t\t\t\t\t//\t\t\t\t  1000, 2000, 3000\n\t\t\t\t        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n\n\t\t\t\t        //                100,  200,  300,   400, 500,  600,  700,   800,   900\n\t\t\t\t        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n\n\t\t\t\t        //                10,   20,   30,    40,  50,   60,   70,    80,    90  \n\t\t\t\t        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n\n\t\t\t\t        //                1,    2,    3,     4,   5,    6,    7,     8,     9\n\t\t\t\t        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n\n\t\t\t\t        return M[num / 1000] + C[(num % 1000) / 100] + X[(num % 100) / 10] + I[num % 10];\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.2.2 Roman To Integer\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public int romanToInt(String s) {\n\t\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t\t            return 0;\n\t\t\t\t        }\n\t\t\t\t        int res = 0;\n\t\t\t\t        for (int i = s.length() - 1; i >= 0; i--) {\n\t\t\t\t            char c = s.charAt(i);\n\t\t\t\t            if (c == 'I') {\n\t\t\t\t                if (res >= 5) {\n\t\t\t\t                    res -= 1;\n\t\t\t\t                } else {\n\t\t\t\t                    res += 1;\n\t\t\t\t                }\n\t\t\t\t            } else if (c == 'V') {\n\t\t\t\t                res += 5;\n\t\t\t\t            } else if (c == 'X') {\n\t\t\t\t                if (res >= 50) {\n\t\t\t\t                    res -= 10;\n\t\t\t\t                } else {\n\t\t\t\t                    res += 10;\n\t\t\t\t                }\n\t\t\t\t            } else if (c == 'L') {\n\t\t\t\t                res += 50;\n\t\t\t\t            } else if (c == 'C') {\n\t\t\t\t                if (res >= 500) {\n\t\t\t\t                    res -= 100;\n\t\t\t\t                } else {\n\t\t\t\t                    res += 100;\n\t\t\t\t                }\n\t\t\t\t            } else if (c == 'D') {\n\t\t\t\t                res += 500;\n\t\t\t\t            } else if (c == 'M') {\n\t\t\t\t                res += 1000;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.2.3 Integer To English Words\n\t\t\t\tpublic class Solution {\n\t\t\t\t    private final String[] lessThan20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n\t\t\t\t    private final String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\t\t\t\t    private final String[] thousands = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\t\t\t\t    public String numberToWords(int num) {\n\t\t\t\t        if (num == 0) {\n\t\t\t\t            return \"Zero\";\n\t\t\t\t        }\n\t\t\t\t        int i = 0;\n\t\t\t\t        String words = \"\";\n\t\t\t\t        while (num > 0) {\n\t\t\t\t            if (num % 1000 != 0) {\n\t\t\t\t                words = helper(num % 1000) + thousands[i] + \" \" + words;\n\t\t\t\t            }\n\t\t\t\t            num /= 1000;\n\t\t\t\t            i++;\n\t\t\t\t        }\n\t\t\t\t        return words.trim();\n\t\t\t\t    }\n\t\t\t\t    private String helper(int num) {\n\t\t\t\t        if (num == 0) {\n\t\t\t\t            return \"\";\n\t\t\t\t        } else if (num < 20) {\n\t\t\t\t            return lessThan20[num] + \" \";\n\t\t\t\t        } else if (num < 100) {\n\t\t\t\t            return tens[num / 10] + \" \" + helper(num % 10);\n\t\t\t\t        } else {\n\t\t\t\t            return lessThan20[num / 100] + \" Hundred \" + helper(num % 100);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t1.3 Math Problem\n\t\t\t1.3.1 Add Binary\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public String addBinary(String a, String b) {\n\t\t\t\t        if (a == null || a.length() == 0) {\n\t\t\t\t            return b;\n\t\t\t\t        }\n\t\t\t\t        if (b == null || b.length() == 0) {\n\t\t\t\t            return a;\n\t\t\t\t        }\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        int flag = 0;\n\t\t\t\t        int i = a.length() - 1;\n\t\t\t\t        int j = b.length() - 1;\n\t\t\t\t        while (i >= 0 || j >= 0) {\n\t\t\t\t            if (i >= 0) {\n\t\t\t\t                flag += a.charAt(i) - '0';\n\t\t\t\t                i--;\n\t\t\t\t            }\n\t\t\t\t            if (j >= 0) {\n\t\t\t\t                flag += b.charAt(j) - '0';\n\t\t\t\t                j--;\n\t\t\t\t            }\n\t\t\t\t            sb.insert(0, flag % 2);\n\t\t\t\t            flag = flag / 2;\n\t\t\t\t        }\n\t\t\t\t        if (flag == 1) {\n\t\t\t\t            sb.insert(0, \"1\");\n\t\t\t\t        }\n\t\t\t\t        return sb.toString();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.3.2 Multiply Strings\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public String multiply(String num1, String num2) {\n\t\t\t\t        int len1 = num1.length();\n\t\t\t\t        int len2 = num2.length();\n\t\t\t\t        int[] products = new int[num1.length() + num2.length()];\n\t\t\t\t        for (int i = len1 - 1; i >= 0; i--) {\n\t\t\t\t            for (int j = len2 - 1; j >= 0; j--) {\n\t\t\t\t                int a = num1.charAt(i) - '0';\n\t\t\t\t                int b = num2.charAt(j) - '0';\n\t\t\t\t                products[i + j + 1] += a * b;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        int carry = 0;\n\t\t\t\t        for (int i = products.length - 1; i >= 0; i--) {\n\t\t\t\t            int temp = (carry + products[i]) % 10;\n\t\t\t\t            carry = (carry + products[i]) / 10;\n\t\t\t\t            products[i] = temp;\n\t\t\t\t        }\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        for (int num : products) {\n\t\t\t\t            sb.append(num);\n\t\t\t\t        }\n\t\t\t\t        while (sb.length() != 0 && sb.charAt(0) == '0') {\n\t\t\t\t            sb.deleteCharAt(0);\n\t\t\t\t        }\n\t\t\t\t        return sb.length() == 0 ? \"0\" : sb.toString();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t1.4 Compare Problem\n\t\t\t1.4.1 Compare Version Numbers\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public int compareVersion(String version1, String version2) {\n\t\t\t\t        String[] v1 = version1.split(\"\\\\.\");\n\t\t\t\t        String[] v2 = version2.split(\"\\\\.\");\n\t\t\t\t        int len = Math.max(v1.length, v2.length);\n\t\t\t\t        for (int i = 0; i < len; i++) {\n\t\t\t\t            Integer i1 = i < v1.length ? Integer.parseInt(v1[i]) : 0; \n\t\t\t\t            Integer i2 = i < v2.length ? Integer.parseInt(v2[i]) : 0;\n\t\t\t\t            if (i1 > i2) {\n\t\t\t\t                return 1;\n\t\t\t\t            } else if (i1 < i2) {\n\t\t\t\t                return -1;\n\t\t\t\t            } \n\t\t\t\t        }\n\t\t\t\t        return 0;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.4.2 Compare Strings\n\t\t\t\t/*\n\t\t\t\t\tCompare two strings A and B, determine whether A contains all of the characters in B.\n\t\t\t\t\tThe characters in string A and B are all Upper Case letters.\n\t\t\t\t\tExample\n\t\t\t\t\t\tFor A = \"ABCD\", B = \"ACD\", return true.\n\t\t\t\t\t\tFor A = \"ABCD\", B = \"AABC\", return false.\n\t\t\t\t\tNote\n\t\t\t\t\t\tThe characters of B in A are not necessary continuous or ordered.\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean compareStrings(String A, String B) {\n\t\t\t\t        int[] arrA = new int[256];\n\t\t\t\t        for (int i = 0; i < A.length(); i++) {\n\t\t\t\t            arrA[A.charAt(i) - '0']++;\n\t\t\t\t        }\n\t\t\t\t        int count = 0;\n\t\t\t\t        for (int i = 0; i < B.length(); i++) {\n\t\t\t\t            if (arrA[B.charAt(i) - '0'] > 0) {\n\t\t\t\t                arrA[B.charAt(i) - '0']--;\n\t\t\t\t                count++;\n\t\t\t\t            } \n\t\t\t\t        }\n\t\t\t\t        return count == B.length();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t1.5\tOthers \n\t\t\t1.5.1 Count And Say\n\t\t\t/*\n\t\t\t\tThe count-and-say sequence is the sequence of integers beginning as follows:\n\t\t\t\t1, 11, 21, 1211, 111221, ...\n\n\t\t\t\t1 is read off as \"one 1\" or 11.\n\t\t\t\t11 is read off as \"two 1s\" or 21.\n\t\t\t\t21 is read off as \"one 2, then one 1\" or 1211.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public String countAndSay(int n) {\n\t\t\t        if (n == 0) {\n\t\t\t            return \"\";\n\t\t\t        } \n\t\t\t        String res = \"1\";\n\t\t\t        int count = 1;\n\t\t\t        for (int i = 1; i < n; i++) {\n\t\t\t            StringBuilder curRes = new StringBuilder();\n\t\t\t            for (int i = 1; j < res.length(); j++) {\n\t\t\t                if (res.charAt(i - 1) == res.charAt(i)) {\n\t\t\t                    count++;\n\t\t\t                } else {\n\t\t\t                    curRes.append(count);\n\t\t\t                    curRes.append(res.charAt(i - 1));\n\t\t\t                    count = 1;\n\t\t\t                }\n\t\t\t            }\n\t\t\t            curRes.append(count);\n\t\t\t            curRes.append(res.charAt(res.length() - 1));\n\t\t\t            count = 1;\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\n\t\t\n\n\n2. Longest Problem\n\t\t2.1 Longest Substring With At Most Two Distinct Characters\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLongestSubstringTwoDistinct(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        HashMap<Character, Integer> map = new HashMap<>();\n\t\t\t        int maxLen = 0;\n\t\t\t        int start = 0;\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (!map.containsKey(c) && map.size() == 2) {//key point\n\t\t\t                int leftCharPos = s.length();\n\t\t\t                char leftChar = ' ';\n\t\t\t                for (char ch : map.keySet()) {\n\t\t\t                    if (map.get(ch) < leftCharPos) {\n\t\t\t                        leftCharPos = map.get(ch);\n\t\t\t                        leftChar = ch;\n\t\t\t                    }\n\t\t\t                }\n\t\t\t                start = leftCharPos + 1;\n\t\t\t                map.remove(leftChar);\n\t\t\t            }\n\t\t\t            map.put(c, i);\n\t\t\t            maxLen = Math.max(maxLen, i - start + 1);\n\t\t\t        }\n\t\t\t        return maxLen;\n\t\t\t    }\n\t\t\t}\n\t\t2.2 Longest Valid Parentheses\n\t\t\t/*\n\t\t\t\t1. 新建一个stack，用以保存括号char的序号，而不是保存内容，遍历String上的所有char， 遇到'('一律将index进栈.\n\t\t\t    2. 遇到')'，一律不进栈，此时判断stack是否为空如果为空\n\t\t\t       1） 为空说明之前已经将'('匹配完出栈，已经没有'('可以进行匹配，所以需要将start的位置 赋值为i+ 1，跳过这个')'\n\t\t\t       2） 如果栈非空， pop 一个'('和这个')'进行匹配， 匹配完成后判断栈是否为空，\n\t\t\t            2.1）如果空  maxLen = Math.max(maxLen, i - start + 1) \n\t\t\t            2.2）如果栈非空  maxLen = Math.max(maxLen, i - stack.pop())\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int longestValidParentheses(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;  \n\t\t\t        }\n\t\t\t        Stack<Integer> stack = new Stack<Integer>();\n\t\t\t        int start = -1;\n\t\t\t        int maxLen = 0;\n\t\t\t        //use a stack to store the unvalid parentheses\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            if (s.charAt(i) == '(') {\n\t\t\t                stack.push(i);\n\t\t\t            } else {\n\t\t\t                ////if stack is empty, it means that we already found a complete valid combo and pop to the stack\n\t\t\t                // or since we meet a right parenthesesm so we need to update the last index. to store the unmatched  position\n\t\t\t                if (stack.isEmpty()) {\n\t\t\t                    start = i;\n\t\t\t                } else {\n\t\t\t                    stack.pop();\n\t\t\t                    maxLen = stack.isEmpty() ? Math.max(maxLen, i - start) : Math.max(maxLen, i - stack.peek());\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return maxLen;\n\t\t\t    }\n\t\t\t}\n\t\t2.3\tLongest Substring Without Repeating Characters\n\t\t\t/*\n\t\t\t\tstep1: 设定一个滑动窗口，窗口的左边界为left，右边界为right，维护一个全局最大距离变量 max = right - left + 1\n\t\t\t\tstep2: 先不停将right往右边移动，并放入hashset，只要hashset中没有重复的字符，right一直++\n\t\t\t\tstep3: 一旦遇到重复的字符，判断先前的 max 是否小于现在的right - left + 1，如果小于则更新max,\n\t\t\t\t\t   并且需要将right之前存在set里的字符remove，因为下一次要进行比较的窗口序列是从right开始，也就是 left = right\n\t\t\t\tstep4: 每一次left前进只在找到重复字符时才++，\n\t\t\t\t\t   相反right只在没找到重复字符时才++.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLongestSubstring(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int left = 0;\n\t\t\t        int right = 0;\n\t\t\t        int maxLen = 0;\n\t\t\t        HashSet<Character> set = new HashSet<>();\n\t\t\t        while (right < s.length()) {\n\t\t\t            char c = s.charAt(right);\n\t\t\t            if (set.contains(c)) {\n\t\t\t                while (s.charAt(left) != c) {\n\t\t\t                    set.remove(s.charAt(left));\n\t\t\t                    left++;\n\t\t\t                }\n\t\t\t                left++;\n\t\t\t            } else {\n\t\t\t                set.add(c);\n\t\t\t                maxLen = Math.max(maxLen, right - left + 1);\n\t\t\t            }\n\t\t\t            right++;\n\t\t\t        }\n\t\t\t        maxLen = Math.max(maxLen, right - left);\n\t\t\t        return maxLen;\n\t\t\t    }\n\t\t\t}\n\t\t2.4 Longest Palindromic Substring\n\t\t\t/*\n\t\t\t\t中心回探法O（n*n)\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    private int low, maxLen;\n\t\t\t    public String longestPalindrome(String s) {\n\t\t\t        int len = s.length();\n\t\t\t        if (len < 2) {\n\t\t\t            return s;\n\t\t\t        }\n\t\t\t        \n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            extendPalindrome(s, i, i);\n\t\t\t            extendPalindrome(s, i, i + 1);\n\t\t\t        }\n\t\t\t        return s.substring(low, low + maxLen);\n\t\t\t    }\n\t\t\t    public void extendPalindrome(String s, int i, int j) {\n\t\t\t        while (i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n\t\t\t            i--;\n\t\t\t            j++;\n\t\t\t        }\n\t\t\t        if (maxLen < j - i - 1) { \n\t\t\t            low = i + 1;\n\t\t\t            maxLen = j - i - 1;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t\t/*\n\t\t\t\tDP\n\t\t\t*/\n\t\t\tpublic String longestPalindrome(String s) {\n\t\t        if (s == null || s.length() == 0) {\n\t\t            return \"\";\n\t\t        }\n\t\t        //isPalin[i][j], i and j are two indices of the string, \n\t\t        //denote whether substring from i to j is palindrome;\n\t\t        //isPalin[i][i] is always palindrome, since s.charAt(i) == s.charAt(i)\n\t\t        boolean[][] isPalind = new boolean[s.length()][s.length()];\n\t\t        String res = \"\";\n\t\t        int maxLen = 0;\n\t\t        for (int i = s.length() - 1; i >= 0; i--) {\n\t\t            for (int j = i; j < s.length(); j++) {\n\t\t                // j - i <= 2 --> aba or aa 肯定palindrome\n\t\t                if (s.charAt(i) == s.charAt(j) && (j - i <= 2 || isPalind[i + 1][j - 1])) {\n\t\t                    isPalind[i][j] = true;\n\t\t                    if (maxLen < j - i + 1) {\n\t\t                        maxLen = j - i + 1;\n\t\t                        res = s.substring(i, j + 1);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        return res;\n\t\t    }\n\t\t    /*\n\t\t    \tBest manacher's Algorithm   O(n) O(n)\n\t\t\t\thttp://www.felix021.com/blog/read.php?2040\n\t\t\t\thttp://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public String longestPalindrome(String s) {\n\t\t\t        if (s == null || s.length() <= 1) {\n\t\t\t            return s;\n\t\t\t        }\n\t\t\t        s = preProcess(s);\n\t\t\t        int[] p = new int[s.length()];\n\t\t\t        int mid = 0;\n\t\t\t        int max = 0;\n\t\t\t        for (int i = 1; i < s.length() - 1; i++) {\n\t\t\t            p[i] = i < max ? Math.min(p[mid - (i - mid)], max - i) : 0; \n\t\t\t            while (s.charAt(i - p[i] - 1) == s.charAt(i + p[i] + 1)) {\n\t\t\t                p[i]++;\n\t\t\t            }\n\t\t\t            if (i + p[i] > max) {\n\t\t\t                mid = i;\n\t\t\t                max = p[i];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        int maxLen = 0;\n\t\t\t        mid = 0;\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            if (p[i] > maxLen) {\n\t\t\t                mid = i;\n\t\t\t                maxLen = p[i];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t        for (int i = mid - maxLen; i <= mid + maxLen; i++) {\n\t\t\t            if (s.charAt(i) != '#') {\n\t\t\t                sb.append(s.charAt(i));\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return sb.toString();\n\t\t\t    }\n\t\t\t    public String preProcess(String s) {\n\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t        sb.append('~');\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            sb.append('#');\n\t\t\t            sb.append(s.charAt(i));\n\t\t\t        }\n\t\t\t        sb.append(\"#$\");\n\t\t\t        return sb.toString();\n\t\t\t    }\n\t\t\t}\n\t\t2.5 Longest Common Prefix\n\t\t\t// indexOf method\n\t\t\tpublic class Solution {\n\t\t\t    public String longestCommonPrefix(String[] strs) {\n\t\t\t        if (strs == null || strs.length == 0) {\n\t\t\t            return \"\";\n\t\t\t        }\n\t\t\t        String pre = strs[0];\n\t\t\t        for (int i = 1; i < strs.length; i++) {\n\t\t\t            while (strs[i].indexOf(pre) != 0) {\n\t\t\t                pre = pre.substring(0, pre.length() - 1);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return pre;\n\t\t\t    }\n\t\t\t}\n\t\t\t//no indexOf method\n\t\t\tpublic class Solution {\n\t\t\t    public String longestCommonPrefix(String[] strs) {\n\t\t\t        if (strs == null || strs.length == 0) {\n\t\t\t            return \"\";\n\t\t\t        }\n\t\t\t        for (int i = 0; i < strs[0].length(); i++) {\n\t\t\t            char c = strs[0].charAt(i);\n\t\t\t            for (int j = 1; j < strs.length; j++) {\n\t\t\t                if (i == strs[j].length() || strs[j].charAt(i) != c) {\n\t\t\t                    return strs[0].substring(0, i);\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return strs[0];\n\t\t\t    }\n\t\t\t}\n\t\t2.6 Longest Consecutive Sequence\n\t\t\t/*\n\t\t\t\tWe will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. \n\t\t\t\tFor example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5.\n\n\t\t\t\tWhenever a new element n is inserted into the map, do two things:\n\n\t\t\t\t1) See if n - 1 and n + 1 exist in the map, and if so, it means there is an existing sequence next to n. \n\t\t\t\t\tVariables left and right will be the length of those two sequences, while 0 means there is no sequence and n will be the boundary point later. \n\t\t\t\t\tStore (left + right + 1) as the associated value to key n into the map.\n\t\t\t\t2) Use left and right to locate the other end of the sequences to the left and right of n respectively, and replace the value with the new length.\n\t\t\t\t\tEverything inside the for loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int longestConsecutive(int[] nums) {\n\t\t\t        int res = 0;\n\t\t\t        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\t\t        for (int i : nums) {\n\t\t\t            if (!map.containsKey(i)) {\n\t\t\t                int left = map.containsKey(i - 1) ? map.get(i - 1) : 0;\n\t\t\t                int right = map.containsKey(i + 1) ? map.get(i + 1) : 0;\n\t\t\t                \n\t\t\t                int sum = left + right + 1;\n\t\t\t                map.put(i, sum);\n\t\t\t                \n\t\t\t                res = Math.max(res, sum);\n\t\t\t                \n\t\t\t                map.put(i - left, sum);\n\t\t\t                map.put(i + right, sum);\n\t\t\t            } else {\n\t\t\t                continue;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t2.7 Longest Increasing Subsequence\n\t\t\t//O(n*n) dp\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLIS(int[] nums) {\n\t\t\t        if (nums == null || nums.length == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int[] dp = new int[nums.length];\n\t\t\t        int max = 0;\n\t\t\t        Arrays.fill(dp, 1);\n\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t            for (int j = 0; j < i; j++) {\n\t\t\t                if (nums[i] > nums[j]) {\n\t\t\t                    dp[i] = Math.max(dp[j] + 1, dp[i]);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            max = Math.max(max, dp[i]);\n\t\t\t        }\n\t\t\t        return max;\n\t\t\t    }\n\t\t\t}\n\t\t\t//O(n),binarySearch and Dp\n\t\t\t/*\n\t\t\t\tThe idea is that as you iterate the sequence, you keep track of the minimum value a subsequence of given length might end with, f\n\t\t\t\tor all so far possible subsequence lengths. So dp[i] is the minimum value a subsequence of length i+1 might end with. Having this info,\n\t\t\t\t for each new number we iterate to, we can determine the longest subsequence where it can be appended using binary search. \n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLIS(int[] nums) {\n\t\t\t        int[] dp = new int[nums.length];\n\t\t\t        int len = 0;\n\t\t\t        for (int num : nums) {\n\t\t\t            int i = binarySearch(dp, 0, len, num);\n\t\t\t            dp[i] = num;\n\t\t\t            if (i == len) {\n\t\t\t                len++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return len;\n\t\t\t    }\n\t\t\t    private int binarySearch(int[] nums, int start, int end, int target) {\n\t\t\t        while (start < end) {\n\t\t\t            int mid = start + (end - start)/2;\n\t\t\t            if (nums[mid] >= target) {\n\t\t\t                end = mid;\n\t\t\t            } else {\n\t\t\t                start = mid + 1;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return end;\n\t\t\t    }\n\t\t\t}\n\t\t2.8 Longest Common Substring\n\t\t\t/*\n\t\t\t\tgiven two strings, find the longest common substring.\n\t\t\t\tExample\n\t\t\t\t\tGiven A=“ABCD”, B=“CBCE”, return  2\n\t\t\t\tD[i][j] 定义为：两个string的前i个和前j个字符串，尾部连到最后的最长子串。\n\t\t\t\tD[i][j] = \n\t\t\t\t\t1. i = 0 || j = 0 : 0\n\t\t\t\t\t2. s1.char[i - 1] = s2.char[j - 1] ? D[i-1][j-1] + 1 : 0;\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t\tpublic int longestCommonSubstring(String A, String B) {\n\t\t\t\t\tint[][] dp = new int[A.length() + 1][B.length() + 1];\n\t\t\t\t\tint result = 0;\n\t\t\t\t\tfor (int i = 0; i <= A.length(); i++) {\n\t\t\t\t\t\tfor (int j = 0; j <= B.length(); j++) {\n\t\t\t\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\t\t\t\tres[i][j] = 0;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (A.charAt(i - 1) != B.charAt(j - 1)) {\n\t\t\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresult = Math.max(result, res[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\n3. Anagram Problem\n\t\t3.1 Valid Anagram\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isAnagram(String s, String t) {\n\t\t\t        int[] arr = new int[26];\n\t\t\t        for (char c : s.toCharArray()) {\n\t\t\t            arr[c - 'a'] += 1;\n\t\t\t        }\n\t\t\t        for (char c : t.toCharArray()) {\n\t\t\t            arr[c - 'a'] -= 1;\n\t\t\t        }\n\t\t\t        for (int value : arr) {\n\t\t\t            if (value >= 1 || value < 0) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\t\t3.2 Two Strings Are Anagrams\n\t\t\t/*\n\t\t\t\tWrite a method anagram(s,t) to decide if two strings are anagrams or not.\n\t\t\t\tExample\n\t\t\t\t\tGiven s=\"abcd\", t=\"dcab\", return true.\n\n\t\t\t\tChallenge\n\t\t\t\t\tO(n) time, O(1) extra space\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean anagram(String s, String t) {\n\t\t\t        int[] charArr = new int[256];\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            if (s.charAt(i) != ' ') {\n\t\t\t                charArr[s.charAt(i) - '0']++;\n\t\t\t            }\n\t\t\t            if (t.charAt(i) != ' ') {\n\t\t\t                charArr[t.charAt(i) - '0']--;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        for (int i = 0; i < charArr.length; i++) {\n\t\t\t            if (charArr[i] != 0) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\t\t3.3 Group Anagrams\n\t\t\t/*\n\t\t\t\tFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \n\t\t\t\tReturn:\n\t\t\t\t[\n\t\t\t\t  [\"ate\", \"eat\",\"tea\"],\n\t\t\t\t  [\"nat\",\"tan\"],\n\t\t\t\t  [\"bat\"]\n\t\t\t\t]\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<List<String>> groupAnagrams(String[] strs) {\n\t\t\t        List<List<String>> res = new ArrayList<>();\n\t\t\t        HashMap<String, List<String>> map = new HashMap<>();\n\t\t\t        for (String str : strs) {\n\t\t\t            char[] wordArr = str.toCharArray();\n\t\t\t            Arrays.sort(wordArr);\n\t\t\t            String anagram = String.valueOf(wordArr);\n\t\t\t            if (!map.containsKey(anagram)) {\n\t\t\t                map.put(anagram, new ArrayList<String>());\n\t\t\t            } \n\t\t\t            map.get(anagram).add(str);\n\t\t\t        }\n\t\t\t        for (List<String> item : map.values()) {\n\t\t\t            Collections.sort(item);\n\t\t\t            res.add(item);\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t3.4 Anagrams LintCode\n\t\t\t/*\n\t\t\t\tGiven an array of strings, return all groups of strings that are anagrams.\n\t\t\t\tExample\n\t\t\t\t\tGiven [\"lint\", \"intl\", \"inlt\", \"code\"], return [\"lint\", \"inlt\", \"intl\"].\n\t\t\t\t\tGiven [\"ab\", \"ba\", \"cd\", \"dc\", \"e\"], return [\"ab\", \"ba\", \"cd\", \"dc\"].\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<String> anagrams(String[] strs) {\n\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t        if (strs == null || strs.length == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        HashMap<String, List<String>> map = new HashMap<>();\n\t\t\t        for (String s : strs) {\n\t\t\t            char[] arr = s.toCharArray();\n\t\t\t            Arrays.sort(arr);\n\t\t\t            String key = new String(arr);\n\t\t\t            if (!map.containsKey(key)) {\n\t\t\t                map.put(key, new ArrayList<String>());\n\t\t\t            }\n\t\t\t            map.get(key).add(s);\n\t\t\t        }\n\t\t\t        for (List<String> item : map.values()) {\n\t\t\t            if (item.size() > 1) {\n\t\t\t                res.addAll(item);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\n4. Palindrome Problem\n\t\t4.1 Valid Palindrome\n\t\t\t/*\n\t\t\t\tGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\t\t\t\tFor example,\n\t\t\t\t\"A man, a plan, a canal: Panama\" is a palindrome.\n\t\t\t\t\"race a car\" is not a palindrome.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isPalindrome(String s) {\n\t\t\t        int start = 0;\n\t\t\t        int end = s.length() - 1;\n\t\t\t        while (start < end) {\n\t\t\t            if(isValid(s.charAt(start)) && isValid(s.charAt(end))) {\n\t\t\t                if (isSame(s.charAt(start), s.charAt(end))) {\n\t\t\t                    start++;\n\t\t\t                    end--;\n\t\t\t                    continue;\n\t\t\t                } else {\n\t\t\t                    return false;\n\t\t\t                }\n\t\t\t            } \n\t\t\t            if (!isValid(s.charAt(start))) {\n\t\t\t                start++;\n\t\t\t            }\n\t\t\t            if (!isValid(s.charAt(end))) {\n\t\t\t                end--;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t    public boPHolean isValid(char c) {\n\t\t\t        if (c != ' ' && ((c <= 'z' && c >= 'a') || (c <= '9' && c >= '0') || (c <= 'Z' && c >= 'A'))) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        return false;\n\t\t\t    }\n\t\t\t    public boolean isSame(char c1, char c2) {\n\t\t\t        if (c1 >= 'A' && c1 <= 'Z') {\n\t\t\t            c1 = (char) (c1 - 'A' + 'a');\n\t\t\t        }\n\t\t\t        if (c2 >= 'A' && c2 <= 'Z') {\n\t\t\t            c2 = (char) (c2 - 'A' + 'a');\n\t\t\t        }\n\t\t\t        return c1 == c2;\n\t\t\t    }\n\t\t\t}\n\n\t\t4.2 Palindrome Permutation\n\t\t\t/*\n\t\t\t\tGiven a string, determine if a permutation of the string could form a palindrome.\n\t\t\t\tFor example,\n\t\t\t\t\"code\" -> False, \"aab\" -> True, \"carerac\" -> True.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean canPermutePalindrome(String s) {\n\t\t\t        HashSet<Character> set = new HashSet<>();\n\t\t\t        for (char c : s.toCharArray()) {\n\t\t\t            if (set.contains(c)) {\n\t\t\t                set.remove(c);\n\t\t\t            } else {\n\t\t\t                set.add(c);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return set.size() <= 1;\n\t\t\t    }\n\t\t\t}\n\t\t4.3 Palindrome Partitioning I\n\t\t\t/*\n\t\t\t\tGiven a string s, partition s such that every substring of the partition is a palindrome.\n\t\t\t\tReturn all possible palindrome partitioning of s.\n\t\t\t\tFor example, given s = \"aab\",\n\t\t\t\tReturn\n\t\t\t\t  [\n\t\t\t\t    [\"aa\",\"b\"],\n\t\t\t\t    [\"a\",\"a\",\"b\"]\n\t\t\t\t  ]\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<List<String>> partition(String s) {\n\t\t\t        List<List<String>> res =new ArrayList<>();\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        List<String> item = new ArrayList<>();\n\t\t\t        helper(res, item, s, 0);\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void helper(List<List<String>> res, List<String> item, String s, int start) {\n\t\t\t        if (start == s.length()) {\n\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        for (int i = start; i < s.length(); i++) {\n\t\t\t            String str = s.substring(start, i + 1);\n\t\t\t            if (isValid(str)) {\n\t\t\t                item.add(str);\n\t\t\t                helper(res, item, s, i + 1);\n\t\t\t                item.remove(item.size() - 1);\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    public boolean isValid(String s) {\n\t\t\t        int i = 0;\n\t\t\t        int j = s.length() - 1;\n\t\t\t        while (i < j) {\n\t\t\t            if (s.charAt(i++) != s.charAt(j--)) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\t\t4.4 Palindrome Permutation II\n\t\t\tpublic class Solution {\n\t\t\t    public List<String> generatePalindromes(String s) {\n\t\t\t        List<String> res =new ArrayList<>();\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        int odd = 0;\n\t\t\t        String mid = \"\";\n\t\t\t        List<Character> item = new ArrayList<>();\n\t\t\t        HashMap<Character, Integer> map = new HashMap<>();\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (map.containsKey(c)) {\n\t\t\t                map.put(c, map.get(c) + 1);\n\t\t\t            } else {\n\t\t\t                map.put(c, 1);\n\t\t\t            }\n\t\t\t            odd += map.get(c) % 2 != 0 ? 1 : -1;\n\t\t\t        }\n\t\t\t        if (odd > 1) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n\t\t\t            char key = entry.getKey();\n\t\t\t            int val = entry.getValue();\n\t\t\t            \n\t\t\t            if (val %2 != 0) {\n\t\t\t                mid += key;\n\t\t\t            }\n\t\t\t            for (int i = 0; i < val / 2; i++) {\n\t\t\t                item.add(key);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        dfs(res, item, mid, new boolean[item.size()], new StringBuilder());\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void dfs(List<String> res, List<Character> item, String mid, boolean[] visited, StringBuilder sb) {\n\t\t\t        if (sb.length() == item.size()) {\n\t\t\t            res.add(sb.toString() + mid + sb.reverse().toString());\n\t\t\t            sb.reverse();\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        for (int i = 0; i < item.size(); i++) {\n\t\t\t            if (i != 0 && item.get(i) == item.get(i - 1) && !visited[i - 1]) {\n\t\t\t                continue;\n\t\t\t            }\n\t\t\t            if (!visited[i]) {\n\t\t\t                visited[i] = true;\n\t\t\t                sb.append(item.get(i));\n\t\t\t                dfs(res, item, mid, visited, sb);\n\t\t\t                visited[i] = false;\n\t\t\t                sb.deleteCharAt(sb.length() - 1);\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t4.5 Shortest Palindrome\n\t\t\t/*\n\t\t\t\tGiven \"aacecaaa\", return \"aaacecaaa\".\n\t\t\t\tGiven \"abcd\", return \"dcbabcd\".\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public String shortestPalindrome(String s) {\n\t\t\t        if (s.length() <= 1) {\n\t\t\t            return s;\n\t\t\t        }\n\t\t\t        String cur = s + \" \" + new StringBuilder(s).reverse().toString();\n\t\t\t        int len = cur.length();\n\t\t\t        int[] next = new int[len];\n\t\t\t        int k = -1;\n\t\t\t        int j = 0;\n\t\t\t        next[0] = -1;\n\t\t\t        while (j < len - 1) {\n\t\t\t            if (k == -1 || cur.charAt(k) == cur.charAt(j)) {\n\t\t\t                next[++j] = ++k;\n\t\t\t            } else {\n\t\t\t                k = next[k];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return new StringBuilder(s.substring(next[cur.length() - 1] + 1)).reverse().toString() + s;\n\t\t\t    }\n\t\t\t}\n\n5. String And Word Modification Problem\n\t\t5.1 Reverse And Rotate \n\t\t\t\t5.1.1 Reverse Word In A String I\n\t\t\t\t\t//Using split()\n\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t\t//Using split(), Reverse Word In A String I\n\t\t\t\t\t\tpublic String reverseWords(String s) {\n\t\t\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t\t\t            return \"\";\n\t\t\t\t\t        }\n\t\t\t\t\t        String[] strArr = s.split(\" \");\n\t\t\t\t\t        if (strArr.length == 0) {\n\t\t\t\t\t            return \"\";\n\t\t\t\t\t        }\n\t\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t\t        for (int i = strArr.length - 1; i >= 0; i--) {\n\t\t\t\t\t            if (!strArr[i].equals(\"\")) {\n\t\t\t\t\t                sb.append(strArr[i]).append(\" \");\n\t\t\t\t\t            }\n\t\t\t\t\t        }\n\t\t\t\t\t        return sb.toString().trim();\n\t\t\t\t\t    }\n\t\t\t\t\t    //No using split()\n\t\t\t\t\t    public String reverseWords(String s) {\n\t\t\t\t\t        StringBuilder res = new StringBuilder();\n\t\t\t\t\t        for (int start = s.length() - 1; start >= 0; start--) {\n\t\t\t\t\t            if (s.charAt(start) == ' ') {\n\t\t\t\t\t                continue;\n\t\t\t\t\t            }\n\t\t\t\t\t            int end = start;\n\t\t\t\t\t            while (start >= 0 && s.charAt(start) != ' ') {\n\t\t\t\t\t                start--;\n\t\t\t\t\t            }\n\t\t\t\t\t            res.append(s.substring(start + 1, end + 1)).append(' ');\n\t\t\t\t\t        }\n\t\t\t\t\t        return res.toString().trim();\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t5.1.2 Reverse Word In A String II\n\t\t\t\t\t//Reverse Word In A String II\n\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t\t    public void reverseWords(char[] s) {\n\t\t\t\t\t\t        reverse(s, 0, s.length - 1);\n\t\t\t\t\t\t        for (int i = 0, j = 0; j < s.length; j++) {\n\t\t\t\t\t\t            if (s[j] == ' ') {\n\t\t\t\t\t\t                reverse(s, i, j - 1);\n\t\t\t\t\t\t                i = j + 1;\n\t\t\t\t\t\t            }\n\t\t\t\t\t\t            if (j == s.length - 1) {\n\t\t\t\t\t\t                reverse(s, i, j);\n\t\t\t\t\t\t            }\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    public void reverse(char[] s, int start, int end) {\n\t\t\t\t\t\t        while (start < end) {\n\t\t\t\t\t\t            swap(s, start++, end--);\n\t\t\t\t\t\t        }\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    public void swap(char[] s, int i, int j) {\n\t\t\t\t\t\t        char temp = s[i];\n\t\t\t\t\t\t        s[i] = s[j];\n\t\t\t\t\t\t        s[j] = temp;\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t5.1.3 Rotate String / Rotate Array\n\t\t\t\t\t/*\n\t\t\t\t\t\tGiven a string and an offset, rotate string by offset. (rotate from left to right)\n\t\t\t\t\t\tExample\n\t\t\t\t\t\t\tGiven \"abcdefg\".\n\t\t\t\t\t\t\toffset=0 => \"abcdefg\"\n\t\t\t\t\t\t\toffset=1 => \"gabcdef\"\n\t\t\t\t\t\t\toffset=2 => \"fgabcde\"\n\t\t\t\t\t\t\toffset=3 => \"efgabcd\"\n\t\t\t\t\t\tChallenge\n\t\t\t\t\t\t\tRotate in-place with O(1) extra memory.\n\t\t\t\t\t*/\n\t\t\t\t\t/*\n\t\t\t\t\t\tKey point: \t从转动的位置开始将两个部分反转，然后再将整个字符串反转即可\n\t\t\t\t\t\t\t\t\t(1) reverse(str, 0, str.length - offset - 1);\n\t\t\t\t\t\t\t        (2) reverse(str, str.length - offset, str.length - 1);\n\t\t\t\t\t\t\t        (3) reverse(str, 0, str.length - 1);\n\t\t\t\t\t\t\t        (4) finally we can get a array which was already moved from left to right with offset position\n\t\t\t\t\t*/\n\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t    public void rotateString(char[] str, int offset) {\n\t\t\t\t\t        if (str == null || str.length == 0) {\n\t\t\t\t\t            return;\n\t\t\t\t\t        }\n\t\t\t\t\t        offset = offset % str.length;\n\t\t\t\t\t        reverse(str, 0, str.length - offset - 1);\n\t\t\t\t\t        reverse(str, str.length - offset, str.length - 1);\n\t\t\t\t\t        reverse(str, 0, str.length - 1);\n\t\t\t\t\t    }\n\t\t\t\t\t    public void reverse(char[] str, int i, int j) {\n\t\t\t\t\t        while (i < j) {\n\t\t\t\t\t            swap(str, i++, j--);\n\t\t\t\t\t        }\n\t\t\t\t\t    }\n\t\t\t\t\t    public void swap(char[] str, int i, int j) {\n\t\t\t\t\t        char temp = str[i];\n\t\t\t\t\t        str[i] = str[j];\n\t\t\t\t\t        str[j] = temp;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t5.1.4 Scramble String\n\t\t\t\t\t/*\n\t\t\t\t\t\tWe say that \"rgeat\" is a scrambled string of \"great\".\n\t\t\t\t\t\tWe say that \"rgtae\" is a scrambled string of \"great\".\n\t\t\t\t\t\tGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n\t\t\t\t\t*/\n\t\t\t\t\t//Solution1: Recursive\n\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t    public boolean isScramble(String s1, String s2) {\n\t\t\t\t\t        if (s1.length() != s2.length()) {\n\t\t\t\t\t            return false;\n\t\t\t\t\t        }\n\t\t\t\t\t        if (s1.equals(s2)) {\n\t\t\t\t\t            return true;\n\t\t\t\t\t        }\n\t\t\t\t\t        int[] count = new int[256];\n\t\t\t\t\t        for (int i = 0; i < s1.length(); i++) {\n\t\t\t\t\t            count[s1.charAt(i) - '0']++;\n\t\t\t\t\t            count[s2.charAt(i) - '0']--;\n\t\t\t\t\t        }\n\t\t\t\t\t        for (int i = 0; i < count.length; i++) {\n\t\t\t\t\t            if (count[i] != 0) {\n\t\t\t\t\t                return false;\n\t\t\t\t\t            }\n\t\t\t\t\t        }\n\t\t\t\t\t        for (int i = 1; i < s1.length(); i++) {\n\t\t\t\t\t            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && \n\t\t\t\t\t                isScramble(s1.substring(i), s2.substring(i))) {\n\t\t\t\t\t                return true;\n\t\t\t\t\t            }\n\t\t\t\t\t            if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && \n\t\t\t\t\t                isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {\n\t\t\t\t\t                return true;\n\t\t\t\t\t            }\n\t\t\t\t\t        }\n\t\t\t\t\t        return false;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t5.1.5 Interleaving String\n\t\t\t\t\t/*\n\t\t\t\t\t\tGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n\t\t\t\t\t\tFor example,\n\t\t\t\t\t\tGiven:\n\t\t\t\t\t\ts1 = \"aabcc\",\n\t\t\t\t\t\ts2 = \"dbbca\",\n\t\t\t\t\t\tWhen s3 = \"aadbbcbcac\", return true.\n\t\t\t\t\t\tWhen s3 = \"aadbbbaccc\", return false.\n\t\t\t\t\t*/\n\t\t\t\t\tpublic class Solution {\n\t\t\t\t\t    public boolean isInterleave(String s1, String s2, String s3) {\n\t\t\t\t\t        int m = s1.length();\n\t\t\t\t\t        int n = s2.length();\n\t\t\t\t\t        if (m + n != s3.length()) {\n\t\t\t\t\t            return false;\n\t\t\t\t\t        }\n\t\t\t\t\t        boolean[][] dp = new boolean[m + 1][n + 1];\n\t\t\t\t\t        dp[0][0] = true;\n\t\t\t\t\t        for (int i = 1; i <= m; i++) {\n\t\t\t\t\t            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n\t\t\t\t\t        }\n\t\t\t\t\t        for (int i = 1; i <= n; i++) {\n\t\t\t\t\t            dp[0][i] = dp[0][i - 1] && s2.charAt(i - 1) == s3.charAt(i - 1);\n\t\t\t\t\t        }\n\t\t\t\t\t        for (int i = 1; i <= m; i++) {\n\t\t\t\t\t            for (int j = 1; j <= n; j++) {\n\t\t\t\t\t                dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1) ||\n\t\t\t\t\t                           dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n\t\t\t\t\t            }\n\t\t\t\t\t        }\n\t\t\t\t\t        return dp[m][n];\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t5.2 Length Of Last Word\n\t\t\t/*\n\t\t\t\tGiven a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n\t\t\t\tIf the last word does not exist, return 0.\n\t\t\t\tNote: A word is defined as a character sequence consists of non-space characters only.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLastWord(String s) {\n\t\t\t        int end  = s.length() - 1;\n\t\t\t        while (end >= 0 && s.charAt(end) == ' ') {\n\t\t\t            end--;\n\t\t\t        }\n\t\t\t        int start = end;\n\t\t\t        while (start >= 0 && s.charAt(start) != ' ') {\n\t\t\t            start--;\n\t\t\t        }\n\t\t\t        return end - start;\n\t\t\t    }\n\t\t\t}\n\t\t5.3 Encode And Decode Strings\n\t\t\t/*\n\t\t\t\tencode: len + '/' + s\n\t\t\t\tdecode: 1. Using indexOf('/', i) to find the slash position\n\t\t\t\t\t\t2. slash \n\t\t\t*/\n\t\t\tpublic class Codec {\n\t\t\t    // Encodes a list of strings to a single string.\n\t\t\t    public String encode(List<String> strs) {\n\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t        for (String s : strs) {\n\t\t\t            sb.append(s.length()).append('/').append(s);\n\t\t\t        }\n\t\t\t        return sb.toString();\n\t\t\t    }\n\t\t\t    // Decodes a single string to a list of strings.\n\t\t\t    public List<String> decode(String s) {\n\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t        int i = 0;\n\t\t\t        while (i < s.length()) {\n\t\t\t            int slash = s.indexOf('/', i);//这里的indexOf是return从下标i开始，第一个遇见的 slash的下标，并不是指固定位置上有没有\n\t\t\t            int len = Integer.valueOf(s.substring(i, slash));\n\t\t\t            res.add(s.substring(slash + 1, slash + len + 1));\n\t\t\t            i = slash + len + 1;\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t5.4 Decode Ways\n\t\t\t//DP\n\t\t\tpublic class Solution {\n\t\t\t    public int numDecodings(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int[] dp = new int[s.length() + 1];\n\t\t\t        dp[0] = 1;\n\t\t\t        if (isValid(s.substring(0, 1))) {\n\t\t\t            dp[1] = 1;\n\t\t\t        } else {\n\t\t\t            dp[1] = 0;\n\t\t\t        }\n\t\t\t        for (int i = 2; i <= s.length(); i++) {\n\t\t\t            if (isValid(s.substring(i - 1, i))) {\n\t\t\t                dp[i] += dp[i - 1];\n\t\t\t            }\n\t\t\t            if (isValid(s.substring(i - 2, i))) {\n\t\t\t                dp[i] += dp[i - 2];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[s.length()];\n\t\t\t    }\n\t\t\t    public boolean isValid(String s) {\n\t\t\t        if (s.charAt(0) == '0') {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        int code = Integer.parseInt(s);\n\t\t\t        return code <= 26 && code >= 1;\n\t\t\t    }\n\t\t\t}\n\t\t\t//Recursive\n\t\t\tpublic class Solution {\n\t\t\t    int num;\n\t\t\t    public int numDecodings(String s) {\n\t\t\t        if (s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        num = 0;\n\t\t\t        dfs(s);\n\t\t\t        return num;\n\t\t\t    }\n\t\t\t    \n\t\t\t    public void dfs(String s){\n\t\t\t        if (s.length() == 0) {\n\t\t\t            num++;\n\t\t\t        }\n\t\t\t        for(int i = 0; i <= 1 && i < s.length(); i++){\n\t\t\t            if (isValid(s.substring(0, i + 1))) {\n\t\t\t                dfs(s.substring(i + 1));\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    \n\t\t\t    public boolean isValid(String s){\n\t\t\t        if (s.charAt(0) == '0') {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        int code = Integer.parseInt(s);\n\t\t\t        return code >= 1 && code <= 26;\n\t\t\t    }\n\t\t\t}\n\t\t5.5 Space Replacement\n\t\t\t/*\n\t\t\t\tWrite a method to replace all spaces in a string with %20. The string is given in a characters array, \n\t\t\t\tyou can assume it has enough space for replacement and you are given the true length of the string.\n\t\t\t\tYou code should also return the new length of the string after replacement.\n\t\t\t\tExample\n\t\t\t\t\tGiven \"Mr John Smith\", length = 13.\n\t\t\t\t\tThe string after replacement should be \"Mr%20John%20Smith\".\n\t\t\t\tChallenge\n\t\t\t\t\tDo it in-place.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int replaceBlank(char[] string, int length) {\n\t\t\t        int realLen = length;\n\t\t\t        for (int i = 0; i < length; i++) {\n\t\t\t            if (string[i] == ' ') {\n\t\t\t                realLen += 2;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        int index = realLen;\n\t\t\t        for (int i = length - 1; i>= 0; i--) {\n\t\t\t            if (string[i] == ' ') {\n\t\t\t                string[--index] = '0';\n\t\t\t                string[--index] = '2';\n\t\t\t                string[--index] = '%';\n\t\t\t            } else {\n\t\t\t                string[--index] = string[i];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return realLen;\n\t\t\t    }\n\t\t\t}\n\t\t5.6 ZigZag Conversion\n\t\t\t/*\n\t\t\t\tThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: \n\t\t\t\t(you may want to display this pattern in a fixed font for better legibility)\n\t\t\t\t\tP   A   H   N\n\t\t\t\t\tA P L S I I G\n\t\t\t\t\tY   I   R\n\t\t\t\tAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\t\t\t\tWrite the code that will take a string and make this conversion given a number of rows:\n\t\t\t\t\n\t\t\t\tstring convert(string text, int nRows);\n\t\t\t\tconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public String convert(String s, int numRows) {\n\t\t\t        char[] c = s.toCharArray();\n\t\t\t        int len = s.length();\n\t\t\t        StringBuilder[] sb = new StringBuilder[numRows];\n\t\t\t        for (int i = 0; i < sb.length; i++) {\n\t\t\t            sb[i] = new StringBuilder();\n\t\t\t        }\n\t\t\t        int i = 0;\n\t\t\t        while (i < len) {\n\t\t\t            for (int index = 0; index < numRows && i < len; index++) {\n\t\t\t                sb[index].append(c[i++]);\n\t\t\t            }\n\t\t\t            for (int index = numRows - 2; index >= 1 && i < len; index--) {\n\t\t\t                sb[index].append(c[i++]);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        for (int index = 1; index < sb.length; index++) {\n\t\t\t            sb[0].append(sb[index]);\n\t\t\t        }\n\t\t\t        return sb[0].toString();\n\t\t\t    }\n\t\t\t}\n\n\t\t\n\n\n\n6. File Read And Write\n\t\t6.1 Read N Characters Given Read4 I\n\t\t\tpublic class Solution extends Reader4 {\n\t\t\t    /**\n\t\t\t     * @param buf Destination buffer\n\t\t\t     * @param n   Maximum number of characters to read\n\t\t\t     * @return    The number of characters read\n\t\t\t     */\n\t\t\t    public int read(char[] buf, int n) {\n\t\t\t        char[] buffer = new char[4];\n\t\t\t        int readBytes = 0;\n\t\t\t        int bytes = 0;\n\t\t\t        boolean lessthan4 = false;\n\t\t\t        while (!lessthan4 && readBytes < n) {\n\t\t\t            int size = read4(buffer);\n\t\t\t            if (size < 4) {\n\t\t\t                lessthan4 = true;\n\t\t\t            }\n\t\t\t            bytes = Math.min(n - readBytes, size);\n\t\t\t            for (int i = 0; i < bytes; i++) {\n\t\t\t                buf[readBytes + i] = buffer[i];\n\t\t\t            }\n\t\t\t            readBytes += bytes;\n\t\t\t        }\n\t\t\t        return readBytes;\n\t\t\t    }\n    \t\t}\n\t\t6.2 Read N Characters Given Read4 II\n\t\t\tpublic class Solution extends Reader4 {\n\t\t\t    /**\n\t\t\t     * @param buf Destination buffer\n\t\t\t     * @param n   Maximum number of characters to read\n\t\t\t     * @return    The number of characters read\n\t\t\t     */\n\t\t\t    private char[] buffer = new char[4];\n\t\t\t    int offset = 0;\n\t\t\t    int bufsize = 0;\n\t\t\t    public int read(char[] buf, int n) {\n\t\t\t        int readBytes = 0;\n\t\t\t        boolean lessthan4 = false;\n\t\t\t        int bytes = 0;\n\t\t\t        while (!lessthan4 && readBytes < n) {\n\t\t\t            if (bufsize == 0) {\n\t\t\t                bufsize = read4(buffer);\n\t\t\t                if (bufsize < 4) {\n\t\t\t                \tlessthan4 = true;\n\t\t\t                }\n\t\t\t            }\n\t\t\t            \n\t\t\t            bytes = Math.min(n - readBytes, bufsize);\n\t\t\t            for (int i = 0; i < bytes; i++) {\n\t\t\t                buf[readBytes + i] = buffer[offset + i];\n\t\t\t            }\n\t\t\t            offset = (offset + bytes) % 4;\n\t\t\t            bufsize -= bytes;\n\t\t\t            readBytes += bytes;\n\t\t\t        }\n\t\t\t        return readBytes;\n\t\t\t    }\n\t\t\t}\n\n\n\n7. Word Distance Problem\n\t\t7.1 Edit Distance\n\t\t\t/*\n\t\t\t\tGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. \n\t\t\t*/\n\t\t\t//2D DP\n\t\t\tpublic class Solution {\n\t\t\t    public int minDistance(String word1, String word2) {\n\t\t\t        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n\t\t\t        for (int i = 0; i <= word1.length(); i++) {\n\t\t\t            dp[i][0] = i;\n\t\t\t        }\n\t\t\t        for (int i = 0; i <= word2.length(); i++) {\n\t\t\t            dp[0][i] = i;\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= word1.length(); i++) {\n\t\t\t            for (int j = 1; j <= word2.length(); j++) {\n\t\t\t                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {\n\t\t\t                    int delete = dp[i][j - 1] + 1;\n\t\t\t                    int insert = dp[i - 1][j] + 1;\n\t\t\t                    int replace = dp[i - 1][j - 1] + 1;\n\t\t\t                    dp[i][j] = Math.min(insert, Math.min(delete, replace));\n\t\t\t                } else {\n\t\t\t                    dp[i][j] = dp[i - 1][j - 1];\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[word1.length()][word2.length()];\n\t\t\t    }\n\t\t\t}\n\t\t\t//1D DP\n\t\t\tpublic class Solution {\n\t\t\t    public int minDistance(String word1, String word2) {\n\t\t\t        int[] dp = new int[word2.length() + 1];\n\t\t\t        for (int i = 0; i <= word2.length(); ++i) {\n\t\t\t        \tdp[i] = i;\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= word1.length(); ++i) {\n\t\t\t            int pre = dp[0];\n\t\t\t            dp[0] = i;\n\t\t\t            for (int j = 1; j <= word2.length(); ++j) {\n\t\t\t                int temp = dp[j];\n\t\t\t                dp[j] = Math.min(dp[j - 1], dp[j]) + 1;\n\t\t\t                dp[j] = Math.min(dp[j], pre + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\n\t\t\t                pre = temp;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[word2.length()];\n\t\t\t    }\n\t\t\t}\n\t\t7.2 One Distance\n\t\t\t/*\n\t\t\t\tGiven two strings S and T, determine if they are both one edit distance apart.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isOneEditDistance(String s, String t) {\n\t\t\t        int m = s.length();\n\t\t\t        int n = t.length();\n\t\t\t        if (m > n) {\n\t\t\t            return isOneEditDistance(t, s);\n\t\t\t        }\n\t\t\t        if (m == n) {\n\t\t\t            int count = 0;\n\t\t\t            for (int i = 0; i < m; i++) {\n\t\t\t                if (s.charAt(i) != t.charAt(i)) {\n\t\t\t                    count++;\n\t\t\t                }\n\t\t\t            }\n\t\t\t            return count == 1;\n\t\t\t        }\n\t\t\t        if (m == n - 1) {\n\t\t\t            for (int i = 0; i < m; i++) {\n\t\t\t                if (s.charAt(i) != t.charAt(i)) {\n\t\t\t                    return s.substring(i).equals(t.substring(i + 1));\n\t\t\t                }\n\t\t\t            }\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        return false;\n\t\t\t    }\n\t\t\t}\n\t\t7.3 Shortest Word Distance \n\t\t\t7.3.1 Shortest Word Distance I\n\t\t\t\t/*\n\t\t\t\t\tFor example,\n\t\t\t\t\t\tAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\n\t\t\t\t\t\tGiven word1 = “coding”, word2 = “practice”, return 3.\n\t\t\t\t\t\tGiven word1 = \"makes\", word2 = \"coding\", return 1.\n\t\t\t\t\tNote:\n\t\t\t\t\tYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public int shortestDistance(String[] words, String word1, String word2) {\n\t\t\t\t        if (words == null || words.length == 0) {\n\t\t\t\t            return 0;\n\t\t\t\t        }\n\t\t\t\t        int start = -1;\n\t\t\t\t        int end = -1;\n\t\t\t\t        int minLen = Integer.MAX_VALUE;\n\t\t\t\t        for (int i = 0; i < words.length; i++) {\n\t\t\t\t            if (words[i].equals(word1)) {\n\t\t\t\t                start = i;\n\t\t\t\t            } else if (words[i].equals(word2)) {\n\t\t\t\t                end = i;\n\t\t\t\t            }\n\t\t\t\t            if (start != -1 && end != -1) {\n\t\t\t\t                minLen = Math.min(minLen, Math.abs(end - start));\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return minLen;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t7.3.2 Shortest Word Distance II\n\t\t\t\t//需要design，以适应可以多次调用查询不同word之间的最短距离\n\t\t\t\tpublic class WordDistance {\n\t\t\t\t    private HashMap<String, ArrayList<Integer>> map;\n\t\t\t\t    public WordDistance(String[] words) {\n\t\t\t\t        map = new HashMap<String, ArrayList<Integer>>();\n\t\t\t\t        for (int i = 0; i < words.length; i++) {\n\t\t\t\t            if (!map.containsKey(words[i])) {\n\t\t\t\t                map.put(words[i], new ArrayList<>());\n\t\t\t\t            }\n\t\t\t\t            map.get(words[i]).add(i);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    //从O(m * n) 缩减到O(m + n)的关键在于要意识到，两个list里面的下标都已经是排好序的了，类似merge sort的merge方法\n\t\t\t\t    public int shortest(String word1, String word2) {\n\t\t\t\t        List<Integer> list1 = map.get(word1);\n\t\t\t\t        List<Integer> list2 = map.get(word2);\n\t\t\t\t        int minLen = Integer.MAX_VALUE;\n\t\t\t\t        int i = 0;\n\t\t\t\t        int j = 0;\n\t\t\t\t        while (i < list1.size() && j < list2.size()) {\n\t\t\t\t            minLen = Math.min(minLen, Math.abs(list1.get(i) - list2.get(j)));\n\t\t\t\t            if (list1.get(i) > list2.get(j)) {\n\t\t\t\t                j++;\n\t\t\t\t            } else {\n\t\t\t\t                i++;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return minLen;\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t7.3.3 Shortest Word Distance III\n\n\n8. String Matching\n\t\t8.1 Basic Matching\n\t\t\t8.1.1 Implement StrStr()\n\t\t\t\t//Solution1: Brute Force\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public int strStr(String haystack, String needle) {\n\t\t\t\t        if (needle == null || needle.length() == 0) {\n\t\t\t\t            return 0;\n\t\t\t\t        }\n\t\t\t\t        if (haystack == null || haystack.length() == 0) {\n\t\t\t\t            return -1;\n\t\t\t\t        }\n\t\t\t\t        int i, j;\n\t\t\t\t        for (i = 0; i <= haystack.length() - needle.length(); i++) {\n\t\t\t\t            for (j = 0; j < needle.length(); j++) {\n\t\t\t\t                if (haystack.charAt(i + j) != needle.charAt(j)) {\n\t\t\t\t                    break;\n\t\t\t\t                }\n\t\t\t\t                if (j == needle.length() - 1) {\n\t\t\t\t                    return i;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return -1;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t8.1.2 Implement StrStr() By Kmp\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic int strStr(String haystack, String needle) {\n\t\t\t\t        if (needle == null || needle.length() == 0) {\n\t\t\t\t            return 0;\n\t\t\t\t        }\n\t\t\t\t        if (haystack == null || haystack.length() == 0) {\n\t\t\t\t            return -1;\n\t\t\t\t        }\n\t\t\t\t        int[] next = new int[needle.length()];\n\t\t\t\t        setNext(next, needle);\n\t\t\t\t        int i = 0;\n\t\t\t\t        int j = 0;\n\t\t\t\t        while (i < haystack.length()) {\n\t\t\t\t            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\n\t\t\t\t                i++;\n\t\t\t\t                j++;\n\t\t\t\t            } else {\n\t\t\t\t                j = next[j];\n\t\t\t\t            }\n\t\t\t\t            if (j == needle.length()) {\n\t\t\t\t                return i - needle.length();\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return -1;\n\t\t\t\t    }\n\t\t\t\t    public void setNext(int[] next, String pattern) {\n\t\t\t\t        char[] s = pattern.toCharArray();\n\t\t\t\t        int len = pattern.length();\n\t\t\t\t        int k = -1;\n\t\t\t\t        int j = 0;\n\t\t\t\t        next[0] = -1;\n\t\t\t\t        while (j < s.length - 1) {\n\t\t\t\t            if (k == -1 || s[k] == s[j]) {\n\t\t\t\t                next[++j] = ++k;\n\t\t\t\t            } else {\n\t\t\t\t                k = next[k];\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    } \n\t\t\t\t}\n\n9. Slide Window Problem\n\t\t9.1 Longest Substring With At Most K Distinct Characters\n\t\t\t//O (n * k)\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLongestSubstringTwoDistinct(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        HashMap<Character, Integer> map = new HashMap<>();\n\t\t\t        int maxLen = 0;\n\t\t\t        int start = 0;\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (!map.containsKey(c) && map.size() == K) {\n\t\t\t                int leftCharPos = s.length();\n\t\t\t                char leftChar = ' ';\n\t\t\t                for (char ch : map.keySet()) {\n\t\t\t                    if (map.get(ch) < leftCharPos) {\n\t\t\t                        leftCharPos = map.get(ch);\n\t\t\t                        leftChar = ch;\n\t\t\t                    }\n\t\t\t                }\n\t\t\t                start = leftCharPos + 1;\n\t\t\t                map.remove(leftChar);\n\t\t\t            }\n\t\t\t            map.put(c, i);\n\t\t\t            maxLen = Math.max(maxLen, i - start + 1);\n\t\t\t        }\n\t\t\t        return maxLen;\n\t\t\t    }\n\t\t\t}\n\t\t9.2 Longest Substring Without Repeating Characters\n\t\t\t//O(n)\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLongestSubstring(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int left = 0;\n\t\t\t        int right = 0;\n\t\t\t        int maxLen = 0;\n\t\t\t        HashSet<Character> set = new HashSet<>();\n\t\t\t        while (right < s.length()) {\n\t\t\t            char c = s.charAt(right);\n\t\t\t            if (set.contains(c)) {\n\t\t\t                while (s.charAt(left) != c) {\n\t\t\t                    set.remove(s.charAt(left));\n\t\t\t                    left++;\n\t\t\t                }\n\t\t\t                left++;\n\t\t\t            } else {\n\t\t\t                set.add(c);\n\t\t\t                maxLen = Math.max(maxLen, right - left + 1);\n\t\t\t            }\n\t\t\t            right++;\n\t\t\t        }\n\t\t\t        return Math.max(maxLen, right - 1 - left + 1);\n\t\t\t    }\n\t\t\t}\n\t\t9.3 Substring With Concatenation Of All Words\n\t\t\t/*\n\t\t\t\tYou are given a string, s, and a list of words, words, that are all of the same length. \n\t\t\t\tFind all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n\n\t\t\t\tFor example, given:\n\t\t\t\t\ts: \"barfoothefoobarman\"\n\t\t\t\t\twords: [\"foo\", \"bar\"]\n\n\t\t\t\tYou should return the indices: [0,9].\n\t\t\t\t(order does not matter).\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<Integer> findSubstring(String s, String[] words) {\n\t\t\t        List<Integer> res = new ArrayList<Integer>();\n\t\t\t        if (s == null || s.length() == 0 || words == null || words.length == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        int wordLen = words[0].length();\n\t\t\t        int arrLen = words.length;\n\t\t\t        HashMap<String, Integer> map = new HashMap<>();\n\t\t\t        for (String word : words) {\n\t\t\t            map.put(word, !map.containsKey(word) ? 1 : map.get(word) + 1);\n\t\t\t        }\n\t\t\t        for (int i = 0; i < wordLen; i++) {\n\t\t\t            HashMap<String, Integer> curMap = new HashMap<>();\n\t\t\t            int count = 0;\n\t\t\t            int left = i;\n\t\t\t            for (int j = i; j <= s.length() - wordLen; j += wordLen) {\n\t\t\t                String str = s.substring(j, j + wordLen);\n\t\t\t                if (map.containsKey(str)) {\n\t\t\t                    curMap.put(str, !curMap.containsKey(str) ? 1 : curMap.get(str) + 1);\n\t\t\t                    if (curMap.get(str) <= map.get(str)) {\n\t\t\t                        count++;\n\t\t\t                    } else {\n\t\t\t                        while (curMap.get(str) > map.get(str)) {\n\t\t\t                            String temp = s.substring(left, left + wordLen);\n\t\t\t                            if (curMap.containsKey(temp)) {\n\t\t\t                                curMap.put(temp, curMap.get(temp) - 1);\n\t\t\t                                if (curMap.get(temp) < map.get(temp)) {\n\t\t\t                                    count--;\n\t\t\t                                }\n\t\t\t                            }\n\t\t\t                            left += wordLen;\n\t\t\t                        }\n\t\t\t                    }\n\t\t\t                    if (count == words.length) {\n\t\t\t                        res.add(left);\n\t\t\t                        String temp = s.substring(left, left + wordLen);\n\t\t\t                        if (curMap.containsKey(temp)) {\n\t\t\t                            curMap.put(temp, curMap.get(temp) - 1);\n\t\t\t                        }\n\t\t\t                        count--;\n\t\t\t                        left += wordLen;\n\t\t\t                    }\n\t\t\t                } else {\n\t\t\t                    curMap.clear();\n\t\t\t                    count = 0;\n\t\t\t                    left = j + wordLen;\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t9.4\tMinimum Window Substring\n\t\t\t/*\n\t\t\t\tGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n\t\t\t\tFor example,\n\t\t\t\tS = \"ADOBECODEBANC\"\n\t\t\t\tT = \"ABC\"\n\t\t\t\tMinimum window is \"BANC\".\n\n\t\t\t\tNote:\n\t\t\t\tIf there is no such window in S that covers all characters in T, return the empty string \"\".\n\t\t\t\tIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public String minWindow(String s, String t) {\n\t\t\t        String res = \"\";\n\t\t\t        if (s == null || s.length() == 0 || t == null || t.length() == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        HashMap<Character, Integer> map = new HashMap<>();\n\t\t\t        for (char c : t.toCharArray()) {\n\t\t\t            map.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);\n\t\t\t        }\n\t\t\t        int minStart = 0;\n\t\t\t        int minLen = s.length() + 1;\n\t\t\t        int count = 0;\n\t\t\t        int left = 0;\n\t\t\t        for (int right = 0; right < s.length(); right++) {\n\t\t\t            char rightChar = s.charAt(right);\n\t\t\t            if (map.containsKey(rightChar)) {\n\t\t\t                map.put(rightChar, map.get(rightChar) - 1);\n\t\t\t                if (map.get(rightChar) >= 0) {\n\t\t\t                    count++;\n\t\t\t                }\n\t\t\t                while (count == t.length()) {\n\t\t\t                    if (right - left + 1 < minLen) {\n\t\t\t                        minLen = right - left + 1;\n\t\t\t                        minStart = left;\n\t\t\t                    }\n\t\t\t                    char leftChar = s.charAt(left);\n\t\t\t                    if (map.containsKey(leftChar)) {\n\t\t\t                        map.put(leftChar, map.get(leftChar) + 1);\n\t\t\t                        if (map.get(leftChar) > 0) {\n\t\t\t                            count--;\n\t\t\t                        }\n\t\t\t                    }\n\t\t\t                    left++;\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (minLen > s.length()) {\n\t\t\t            return \"\";\n\t\t\t        }\n\t\t\t        return s.substring(minStart, minStart + minLen);\n\t\t\t    }\n\t\t\t}\n\n\n\n"
    }
  ]
}