{
  "title": "Binary Tree",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "1. The Definition of Tree\n\n\tRoot – The top node in a tree.\n\tParent – The converse notion of a child.\n\tSiblings – Nodes with the same parent.\n\tDescendant – a node reachable by repeated proceeding from parent to child.\n\tAncestor – a node reachable by repeated proceeding from child to parent.\n\tLeaf – a node with no children\n\n\tLevel – The level of a node is defined by 1 + (the number of connections between the node and the root).\n\tHeight of tree – The height of a tree is the number of edges on the longest downward path between the root and a leaf.\n\n\tHeight of node – The height of a node is the number of edges on the longest downward path between that node and a leaf.\n\tDepth – The depth of a node is the number of edges from the node to the tree root node.\n\n\tInternal node – a node with at least one child.\n\tExternal node – a node with no children.\n\tDegree – number of sub trees of a node.\n\tEdge – connection between one node to another.\n\tPath – a sequence of nodes and edges connecting a node with a descendant.\n\tForest – A forest is a set of n ≥ 0 disjoint trees.\n\n\n1.Binary Tree Traversal Problem，树的各种遍历方法\n\t1.1 Preorder : root -> left -> right 中 左 右\n\t\t\t1.1.1 Recursive prefer\n\t\t\t//DFS\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\t\t    \tList<Integer> res = new ArrayList<>();\n\t\t\t    \tpreorder(res, root);\n\t\t\t    \treturn res;\n\t\t\t    }\n\t\t\t    public void preorder(List<Integer> res, TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        res.add(root.val);\n\t\t\t        preorder(res, root.left);\n\t\t\t        preorder(res, root.right);\n\t\t\t    }\n\t\t\t}\n\t\t\t1.1.2 Iterative1 prefer\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        if (root == null)\n\t\t\t            return res;\n\t\t\t        Stack<TreeNode> stack = new Stack<>();\n\t\t\t        while (root != null || !stack.isEmpty()) {\n\t\t\t            if (root != null) {\n\t\t\t                stack.push(root);//只要有左边的叶子节点就一直遍历入栈\n\t\t\t                res.add(root.val);// 跟inorder遍历的唯一区别在于， inorder中res.add(root.val)放到  遍历完最left的时候才add， 正好如何 \n\t\t\t                root = root.left;\n\t\t\t            } else {\n\t\t\t                root = stack.pop();//左边的遍历完了再出栈给root，将右节点的值 //加入结果\n\t\t\t                root = root.right;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t\t1.1.3 Iterative2\n\t\t\t//Using stack to imitate the recursive\n\t\t\tpublic class Solution {\n\t    \t\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\t\t    \tList<Integer> res = new ArrayList<>();\n\t\t\t    \tif (root == null)\n\t\t\t    \t\treturn res;\n\t\t\t    \tStack<TreeNode> stack = new Stack<>();\n\t\t\t    \tstack.push(root);\n\t\t\t    \twhile (!stack.isEmpty()) {\n\t\t\t    \t\tTreeNode cur = stack.pop();\n\t\t\t    \t\tres.add(cur.val);\n\t\t\t    \t\tif (cur.right != null)\n\t\t\t    \t\t\tstack.push(cur.right);\n\t\t\t    \t\tif (cur.left != null)\n\t\t\t    \t\t\tstack.push(cur.left);\n\t\t\t    \t}\n\t\t\t    \treturn res;\n\t    \t\t}\n\t    \t}\n\t1.2 Inorder  left -> root -> right\n\t\t\t1.2.1 Recursive \n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> inorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        if (root == null)\n\t\t\t            return res;\n\t\t\t        dfs(root, res);\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void dfs(TreeNode root, List<Integer> res) {\n\t\t\t        if (root == null)\n\t\t\t            return ;\n\t\t\t        dfs(root.left, res);\n\t\t\t        res.add(root.val);\n\t\t\t        dfs(root.right, res);\n\t\t\t    }\n\t\t\t}\n\t\t\t1.2.2 Iterative prefer\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> inorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        if (root == null)\n\t\t\t            return res;\n\t\t\t        LinkedList<TreeNode> stack = new LinkedList<>();\n\t\t\t        while (root != null || !stack.isEmpty()) {\n\t\t\t            if (root != null) {\n\t\t\t                stack.push(root);\n\t\t\t                root = root.left;\n\t\t\t            } else {\n\t\t\t                root = stack.pop();\n\t\t\t                res.add(root.val);\n\t\t\t                root = root.right;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t1.3 Postorder left -> right -> root\n\t\t\t1.3.1 Recursive\n\t\t\tpublic class Solution {\n\t\t\t    public List<Integer> postorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        if (root == null)\n\t\t\t            return res;\n\t\t\t        dfs(root, res);\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void dfs(TreeNode root, ArrayList<Integer> res) {\n\t\t\t        if (root == null)\n\t\t\t            return ;\n\t\t\t        dfs(root.left, res);\n\t\t\t        dfs(root.right, res);\n\t\t\t        res.add(root.val);\n\t\t\t    }\n\t\t\t}\n\t\t\t1.3.2 Iterative1 prefer , real postorder\n\t\t\t\t/*\n\t\t\t\t\t后序遍历的情况就复杂多了。我们需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况\n\t\t\t\t\t注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：\n\t\t\t\t\t\t1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，即如果有左孩子，则是左孩子进栈，\n\t\t\t\t\t\t   否则如果有右孩子，则是右孩子进栈，如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。\n\t\t\t\t\t\t2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，但是我们知道后序遍历要左右孩子走完才可以访问自己，\n\t\t\t\t\t\t   所以这里如果有右孩子还需要把右孩子进栈，否则说明已经到自己了，可以访问并且出栈了。\n\t\t\t\t\t\t3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。\n\t\t\t\t\t\t   算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。\n\n\t\t\t\t\t下面在弹栈的时候需要分情况一下：\n\t\t\t\t\t\t1）如果当前栈顶元素的右结点存在并且还没访问过（也就是右结点不等于上一个访问结点），那么就把当前结点移到右结点继续循环；\n\t\t\t\t\t\t2）如果栈顶元素右结点是空或者已经访问过，那么说明栈顶元素的左右子树都访问完毕，应该访问自己继续回溯了。\n\t\t\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> postorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        if (root == null)\n\t\t\t            return res;\n\t\t\t        Stack<TreeNode> stack = new Stack<>();\n\t\t\t        TreeNode pre = null;\n\t\t\t        while (root != null || !stack.isEmpty()) {\n\t\t\t            //往左探底\n\t\t\t            if (root != null) {\n\t\t\t                stack.push(root);\n\t\t\t                root = root.left;\n\t\t\t            } else {\n\t\t\t                TreeNode peekNode = stack.peek();\n\t\t\t                //一直往右探底\n\t\t\t                if (peekNode.right != null && peekNode.right != pre) {\n\t\t\t                    root = peekNode.right;\n\t\t\t                } else {\n\t\t\t                    //已经探底，加入这个值\n\t\t\t                    stack.pop();\n\t\t\t                    res.add(peekNode.val);\n\t\t\t                    pre = peekNode;\n\t\t\t                }\n\t\t\t                \n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t\t1.3.3 Iterative2 \n\t\t\t/* \n\t\t\t \tit was like cheating:) \n\t\t\t \tUsing root->right->left to do traversal just like preorder，\n\t\t\t \tand then reverse the result\n\t\t\t \tit will be left -> right -> root\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<Integer> postorderTraversal(TreeNode root) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        Stack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\t        while (!stack.isEmpty() || root != null) {\n\t\t\t            if (root != null) {\n\t\t\t                stack.push(root);\n\t\t\t                res.add(root.val);\n\t\t\t                root = root.right;\n\t\t\t            } else {\n\t\t\t                root = stack.pop();\n\t\t\t                root = root.left;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        Collections.reverse(res);\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t1.4 Level Order\n\t\t\t1.4.1 Normal DFS\n\t\t\tpublic class Solution {\n\t\t\t    public List<List<Integer>> levelOrder(TreeNode root) {\n\t\t\t         List<List<Integer>> res = new ArrayList<>();\n\t\t\t         if (root == null) {\n\t\t\t             return res;\n\t\t\t         }\n\t\t\t         dfs(res, root, 0);\n\t\t\t         return res;\n\t\t\t    }\n\t\t\t    public void dfs(List<List<Integer>> res, TreeNode root, int depth) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        if (res.size() <= depth) {\n\t\t\t            res.add(new ArrayList<>());\n\t\t\t        }\n\t\t\t        res.get(depth).add(root.val);\n\t\t\t        /*\n\t\t\t        \tLevelOrder II problem\n\t\t\t\t        if (res.size() <= depth) {\n\t            \t\t\tres.add(0, new ArrayList<>());\n\t\t\t\t        }\n\t        \t\t\tres.get(res.size() - depth - 1).add(root.val);\n        \t\t\t*/\n\t\t\t        dfs(res, root.left, depth + 1);\n\t\t\t        dfs(res, root.right, depth + 1);\n\t\t\t    }\n\t\t\t}\n\t\t\t1.4.2 Normal BFS\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<List<Integer>> levelOrder(TreeNode root) {\n\t\t\t\t\tList<List<Integer>> res = new ArrayList<>();\n\t\t\t\t\tif (root == null)\n\t\t\t\t\t\treturn res;\n\t\t\t\t\tQueue<TreeNode> queue = new LinkedList<>();\n\t\t\t\t\tqueue.add(root);\n\t\t\t\t\tint curNodeNum = 1;//to record the number of node which in same level\n\t\t\t\t\tint nexNodeNum = 0;//to record the number of node which in next level\n\t\t\t\t\tList<Integer> item = new ArrayList<>();// store every result array in same level \n\t\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\t\tTreeNode cur = queue.poll();\n\t\t\t\t\t\tcurNodeNum--;\n\t\t\t\t\t\titem.add(cur.val);\n\t\t\t\t\t\tif (cur.left != null) {\n\t\t\t\t\t\t\tnexNodeNum++;\n\t\t\t\t\t\t\tqueue.add(cur.left);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cur.right != null) {\n\t\t\t\t\t\t\tnexNodeNum++;\n\t\t\t\t\t\t\tqueue.add(cur.right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//假如一个层上的结点数量为0，则表示该层遍历完，开始下一层的遍历，next设为cur\n\t\t\t\t\t\tif (curNodeNum == 0) {\n\t\t\t\t\t\t\tcurNodeNum = nexNodeNum;\n\t\t\t\t\t\t\tnexNodeNum = 0;\n\t\t\t\t\t\t\tres.add(item);\n\t\t\t\t\t\t\t//res.add(0, levelres);  the only place we need to modify, and it can be used in Level Order II problem\n\t\t\t\t\t\t\titem = new ArrayList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\t1.4.3 ZigZag DFS\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t        if (root == null) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        dfs(res, 0, root);\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void dfs(List<List<Integer>> res, int depth, TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        if (res.size() <= depth) {\n\t\t\t            res.add(new ArrayList<>());\n\t\t\t        }\n\t\t\t        if (depth % 2== 0) {\n\t\t\t            res.get(depth).add(root.val);\n\t\t\t        } else {\n\t\t\t            res.get(depth).add(0, root.val);\n\t\t\t        }\n\t\t\t        dfs(res, depth + 1, root.left);\n\t\t\t        dfs(res, depth + 1, root.right);\n\t\t\t    }\n\t\t\t}\n\t\t\t1.4.4 ZigZag BFS\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n\t\t\t\t\tList<List<Integer>> res = new ArrayList<>();\n\t\t\t\t\tif (root == null)\n\t\t\t\t\t\treturn res;\n\t\t\t\t\tboolean reverse = false;\n\t\t\t\t\tQueue<TreeNode> queue = new LinkedList<>();\n\t\t\t\t\tqueue.add(root);\n\t\t\t\t\tint curNum = 1;\n\t\t\t\t\tint nextNum = 0;\n\t\t\t\t\tList<Integer> item = new ArrayList<>();\n\t\t\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\t\t\tTreeNode cur = queue.poll();\n\t\t\t\t\t\tcurNum--;\n\t\t\t\t\t\titem.add(cur.val);\n\t\t\t            if (cur.left != null) {\n\t\t\t\t\t\t\tqueue.add(cur.left);\n\t\t\t\t\t\t\tnextNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cur.right != null) {\n\t\t\t\t\t\t\tqueue.add(cur.right);\n\t\t\t\t\t\t\tnextNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (curNum == 0) {\n\t\t\t\t\t\t\tcurNum = nextNum;\n\t\t\t\t\t\t\tnextNum = 0;\n\t\t\t\t\t\t\tif (reverse) {\t\t\t\n\t\t\t\t\t\t\t\tCollections.reverse(item);//关键 reverse为true时，用Collections的reverse转置\n\t\t\t\t\t\t\t\treverse = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treverse = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.add(item);\n\t\t\t\t\t\t\titem = new ArrayList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t/*\n        Why we need Morris?\n        Morris Traversal方法可以做到这两点，与前两种方法的不同在于该方法只需要O(1)空间，而且同样可以在O(n)时间内完成。\n        要使用O(1)空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针），\n        由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。\n        在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），\n        只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。\n    */\n\t1.5 Morris Travseral\n\t\t\t1.5.1 Preorder \n\t\t    /*\n\t\t    \tPreorder Morris Solution:\n\t\t    \t前序遍历与中序遍历相似，代码上只有一行不同，不同就在于输出的顺序。\n\t\t\t\t1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。\n\t\t\t\t2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。\n\t\t\t\t\ta) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点（在这里输出，这是与中序遍历唯一一点不同）。当前节点更新为当前节点的左孩子。\n\t\t\t\t\tb) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。\n\t\t\t\t3. 重复以上1、2直到当前节点为空。\n\t\t    */\n\n\t\t\t//Morris用的pre，不管在哪个遍历里，实际上最后都是当前节点在inorder下的前驱结点！！！\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return Collections.emptyList();\n\t\t\t        }\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        TreeNode pre = null;\n\t\t\t        while (root != null) {\n\t\t\t            if (root.left == null) {\n\t\t\t                res.add(root.val);\n\t\t\t                root = root.right;\n\t\t\t            } else {\n\t\t\t                pre = root.left;\n\t\t\t                while (pre.right != null && pre.right != root) {\n\t\t\t                    pre = pre.right;\n\t\t\t                }\n\t\t\t                //假如pre.right 为空，叶子节点，记录root的信息，方便回溯\n\t\t\t                if (pre.right == null) {\n\t\t\t                    pre.right = root;\n\t\t\t                    res.add(root.val);//关键步骤，在这里将当前的root结点输出到结果，先将root输出，再遍历下面的叶子节点输出\n\t\t\t                    root = root.left;\n\t\t\t                }  else {\n\t\t\t                    pre.right = null;\n\t\t\t                    root = root.right;\n\t\t\t                }\n\t\t\t            } \n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t\t1.5.2 Inorder\n\t\t\t/*  Inorder Morris Solution:\n\t\t        例子图片在这里：http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html\n\t\t        1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。\n\t\t        2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。\n\t\t            a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。\n\t\t            b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。\n\t\t        3. 重复以上1、2直到当前节点为空。\n\t\t    */\n\t\t\tpublic class Solution {\n\t\t\t    public List<Integer> inorderTraversal(TreeNode root) {\n\t\t\t        if(root == null) return new ArrayList<Integer>();\n\t\t\t        List<Integer> res = new ArrayList<Integer>();\n\t\t\t        TreeNode pre = null;\n\t\t\t        while(root != null){\n\t\t\t            if(root.left == null){\n\t\t\t                res.add(root.val);\n\t\t\t                root = root.right;\n\t\t\t            } else{\n\t\t\t                pre = root.left;\n\t\t\t                while (pre.right != null && pre.right != root){\n\t\t\t                    pre = pre.right;\n\t\t\t                }\n\t\t\t                if(pre.right == null){\n\t\t\t                    pre.right = root;\n\t\t\t                    root = root.left;\n\t\t\t                    //res.add(root.val); //preorder是在这里加入res\n\t\t\t                }else{\n\t\t\t                    pre.right = null;\n\t\t\t                    res.add(root.val);//与preorder唯一的不同\n\t\t\t                    root = root.right;\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t1.6 Vertical Level Traversal Of Tree\n\t\t\t//Print arbitrary binary tree by vertical levels / columns from left to right,high to low\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<List<Integer>> verticalLevelTraversalofTree(TreeNode root){\n\t\t\t\t\tList<List<Integer>> res = new ArrayList<>();\n\t\t\t\t\t//map's key is column, we assume the root column is zero, the left node will minus 1 ,and the right node will plus 1\n\t\t\t\t\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n\t\t\t\t\t//use a queue to do bfs\n\t\t\t\t\tLinkedList<TreeNode> queue = new LinkedList<>();\n\t\t\t\t\t//use a HashMap to store the TreeNode and the according cloumn value\n\t\t\t\t\tHashMap<TreeNode, Integer> weight = new HashMap<>();\n\t\t\t\t\tif (root == null) {\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\tqueue.add(root);\n\t\t\t\t\tweight.put(root, 0);\n\t\t\t\t\tint min = 0;\n\t\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\t\t\tint w = weight.get(node);\n\t\t\t\t\t\t//if map doesn't has this column value, just create a list ,and put into map\n\t\t\t\t\t\tif (!map.containsKey(w)) {\n\t\t\t\t\t\t\tArrayList<Integer> list = new ArrayList<>();\n\t\t\t\t\t\t\tlist.add(node.val);\n\t\t\t\t\t\t\tmap.put(w, list);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tArrayList<Integer> list = map.get(w);\n\t\t\t\t\t\t\tlist.add(node.val);\n\t\t\t\t\t\t\tmap.put(w, list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//enqueue\n\t\t\t\t\t\tif (node.left != null) {\n\t\t\t\t\t\t\tqueue.add(node.left);\n\t\t\t\t\t\t\t//put the node to weight hashmap\n\t\t\t\t\t\t\tweight.put(node.left, w - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.right != null) {\n\t\t\t\t\t\t\tqueue.add(node.right);\n\t\t\t\t\t\t\tweight.put(node.right, w + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//update min ,min means the minimum column value, which is the left most node\n\t\t\t\t\t\tmin = Math.min(min, w);\n\t\t\t\t\t}\n\t\t\t\t\t//generate res\n\t\t\t\t\twhile(map.containsKey(min)) {\n\t\t\t\t\t\tres.add(map.get(min++));\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n   \n\n\n2. Path Problem In Binary Tree\n\t2.1 Get All Binary Tree Paths， \n\t\t2.1.1 DFS\n\t\t//Hint: Do not need to backtracking\n\t\t//在终止返回的语句中，是res.add(item + root.val)， 而且往下走的时候item + root.val + “->\"只会影响当前节点，并不会影响上一层的item使用\n\t\t\tpublic class Solution {\n\t\t\t\tpublic List<String> binaryTreePaths(TreeNode root) {\n\t\t\t\t\tList<String> res = new ArrayList<>();\n\t\t\t\t\tif (root == null) {\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\thelper(root, \"\", res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tpublic void helper(TreeNode root, String item, List<String> res) {\n\t\t\t\t\tif (root.left == null && root.right == null) {\n\t\t\t\t\t\tres.add(item + root.val);\n\t\t\t\t\t}\n\t\t\t\t\tif (root.left != null) {\n\t\t\t\t\t\thelper(root.left, item + root.val + \"->\", res);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (root.right != null) {\n\t\t\t\t\t\thelper(root.right, item + root.val + \"->\", res);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t2.1.2 BFS\n\t\t\tpublic List<String> binaryTreePaths(TreeNode root) {\n\t\t        List<String> res = new ArrayList<>();\n\t\t        if (root == null) {\n\t\t            return res;\n\t\t        }\n\t\t        Queue<TreeNode> queue = new LinkedList<>();\n\t\t        Queue<String> path = new LinkedList<>();\n\t\t        path.offer(root.val + \"\");\n\t\t        queue.offer(root);\n\t\t        while (!queue.isEmpty()) {\n\t\t            TreeNode cur = queue.poll();\n\t\t            String item = path.poll();\n\t\t            if (cur.left == null && cur.right == null) {\n\t\t                res.add(item);\n\t\t            }\n\t\t            if (cur.left != null) {\n\t\t                queue.offer(cur.left);\n\t\t                path.offer(item + \"->\" + cur.left.val + \"\");\n\t\t            }\n\t\t            if (cur.right != null) {\n\t\t                queue.offer(cur.right);\n\t\t                path.offer(item + \"->\" + cur.right.val + \"\");\n\t\t            }\n\t\t        }\n\t\t        return res;\n\t\t    }\n\t2.2 Path Sum Problem\n\t\t2.2.1 Path Sum I， find a path sum == sum, path (root to leaf)\n\t\t\t//DFS\n\t\t\tpublic boolean hasPathSum(TreeNode root, int sum) {\n\t\t        if (root == null) {\n\t\t            return false;\n\t\t        }\n\t\t        if (root.left == null && root.right == null) {\n\t\t            return root.val == sum;\n\t\t        }\n\t\t        int newSum = sum - root.val;\n\t\t        return hasPathSum(root.left, newSum) || hasPathSum(root.right, newSum);\n\t\t    }\n\t\t2.2.2 Path Sum II, need to return all the possible path node\n\t\t\t//DFS\n\t\t\tpublic class Solution {\n\t\t\t    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t        if (root == null) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        dfs(root, sum, res, new ArrayList<Integer>());\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public void dfs(TreeNode root, int sum, List<List<Integer>> res, List<Integer> item) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        item.add(root.val);\n\t\t\t        if (root.left == null && root.right == null) {\n\t\t\t            if (root.val == sum) {\n\t\t\t                res.add(new ArrayList<>(item));\n\t\t\t            }\n\t\t\t        }\n\t\t\t        dfs(root.left, sum - root.val, res, item);\n\t\t\t        dfs(root.right, sum - root.val, res, item);\n\t\t\t        item.remove(item.size() - 1);\n\t\t\t    }\n\t\t\t}\n\t\t2.2.3 Maximum Path Sum\n\t\t\t//DFS\n\t\t\tpublic class Solution {\n\t\t\t\tint max;\n\t\t\t\tpublic int maxPathSum(TreeNode root) {\n\t\t\t\t\tif (root == null) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\t\tfindMax(root);\n\t\t\t\t\treturn max;\n\t\t\t\t}\n\t\t\t\tpublic int findMax(TreeNode root) {\n\t\t\t\t\tif (root == null) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint leftSum = Math.max(0, findMax(root.left));\n\t\t\t\t\tint rightSum = Math.max(0, findMax(root.right));\n\t\t\t\t\tmax = Math.max(leftSum + rightSum + root.val, max);\n\t\t\t\t\treturn Math.max(leftSum, rightSum) + root.val;\n\t\t\t\t}\n\t\t\t}\n\t\t2.2.4 Sum Root To Leaf Numbers\n\t\t\t//DFS\n\t\t\tpublic class Solution {\n\t\t\t    public int sumNumbers(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        return pathSum(root, 0);\n\t\t\t    }\n\t\t\t    public int pathSum(TreeNode root, int sum) {\n\t\t\t        if (root == null) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int newSum = sum * 10 + root.val;\n\t\t\t        if (root.left == null && root.right == null) {\n\t\t\t            return newSum;\n\t\t\t        }\n\t\t\t        return pathSum(root.left, newSum) + pathSum(root.right, newSum);\n\t\t\t    }\n\t\t\t}\n\t\t\t//BFS\n\t\t\tpublic int sumNumbers(TreeNode root) {\n\t\t        if (root == null) {\n\t\t            return 0;\n\t\t        }\n\t\t        int res = 0;\n\t\t        Queue<TreeNode> queue = new LinkedList<>();\n\t\t        Queue<Integer> pathSum = new LinkedList<>();\n\t\t        queue.offer(root);\n\t\t        pathSum.offer(root.val);\n\t\t        while (!queue.isEmpty()) {\n\t\t            TreeNode cur = queue.poll();\n\t\t            int newSum = pathSum.poll();\n\t\t            if (cur.left == null && cur.right == null) {\n\t\t                res += newSum;\n\t\t            }\n\t\t            if (cur.left != null) {\n\t\t                queue.offer(cur.left);\n\t\t                pathSum.offer(newSum * 10 + cur.left.val);\n\t\t            }\n\t\t            if (cur.right != null) {\n\t\t                queue.offer(cur.right);\n\t\t                pathSum.offer(newSum * 10 + cur.right.val);\n\t\t            }\n\t\t        }\n\t\t        return res;\n    \t\t}\n    2.3 Binary Tree Longest Consecutive Sequence Path\n\t\t\t //   1\n\t\t\t //    \\\n\t\t\t //     3\n\t\t\t //    / \\\n\t\t\t //   2   4\n\t\t\t //        \\\n\t\t\t //         5\n\t\t     //Longest consecutive sequence path is 3-4-5, so return 3.\n\t\t\t //   2\n\t\t\t //    \\\n\t\t\t //     3\n\t\t\t //    / \n\t\t\t //   2    \n\t\t\t //  / \n\t\t\t // 1\n\t\t     //Longest consecutive sequence path is 2-3,not3-2-1, so return 2.\n\t\t\tpublic class Solution {\n\t\t\t    int max;\n\t\t\t    public int longestConsecutive(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        max = 0;\n\t\t\t        dfs(root, root, 0);\n\t\t\t        return max;\n\t\t\t    }\n\t\t\t    public void dfs(TreeNode cur, TreeNode pre, int count) {\n\t\t\t        if (cur == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        count = pre.val + 1 == cur.val ? count + 1 : 1;\n\t\t\t        max = Math.max(count, max);\n\t\t\t        dfs(cur.left, cur, count);\n\t\t\t        dfs(cur.right, cur, count);\n\t\t\t    }\n\t\t\t}\n\n\n3. The Property Of Tree\n\t3.1 Depth And Height\n\t\t3.1.1 Height Of Tree\n\t\t    public int height(TreeNode root) {\n\t\t        if (root == null) {\n\t\t            return 0;\n\t\t        }\n\t\t        return 1 + height(root.left);\n\t\t    }\n\t\t3.1.2 Depth Of Tree(Maximum Depth)\n\t\t\tpublic int depth(TreeNode root) {\n\t\t        if (root == null) {\n\t\t            return 0;\n\t\t        }\n\t\t        return Math.max(depth(root.left), depth(root.right)) + 1;\n    \t\t}\n\t\t3.1.3 Minimum Depth\n\t\t\tpublic int minDepth(TreeNode root) {\n\t\t    \tif (root == null)\n\t\t    \t\treturn 0;\n\t\t    \tif (root.left == null)\n\t\t    \t\treturn minDepth(root.right) + 1;\n\t\t    \tif (root.right == null)\n\t\t    \t\treturn minDepth(root.left) + 1;\n\t\t    \treturn Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n\t\t    }\n\t\t3.1.4 Balanced Binary Tree\n\t\t\tpublic boolean isBalanced(TreeNode root) {\n\t\t        if (root == null) {\n\t\t            return true;\n\t\t        }\n\t\t        int leftDepth = depth(root.left);//3.1.2 Depth of Tree\n\t\t        int rightDepth = depth(root.right);\n\t\t        if (Math.abs(leftDepth - rightDepth) > 1) {\n\t\t            return false;\n\t\t        } \n\t\t        return isBalanced(root.left) && isBalanced(root.right);\n\t\t    }\n\t\t3.1.5 Count Complete Tree\n\t\t\t/*\n\t\t\t\tIn a complete binary tree every level, except possibly the last, is completely filled, \n\t\t\t\tand all nodes in the last level are as far left as possible. \n\t\t\t\tIt can have between 1 and 2h nodes inclusive at the last level h.\n\t\t\t*/\n\t\t    public int countNodes(TreeNode root) {\n\t\t        int rootHeight = height(root);//3.1.1 Height of Tree Method\n\t\t        if (rootHeight < 0) {\n\t\t            return 0;\n\t\t        } \n\t\t        if (height(root.right) == rootHeight - 1) {\n\t\t            return (1 << (rootHeight - 1)) - 1 + countNodes(root.right) + 1;// 2^(h - 1)(左子树) - 1 + count(root.right) + 1(root);\n\t\t            /*\n\t\t                     1\n\t\t                   /   \\\n\t\t                  2     3\n\t\t                 / \\   / \n\t\t                4   5 6\n\t\t            */\n\t\t        } else {\n\t\t            /*\n\t\t                     1\n\t\t                   /  \\\n\t\t                  2    3\n\t\t                 / \\\n\t\t                4   5\n\t\t            */\n\t\t            return (1 << (rootHeight - 2)) - 1 + countNodes(root.left) + 1;// 2^(h - 2)（右子树） - 1 + cout(root.left) + 1(root);\n\t\t        }\n\t\t    }\n    3.2 SubTree, Symmetric Tree, Same Tree, Balanced Binary Tree\n    \t3.2.1 Same Tree\n    \t\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\t\t        if (p == null && q == null) {\n\t\t            return true;\n\t\t        }\n\t\t        if (p == null || q == null) {\n\t\t            return false;\n\t\t        }\n\t\t        if (p.val != q.val) {\n\t\t            return false;\n\t\t        }\n\t\t        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\t\t    }\n\t\t3.2.2 Symmetric Tree\n\t\t\tpublic boolean isSymmetric(TreeNode root) {\n\t\t    \tif (root == null) {\n\t\t    \t\treturn false;\n\t\t    \t}\n\t\t    \treturn isSymmetric(root.left, root.right);\n\t\t    }\n\t\t    public boolean isSymmetric(TreeNode p, TreeNode q) {\n\t\t    \tif (p == null && q == null) {\n\t\t    \t\treturn true;\n\t\t    \t}\n\t\t    \tif (p == null || q == null) {\n\t\t    \t\treturn false;\n\t\t    \t}\n\t\t    \treturn p.val == q.val && isSymmetric(p.left, q.right) && isSymmetric(p.right, q.left);\n\t\t    }\n\t\t3.2.3 SubTree\n\t        // T2 is a subtree of T1 in the following case:\n\t\t\t//        1                3\n\t\t\t//       / \\              / \n\t\t\t// T1 = 2   3      T2 =  4\n\t\t\t//         /\n\t\t\t//        4\n\t\t\t// T2 isn't a subtree of T1 in the following case:\n\n\t\t\t//        1               3\n\t\t\t//       / \\               \\\n\t\t\t// T1 = 2   3       T2 =    4\n\t\t\t//         /\n\t\t\t//        4\n\t    \t/**\n\t\t     * @param T1, T2: The roots of binary tree.\n\t\t     * @return: True if T2 is a subtree of T1, or false.\n\t\t     */\n\t\t    public boolean isSubtree(TreeNode T1, TreeNode T2) {\n\t\t        if (T2 == null) {\n\t\t            return true;\n\t\t        }\n\t\t        if (T1 == null) {\n\t\t            return false;\n\t\t        }\n\t\t        return isSameTree(T1, T2) || isSubtree(T1.left, T2) || isSubtree(T1.right, T2);\n\t\t    }\n\t\t3.2.4 Count Univalue Subtrees\n\t\t\tpublic class Solution {\n\t\t\t    int count = 0;\n\t\t\t    public int countUnivalSubtrees(TreeNode root) {\n\t\t\t        all(root, 0);\n\t\t\t        return count;\n\t\t\t    }\n\t\t\t    public boolean all(TreeNode root, int val) {\n\t\t\t        if (root == null)\n\t\t\t            return true;\n\t\t\t        if (!all(root.left, root.val) | !all(root.right, root.val))// || 或，判断第一个表达式的结果如果是正确的话，就会进入if内，不会判断后面的表达式，因此会漏算后面的计数，这就是short-circuit\n\t\t\t                                                                   // | 或 无论前面的结果如何，都会将所有表达式运行\n\t\t\t            return false;\n\t\t\t        count++;\n\t\t\t        return root.val == val;\n\t\t\t    }\n\t\t\t}\n\t3.3 Lowest Common Ancestor Of A Binary Tree\n\t\t\tpublic class Solution {\n\t\t\t    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\t\t        if (root == null || root == p || root == q) {\n\t\t\t            return root;\n\t\t\t        }\n\t\t\t        TreeNode leftChild = lowestCommonAncestor(root.left, p, q);\n\t\t\t        TreeNode rightChild = lowestCommonAncestor(root.right, p, q);\n\t\t\t        if (leftChild != null && rightChild != null) {\n\t\t\t            return root;\n\t\t\t        }\n\t\t\t        if (leftChild != null) {\n\t\t\t            return leftChild;\n\t\t\t        }\n\t\t\t        if (rightChild != null) {\n\t\t\t            return rightChild;\n\t\t\t        }\n\t\t\t        return null;\n\t\t\t    }\n\t\t\t}\n\n\t\t    \n4. Binary Search Tree \n\t\t4.1 Binary Search Tree Iterator //Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\n\t\t\tpublic class BSTIterator {\n\t\t\t    private Stack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\t    public BSTIterator(TreeNode root) {\n\t\t\t        pushAll(root);\n\t\t\t    }\n\t\t\t    /** @return whether we have a next smallest number */\n\t\t\t    public boolean hasNext() {\n\t\t\t        return !stack.isEmpty();\n\t\t\t    }\n\t\t\t    /** @return the next smallest number */\n\t\t\t    public int next() {\n\t\t\t        TreeNode tmpNode = stack.pop();\n\t\t\t        pushAll(tmpNode.right);\n\t\t\t        return tmpNode.val;\n\t\t\t    }\n\t\t\t    private void pushAll(TreeNode node) {\n\t\t\t        while (node != null) {\n\t\t\t            stack.push(node);\n\t\t\t            node = node.left;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t4.2 Closest Binary Search Tree Value\n\t\t\t//Iterative\n\t\t\tpublic int closestValue(TreeNode root, double target) {\n\t\t\t\tint closet = root.val;\n\t\t\t\twhile (root != null) {\n\t\t\t\t\tif (Math.abs(root.val - target) <= Math.abs(closet - target)) {\n\t\t\t\t\t\tcloset = root.val;\n\t\t\t\t\t}\n\t\t\t\t\troot = root.val < target ? root.right : root.left;\n\t\t\t\t}\n\t\t\t\treturn closet;\n\t\t\t}\n\t\t\t//Recursive\n\t\t\tpublic int closestValue(TreeNode root, double target) {\n\t\t        TreeNode child = target < root.val ? root.left : root.right;\n\t\t        if (child == null) {\n\t\t            return root.val;\n\t\t        }\n\t\t        int closetVal = closestValue(child, target);\n\t\t        return Math.abs(closetVal - target) < Math.abs(root.val - target) ? closetVal : root.val;\n\t\t    }\n\t\t4.3 Closest Binary Search Tree Value II\n\t\t\t/*\n\t\t\t\t\t中序遍历结果是将树中元素从小到大排列，逆式的中序遍历即先遍历右子树再访问根节点最后遍历左子树会得到树中元素从大到小排列的结果，\n\t\t    \t因此可通过中序遍历获取最接近target节点的predecessors，通过逆中序遍历获取最接近target节点的successors,\n\t\t    \t然后merge perdecessors 和 successors 获取最接近target节点的 k个节点值。 注意到在中序遍历时遇到比target 大的节点即停止，\n\t\t    \t因为由BST的性质可知后面的元素均会比target 大，即所有target的predecessors均已找到，同理逆中序遍历时遇到不大于 target的节点即可停止递归。 \n\t\t\t*/\n\t\t    O(n + k)\n\t\t\tpublic class Solution {\n\t\t\t\t    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n\t\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t\t        Stack<Integer> pre = new Stack<>();\n\t\t\t\t        Stack<Integer> post = new Stack<>();\n\t\t\t\t        \n\t\t\t\t        inorder(root, target, false, pre);\n\t\t\t\t        inorder(root, target, true, post);\n\n\t\t\t\t        while (k-- > 0) {\n\t\t\t\t            if (pre.isEmpty()) {\n\t\t\t\t                res.add(post.pop());\n\t\t\t\t            } else if (post.isEmpty()) {\n\t\t\t\t                res.add(pre.pop());\n\t\t\t\t            } else if (Math.abs(pre.peek() - target) < Math.abs(post.peek() - target)) {\n\t\t\t\t                res.add(pre.pop());\n\t\t\t\t            } else {\n\t\t\t\t                res.add(post.pop());\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\n\t\t\t\t    public void inorder(TreeNode root, double target, boolean reverse, Stack<Integer> stack) {\n\t\t\t\t        if (root == null) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        inorder(reverse ? root.right : root.left, target, reverse, stack);\n\t\t\t\t        // early terminate, no need to traverse the whole tree\n\t\t\t\t        if ((reverse && root.val <= target) || (!reverse && root.val > target)) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        // track the value of current node\n\t\t\t\t        stack.push(root.val);\n\t\t\t\t        inorder(reverse ? root.left : root.right, target, reverse, stack);\n\t\t\t\t    }\n\t\t\t}\n\t\t4.4 Convert Sorted Array To Binary Search Tree\n\t\t\tpublic class Solution {    \n\t\t\t    public TreeNode sortedArrayToBST(int[] num) {\n\t\t\t    \t//Corner case\n\t\t\t    \tif (num == null || num.length <= 0)\n\t\t\t    \t\treturn null; \n\t\t\t    \t//use a dfs helper to  generate the bst\n\t\t\t    \treturn dfs(num, 0, num.length - 1);\n\t\t\t\t}\n\t\t\t\t//as we know,  using inorder traverse the bst ,we will get a ascending array,\n\t\t\t\tpublic TreeNode dfs(int[] num, int start, int end) {\n\t\t\t\t\t//this is the termination condition.\n\t\t\t\t\tif (start > end) //mean we reach the null node\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tint mid = (start + end) / 2; //every time we let mid = start + end / 2\n\t\t\t\t\tTreeNode root = new TreeNode(num[mid]);//generate a root node\n\t\t\t\t\t//and recursive genarate the left tree and right tree.\n\t\t\t\t\troot.left = dfs(num, start, mid - 1);\n\t\t\t\t\troot.right = dfs(num, mid + 1, end);\n\t\t\t\t\treturn root; \n\t\t\t\t}\n\t\t\t}\n\t\t4.5 Inorder Successor In BST\n\t\t\tpublic class Solution {\n\t\t\t    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n\t\t\t        if (root == null) {\n\t\t\t            return null;\n\t\t\t        }\n\t\t\t        if (root.val <= p.val) {\n\t\t\t            return inorderSuccessor(root.right, p);\n\t\t\t        } else {\n\t\t\t            TreeNode left = inorderSuccessor(root.left, p);\n\t\t\t            return (left != null) ? left : root;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t4.6 Inorder Predecessor In BST\n\t\t\tpublic class Solution {\n\t\t\t\tpublic TreeNode predecessor(TreeNode root, TreeNode p) {\n\t\t\t\t  \tif (root == null)\n\t\t\t\t    \treturn null;\n\t\t\t\t  \tif (root.val >= p.val) {\n\t\t\t\t    \treturn predecessor(root.left, p);\n\t\t\t\t  \t} else {\n\t\t\t\t    \tTreeNode right = predecessor(root.right, p);\n\t\t\t\t    \treturn (right != null) ? right : root;\n\t\t\t\t  \t}\n\t\t\t\t}\n\t\t\t}\n\t\t4.7 Kth Smallest Element In A BST\n\t\t\tpublic class Solution {\n\t\t\t    public int kthSmallest(TreeNode root, int k) {\n\t\t\t        int leftNum = countNode(root.left);\n\t\t\t        if (leftNum + 1 == k) {\n\t\t\t            return root.val;\n\t\t\t        } else if (leftNum + 1 < k) {\n\t\t\t            return kthSmallest(root.right, k - leftNum - 1);\n\t\t\t        } else {\n\t\t\t            return kthSmallest(root.left, k);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    \n\t\t\t    public int countNode(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        return countNode(root.left) + countNode(root.right) + 1;\n\t\t\t    }\n\t\t\t}\n\t\t4.8 Lowest Common Ancestor Of A Binary Search Tree\n\t\t\t    //iterative1 prefer\n\t\t\t    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\t\t        while (true) {\n\t\t\t            if (root.val > p.val && root.val > q.val) {\n\t\t\t                root = root.left;\n\t\t\t            } else if (root.val < p.val && root.val < q.val) {\n\t\t\t                root = root.right;\n\t\t\t            } else {\n\t\t\t                return root;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    //recursive1 prefer\n\t\t\t    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\t\t        if (root.val > p.val && root.val > q.val) {\n\t\t\t            return lowestCommonAncestor(root.left, p, q);\n\t\t\t        } else if (root.val < p.val && root.val < q.val) {\n\t\t\t            return lowestCommonAncestor(root.right, p, q);\n\t\t\t        } else {\n\t\t\t            return root;\n\t\t\t        }\n\t\t\t    }\n\t\t4.9 Recover Binary Search Tree\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public TreeNode firstElement = null;\n\t\t\t\t    public TreeNode secondElement = null;\n\t\t\t\t    public TreeNode preElement = new TreeNode(Integer.MIN_VALUE);\n\t\t\t\t    public void recoverTree(TreeNode root) {\n\t\t\t\t        if (root == null) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        dfs(root);\n\t\t\t\t        int temp = firstElement.val;\n\t\t\t\t        firstElement.val = secondElement.val;\n\t\t\t\t        secondElement.val = temp;\n\t\t\t\t    }\n\t\t\t\t    public void dfs(TreeNode root) {\n\t\t\t\t        if (root == null) {\n\t\t\t\t            return ;\n\t\t\t\t        }\n\t\t\t\t        dfs(root.left);\n\t\t\t\t        if (firstElement == null && preElement.val > root.val) {\n\t\t\t\t            firstElement = preElement;\n\t\t\t\t        }\n\t\t\t\t        if (firstElement != null && preElement.val > root.val) {\n\t\t\t\t            secondElement = root;\n\t\t\t\t        }\n\t\t\t\t        preElement = root;\n\t\t\t\t        dfs(root.right);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t4.10 Validate Binary Search Tree\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isValidBST(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\n\t\t\t    }\n\t\t\t    public boolean isValid(TreeNode root, long min, long max) {\n\t\t\t        if (root == null) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        if (min < root.val && root.val < max) {\n\t\t\t            return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\n\t\t\t        } else {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t4.11 Verify Preorder Sequence In Binary Search Tree\n\t\t\tpublic class Solution {\n\t\t\t    public boolean verifyPreorder(int[] preorder) {\n\t\t\t        int low = Integer.MIN_VALUE;\n\t\t\t        Stack<Integer> stack = new Stack<>();\n\t\t\t        for (int val : preorder) {\n\t\t\t            if (val < low) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t            while (!stack.empty() && val > stack.peek()) {\n\t\t\t                low = stack.pop();\n\t\t\t            }\n\t\t\t            stack.push(val);\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\t\t4.12 Unique Binary Search Trees\n\t\t\tpublic class Solution {\n\t\t\t    public int numTrees(int n) {\n\t\t\t        if (n == 0 || n == 1) {\n\t\t\t            return n;\n\t\t\t        }\n\t\t\t        int[] dp = new int[n + 1];\n\t\t\t        dp[0] = 1;\n\t\t\t        dp[1] = 1;\n\t\t\t        for (int i = 2; i <= n; i++) {\n\t\t\t            for (int j = 0; j < i; j++) {\n\t\t\t                dp[i] += dp[j] * dp[i - j - 1];\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[n];\n\t\t\t    }\n\t\t\t}\n\t\t4.13 Unique Binary Search Trees II(return all the unique BST)\n\t\t\tpublic class Solution {\n\t\t\t    public List<TreeNode> generateTrees(int n) {\n\t\t\t        return helper(1, n);\n\t\t\t    }\n\t\t\t    public List<TreeNode> helper (int left, int right) {\n\t\t\t        List<TreeNode> res = new ArrayList<>();\n\t\t\t        if (left > right) {\n\t\t\t            res.add(null);\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        for (int i = left; i <= right; i++) {\n\t\t\t            List<TreeNode> leftList = helper(left, i - 1);\n\t\t\t            List<TreeNode> rightList = helper(i + 1, right);\n\t\t\t            for (int j = 0; j < leftList.size(); j++) {\n\t\t\t                for (int k = 0; k < rightList.size(); k++) {\n\t\t\t                    TreeNode root = new TreeNode(i);\n\t\t\t                    root.left = leftList.get(j);\n\t\t\t                    root.right = rightList.get(k);\n\t\t\t                    res.add(root);\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\n\n5. Binary Tree Transform\n\t\t5.1 Binary Tree Upside Down\n\t\t\t// Given a binary tree where all the right nodes are either leaf nodes with a sibling \n\t\t\t// (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where \n\t\t\t// the original right nodes turned into left leaf nodes. Return the new root.\n\t\t\t// Given a binary tree {1,2,3,4,5},\n\t\t\t//     1\n\t\t\t//    / \\\n\t\t\t//   2   3\n\t\t\t//  / \\\n\t\t\t// 4   5\n\t\t\t// return the root of the binary tree [4,5,2,#,#,3,1].\n\t\t\t//    4\n\t\t\t//   / \\\n\t\t\t//  5   2\n\t\t\t//     / \\\n\t\t\t//    3   1  \n\t\t\tpublic class Solution {\n\t\t\t\t//DFS \n\t\t\t\tpublic TreeNode upsideDownBinaryTree(TreeNode root) {\n\t\t\t\t\tif (root == null || (root.left == null && root.right == null)) {\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t}\n\t\t\t\t\tTreeNode newRoot = upsideDownBinaryTree(root.left);\n\t\t\t\t\troot.left.left = root.right;\n\t\t\t\t\troot.left.right = root;\n\t\t\t\t\troot.left = null;\n\t\t\t\t\troot.right = null;\n\t\t\t\t\treturn newRoot;\n\t\t\t\t}\n\t\t\t\t//BFS\n\t\t\t\tpublic TreeNode upsideDownBinaryTree(TreeNode root) {\n\t\t\t\t\tTreeNode cur = root;\n\t\t\t\t\tTreeNode pre = null;\n\t\t\t\t\tTreeNode next = null;\n\t\t\t\t\tTreeNode temp = null;\n\t\t\t\t\twhile (cur != null) {\n\t\t\t\t\t\tnext = cur.left;\n\t\t\t\t\t\tcur.left = temp;\n\t\t\t\t\t\ttemp = cur.right;\n\t\t\t\t\t\tcur.right = pre;\n\t\t\t\t\t\tpre = cur;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t}\n\t\t\t\t\treturn pre;\n\t\t\t\t}\n\t\t\t}\n\t\t5.2 Flatten Binary Tree To Linked List（in-place）\n\t\t\t\t\t 1\n\t\t\t        / \\\n\t\t\t       2   5\n\t\t\t      / \\   \\\n\t\t\t     3   4   6     ->  \t   1\n\t\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t     2\n\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t       3\n\t\t\t\t\t\t\t\t\t        \\\n\t\t\t\t\t\t\t\t\t         4\n\t\t\t\t\t\t\t\t\t          \\\n\t\t\t\t\t\t\t\t\t           5\n\t\t\t\t\t\t\t\t\t            \\\n\t\t\t\t\t\t\t\t\t             6 \n\t\t\tpublic class Solution {\n\t\t\t    TreeNode lastvisited = null;\n\t\t\t    public void flatten(TreeNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        TreeNode realRight = root.right;\n\t\t\t        if (lastvisited != null) {\n\t\t\t            lastvisited.left = null;\n\t\t\t            lastvisited.right = root;\n\t\t\t        }\n\t\t\t        lastvisited = root;\n\t\t\t        flatten(root.left);\n\t\t\t        flatten(realRight);\n\t\t\t    }\n\t\t\t}\n\t\t5.3 Invert Binary Tree\n\t\t\tpublic class Solution {\n\t\t\t    public TreeNode invertTree(TreeNode root) {\n\t\t\t        if (root == null || (root.left == null && root.right == null)) {\n\t\t\t            return root;\n\t\t\t        }\n\t\t\t        TreeNode tempLeft = root.left;\n\t\t\t        root.left = invertTree(root.right);\n\t\t\t        root.right = invertTree(tempLeft);\n\t\t\t        return root;\n\t\t\t    }\n\t\t\t}\n\t\t5.4 Populating Next Right Pointers In Each Node(Perfect Binary Tree)\n\t\t\tpublic class Solution {\n\t\t\t\t//Recursive\n\t\t\t    public void connect(TreeLinkNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        if (root.left != null) {\n\t\t\t            root.left.next = root.right;\n\t\t\t        }\n\t\t\t        if (root.right != null && root.next != null) {\n\t\t\t            root.right.next = root.next.left;\n\t\t\t        }\n\t\t\t        connect(root.left);\n\t\t\t        connect(root.right);\n\t\t\t    }\n    \t\t\t//Iterative\n\t\t\t    public void connect(TreeLinkNode root) {\n\t\t\t        if (root == null) {\n\t\t\t            return;\n\t\t\t        }\n\t\t\t        TreeLinkNode cur = root;\n\t\t\t        while (cur != null && cur.left != null) {\n\t\t\t            cur.left.next = cur.right;\n\t\t\t            if (cur.next != null) {\n\t\t\t                cur.right.next = cur.next.left;\n\t\t\t                cur = cur.next;\n\t\t\t            } else {\n\t\t\t                root = root.left;\n\t\t\t                cur = root;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t5.5\tPopulating Next Right Pointers In Each Node II(No Need To A Perfect Binary Tree)\n\t\t\t\tpublic void connect(TreeLinkNode root) {\n\t\t\t\t    //tempChild 是每层的头结点（dummy node） tempChild.next是每层最左边的结点\n\t\t\t        TreeLinkNode tempChild = new TreeLinkNode(0);\n\t\t\t        while (root != null) {\n\t\t\t            TreeLinkNode curChild = tempChild;//用curChild 来遍历root下的left和right child 并设置next\n\t\t\t            while (root != null) {\n\t\t\t                if (root.left != null) {\n\t\t\t                    curChild.next = root.left;\n\t\t\t                    curChild = curChild.next;\n\t\t\t                }\n\t\t\t                if (root.right != null) {\n\t\t\t                    curChild.next = root.right;\n\t\t\t                    curChild = curChild.next;\n\t\t\t                }\n\t\t\t                //root的左右儿子都设置完后，root向右前进.\n\t\t\t                root = root.next;\n\t\t\t            }\n\t\t\t            //遍历完一层的root，也就是设置完root这一层的结点的儿子们的next指针后， 将tempChild 赋值给root，因为tempChild是root下面那一层的最左边的孩子\n\t\t\t            root = tempChild.next;\n\t\t\t            tempChild.next = null;\n\t\t\t        }\n\t\t\t    }\n\n\n\n6. Construct Binary Tree\n\t\t6.1 Construct Binary Tree From Preorder And Inorder Traversal\n\t\t\tpublic class Solution {\n\t\t\t    public TreeNode buildTree(int[] preorder, int[] inorder) {\n\t\t\t        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n\t\t\t    }\n\t\t\t    public TreeNode build(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd) {\n\t\t\t        if (preStart > preEnd || inStart > inEnd) {\n\t\t\t            return null;\n\t\t\t        }\n\t\t\t        int rootVal = pre[preStart];\n\t\t\t        int rootIndex = 0;\n\t\t\t        for (int i = inStart; i <= inEnd; i++) {\n\t\t\t            if (in[i] == rootVal) {\n\t\t\t                rootIndex = i;\n\t\t\t                break;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        int len = rootIndex - inStart;\n\t\t\t        TreeNode root = new TreeNode(rootVal);\n\t\t\t        root.left = build(pre, preStart + 1, preStart + len, in, inStart, rootIndex - 1);\n\t\t\t        root.right = build(pre, preStart + len + 1, preEnd, in, rootIndex + 1, inEnd);\n\t\t\t        return root;\n\t\t\t    }\n\t\t\t}\n\t\t6.2 Construct Binary Tree From Inorder And Postorder Traversal\n\t\t\tpublic class Solution {\n\t\t\t    public TreeNode buildTree(int[] inorder, int[] postorder) {\n\t\t\t        return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n\t\t\t    }\n\t\t\t    public TreeNode build(int[] in, int inStart, int inEnd, int[] post, int postStart, int postEnd) {\n\t\t\t        if (inStart > inEnd || postStart > postEnd) {\n\t\t\t            return null;\n\t\t\t        }\n\t\t\t        int rootVal = post[postEnd];\n\t\t\t        int rootIndex = postEnd;\n\t\t\t        for (int i = inStart; i <= inEnd; i++) {\n\t\t\t            if (in[i] == rootVal) {\n\t\t\t                rootIndex = i;\n\t\t\t                break;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        int len = rootIndex - inStart;\n\t\t\t        TreeNode root = new TreeNode(rootVal);\n\t\t\t        root.left = build(in, inStart, rootIndex - 1, post, postStart, postStart + len - 1);\n\t\t\t        root.right = build(in, rootIndex + 1, inEnd, post, postStart + len, postEnd - 1);\n\t\t\t        return root;\n\t\t\t    }\n\t\t\t}\n\t\t6.3 Serialize And Deserialize Binary Tree\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t\t//\n\t\t\t\t\tpublic String serialize(TreeNode root) {\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        buildString(root, sb);\n\t\t\t\t        return sb.toString();\n\t\t\t\t    }\n\t\t\t\t    private void buildString(TreeNode node, StringBuilder sb) {\n\t\t\t\t        if (node == null) {\n\t\t\t\t            sb.append(\"#\").append(\" \");\n\t\t\t\t        } else {\n\t\t\t\t            sb.append(node.val).append(\" \");\n\t\t\t\t            buildString(node.left, sb);\n\t\t\t\t            buildString(node.right, sb);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    // Decodes your encoded data to tree.\n\t\t\t\t    public TreeNode deserialize(String data) {\n\t\t\t\t        if (data == null) {\n\t\t\t\t            return null;\n\t\t\t\t        }\n\t\t\t\t        String[] strs = data.split(\" \");\n\t\t\t\t        Queue<String> queue = new LinkedList<>();\n\t\t\t\t        queue.addAll(Arrays.asList(strs));\n\t\t\t\t        return buildTree(queue);\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t    public TreeNode buildTree(Queue<String> queue) {\n\t\t\t\t        String val = queue.poll();\n\t\t\t\t        if (val.equals(\"#\")) {\n\t\t\t\t            return null;\n\t\t\t\t        } else {\n\t\t\t\t            TreeNode node = new TreeNode(Integer.valueOf(val));\n\t\t\t\t            node.left = buildTree(queue);\n\t\t\t\t            node.right = buildTree(queue);\n\t\t\t\t            return node;\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\tpublic class Codec {\n\t\t\t\t\tpublic String serialize(TreeNode root) {\n\t\t\t\t        if (root == null) {\n\t\t\t\t            return \"\";\n\t\t\t\t        }\n\t\t\t\t        Queue<TreeNode> queue = new LinkedList<>();\n\t\t\t\t        queue.offer(root);\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        while (!queue.isEmpty()) {\n\t\t\t\t            int size = queue.size();\n\t\t\t\t            for (int i = 0; i < size; i++) {\n\t\t\t\t                TreeNode cur = queue.poll();\n\t\t\t\t                if (cur != null) {\n\t\t\t\t                    queue.offer(cur.left);\n\t\t\t\t                    queue.offer(cur.right);\n\t\t\t\t                }\n\t\t\t\t                String val = cur == null ? \"#\" : String.valueOf(cur.val);\n\t\t\t\t                sb.append(val);\n\t\t\t\t                sb.append(\",\");\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        sb.deleteCharAt(sb.length() - 1);\n\t\t\t\t        return sb.toString();\n\t\t\t\t    }\n\t\t\t\t\t// Decodes your encoded data to tree.\n\t\t\t\t     public TreeNode deserialize(String data) {\n\t\t\t\t        if (data == null || data.length() == 0) {\n\t\t\t\t            return null;\n\t\t\t\t        }\n\t\t\t\t        String[] val = data.split(\",\");\n\t\t\t\t        TreeNode root = new TreeNode(Integer.valueOf(val[0]));\n\t\t\t\t        Queue<TreeNode> queue = new LinkedList<>();\n\t\t\t\t        queue.offer(root);\n\t\t\t\t        //i控制string数组里的值，queue控制遍历的TreeNode，val[i] ,val[i + 1] 确保是 cur的left和right节点值，则有 \n\t\t\t\t        for (int i = 1; i < val.length; i += 2) {\n\t\t\t\t            TreeNode cur = queue.poll();\n\t\t\t\t            if (!\"#\".equals(val[i])) {\n\t\t\t\t                TreeNode left = new TreeNode(Integer.valueOf(val[i]));\n\t\t\t\t                cur.left = left;\n\t\t\t\t                queue.offer(left);\n\t\t\t\t            }\n\t\t\t\t            if (i + 1 < data.length() && !\"#\".equals(val[i + 1])) {\n\t\t\t\t                TreeNode right = new TreeNode(Integer.valueOf(val[i + 1]));\n\t\t\t\t                cur.right = right;\n\t\t\t\t                queue.offer(right);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return root;\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  ]
}