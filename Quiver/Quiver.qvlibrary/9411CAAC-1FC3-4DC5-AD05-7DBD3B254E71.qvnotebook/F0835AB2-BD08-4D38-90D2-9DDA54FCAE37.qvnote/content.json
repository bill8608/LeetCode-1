{
  "title": "Dynamic Programming",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "/*\n\tDynamic Programming\n*/\n\n\n\n1. Word And String Problem\n\t\t1.1 Word Break I\n\t\t\t/*\n\t\t\t\ts = \"leetcode\",\n\t\t\t\tdict = [\"leet\", \"code\"].\n\t\t\t\tReturn true because \"leetcode\" can be segmented as \"leet code\".\n\t\t\t\tnote that: dict can be used mutiple times.\n\t\t\t\tO(n*n), dp\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean wordBreak(String s, Set<String> wordDict) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        if (wordDict == null || wordDict.size() == 0) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        boolean[] dp = new boolean[s.length() + 1];\n\t\t\t        dp[0] = true;\n\t\t\t        // for (int i = 0; i <= s.length(); i++) {\n\t\t\t        //     for (int j = i + 1; j <= s.length(); j++) {\n\t\t\t        //         if (wordDict.contains(s.substring(i, j)) && dp[i]) {\n\t\t\t        //             dp[j] = true;\n\t\t\t        //         }\n\t\t\t        //     }\n\t\t\t        // }\n\t\t\t        for (int i = 1; i <= s.length(); i++) {\n\t\t\t            for (int j = 0; j <= i; j++) {\n\t\t\t                if (wordDict.contains(s.substring(j, i)) && dp[j]) {\n\t\t\t                    dp[i] = true;\n\t\t\t                    break;\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[s.length()];\n\t\t\t    }\n\t\t\t}\n\t\t1.2 Longest Palindromic Substring\n\t\t\tpublic class Solution {\n\t\t\t\tpublic String longestPalindrome(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return \"\";\n\t\t\t        }\n\t\t\t        //isPalin[i][j], i and j are two indices of the string, \n\t\t\t        //denote whether substring from i to j is palindrome;\n\t\t\t        //isPalin[i][i] is always palindrome, since s.charAt(i) == s.charAt(i)\n\t\t\t        boolean[][] isPalind = new boolean[s.length()][s.length()];\n\t\t\t        String res = \"\";\n\t\t\t        int maxLen = 0;\n\t\t\t        for (int i = s.length() - 1; i >= 0; i--) {\n\t\t\t            for (int j = i; j < s.length(); j++) {\n\t\t\t                // j - i <= 2 --> aba or aa 肯定palindrome\n\t\t\t                if (s.charAt(i) == s.charAt(j) && (j - i <= 2 || isPalind[i + 1][j - 1])) {\n\t\t\t                    isPalind[i][j] = true;\n\t\t\t                    if (maxLen < j - i + 1) {\n\t\t\t                        maxLen = j - i + 1;\n\t\t\t                        res = s.substring(i, j + 1);\n\t\t\t                    }\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t1.3 Edit Distance\n\t\t\t/*\n\t\t\t\tGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. \n\t\t\t*/\n\t\t\t//2D DP\n\t\t\tpublic class Solution {\n\t\t\t    public int minDistance(String word1, String word2) {\n\t\t\t        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n\t\t\t        for (int i = 0; i <= word1.length(); i++) {\n\t\t\t            dp[i][0] = i;\n\t\t\t        }\n\t\t\t        for (int i = 0; i <= word2.length(); i++) {\n\t\t\t            dp[0][i] = i;\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= word1.length(); i++) {\n\t\t\t            for (int j = 1; j <= word2.length(); j++) {\n\t\t\t                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {\n\t\t\t                    int delete = dp[i][j - 1] + 1;\n\t\t\t                    int insert = dp[i - 1][j] + 1;\n\t\t\t                    int replace = dp[i - 1][j - 1] + 1;\n\t\t\t                    dp[i][j] = Math.min(insert, Math.min(delete, replace));\n\t\t\t                } else {\n\t\t\t                    dp[i][j] = dp[i - 1][j - 1];\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[word1.length()][word2.length()];\n\t\t\t    }\n\t\t\t}\n\t\t\t//1D DP\n\t\t\tpublic class Solution {\n\t\t\t    public int minDistance(String word1, String word2) {\n\t\t\t        int[] dp = new int[word2.length() + 1];\n\t\t\t        for (int i = 0; i <= word2.length(); ++i) {\n\t\t\t        \tdp[i] = i;\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= word1.length(); ++i) {\n\t\t\t            int pre = dp[0];\n\t\t\t            dp[0] = i;\n\t\t\t            for (int j = 1; j <= word2.length(); ++j) {\n\t\t\t                int temp = dp[j];\n\t\t\t                dp[j] = Math.min(dp[j - 1], dp[j]) + 1;\n\t\t\t                dp[j] = Math.min(dp[j], pre + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\n\t\t\t                pre = temp;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[word2.length()];\n\t\t\t    }\n\t\t\t}\n\n\t\t1.4 Scramble String\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isScramble(String s1, String s2) {\n\t\t\t        if (s1 == null || s2 == null || s1.length() != s2.length()) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        if (s1.length() == 0) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        boolean[][][] check = new boolean[s1.length()][s2.length()][s1.length() + 1];\n\t\t\t        for (int i = 0; i < s1.length(); i++) {\n\t\t\t            for (int j = 0; j < s2.length(); j++) {\n\t\t\t                check[i][j][1] = s1.charAt(i) == s2.charAt(j);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        for (int len = 2; len <= s1.length(); len++) {\n\t\t\t            for (int i = 0; i + len - 1 < s1.length(); i++) {\n\t\t\t                for (int j = 0; j + len - 1 < s2.length(); j++) {\n\t\t\t                    for (int k = 1; k < len; k++) {\n\t\t\t                        check[i][j][len] |= check[i][j][k] && check[i + k][j + k][len - k] ||\n\t\t\t                                            check[i][j + len - k][k] && check[i + k][j][len - k];\n\t\t\t                    }\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return check[0][0][s1.length()];\n\t\t\t    }\n\t\t\t}\n\t\t1.5 Interleaving String\n\t\t\t/*\n\t\t\t\tGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n\t\t\t\tFor example,\n\t\t\t\tGiven:\n\t\t\t\ts1 = \"aabcc\",\n\t\t\t\ts2 = \"dbbca\",\n\t\t\t\tWhen s3 = \"aadbbcbcac\", return true.\n\t\t\t\tWhen s3 = \"aadbbbaccc\", return false.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isInterleave(String s1, String s2, String s3) {\n\t\t\t        int m = s1.length();\n\t\t\t        int n = s2.length();\n\t\t\t        if (m + n != s3.length()) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        boolean[][] dp = new boolean[m + 1][n + 1];\n\t\t\t        dp[0][0] = true;\n\t\t\t        for (int i = 1; i <= m; i++) {\n\t\t\t            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= n; i++) {\n\t\t\t            dp[0][i] = dp[0][i - 1] && s2.charAt(i - 1) == s3.charAt(i - 1);\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= m; i++) {\n\t\t\t            for (int j = 1; j <= n; j++) {\n\t\t\t                dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1) ||\n\t\t\t                           dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[m][n];\n\t\t\t    }\n\t\t\t}\n\n\n\n\t\t\n\n\n2. Subsequence Problem\t \t\n\t\t2.1 Longest Common Subsequence\n\t\t\tpublic class Solution {\n\t\t\t    /**\n\t\t\t     * @param A, B: Two strings.\n\t\t\t     * @return: The length of longest common subsequence of A and B.\n\t\t\t     */\n\t\t\t    public int longestCommonSubsequence(String A, String B) {\n\t\t\t        // write your code here\n\t\t\t        int[][] dp = new int[A.length() + 1][B.length() + 1];\n\t\t\t        for (int i = 1; i <= A.length(); i++) {\n\t\t\t            for (int j = 1; j <= B.length(); j ++) {\n\t\t\t                if(A.charAt(i - 1) == B.charAt(j - 1)) {\n\t\t\t                    dp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t                } else {\n\t\t\t                    dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][j], dp[i][j - 1]));\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[A.length()][B.length()];\n\t\t\t    }\n\t\t\t}\n\t\t2.2 Distinct Subsequences\n\t\t\t/*\n\t\t\t\tGiven a string S and a string T, count the number of distinct subsequences of T in S.\n\t\t\t\t(ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n\t\t\t\tHere is an example:\n\t\t\t\t\tS = \"rabbbit\", T = \"rabbit\"\n\t\t\t\teturn 3.\n\t\t\t*/\n\t\t\t//Solution1: 2D dp\n\t\t\tpublic class Solution {\n\t\t\t    public int numDistinct(String s, String t) {\n\t\t\t        if (s == null || t == null || s.length() < t.length()) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int[][] dp = new int[s.length() + 1][t.length() + 1];\n\t\t\t        for (int i = 0; i <= s.length(); i++) {\n\t\t\t            dp[i][0] = 1;\n\t\t\t        }\n\t\t\t        for (int i = 1; i <= s.length(); i++) {\n\t\t\t            for (int j = 1; j <= t.length(); j++) {\n\t\t\t                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n\t\t\t                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n\t\t\t                } else {\n\t\t\t                    dp[i][j] = dp[i - 1][j];\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[s.length()][t.length()];\n\t\t\t    }\n\t\t\t}\n\t\t\t//Solution2: 1D dp\n\t\t\tpublic class Solution {\n\t\t\t\tpublic int numDistinct(String s, String t) {\n\t\t\t        if (s == null || t == null || s.length() < t.length()) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int[] dp = new int[t.length() + 1];\n\t\t\t        dp[0] = 1;\n\t\t\t        //dp[j] 在每一层i loop中，就意味着dp[i][j]\n\t\t\t        for (int i = 1; i <= s.length(); i++) {\n\t\t\t            int pre = 1;\n\t\t\t            for (int j = 1; j <= t.length(); j++) {\n\t\t\t                int temp = dp[j];//dp[i - 1][j]\n\t\t\t                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n\t\t\t                    dp[j] = dp[j] + pre;//dp[j] = dp[i - 1][j], pre = dp[i - 1][j - 1]\n\t\t\t                }\n\t\t\t                pre = temp;//到下一个j的时候 dp[i - 1][j] 就变成了dp[i - 1][j - 1]\n\t\t\t                \n\t\t\t            }\n\t\t\t        }\n\t\t\t        return dp[t.length()];\n\t\t\t    }\n\t\t\t}\n\t\t2.3 Longest Increasing Subsequence\n\t\t\t//O(n*n) dp\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLIS(int[] nums) {\n\t\t\t        if (nums == null || nums.length == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int[] dp = new int[nums.length];\n\t\t\t        int max = 0;\n\t\t\t        Arrays.fill(dp, 1);\n\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t            for (int j = 0; j < i; j++) {\n\t\t\t                if (nums[i] > nums[j]) {\n\t\t\t                    dp[i] = Math.max(dp[j] + 1, dp[i]);\n\t\t\t                }\n\t\t\t            }\n\t\t\t            max = Math.max(max, dp[i]);\n\t\t\t        }\n\t\t\t        return max;\n\t\t\t    }\n\t\t\t}\n\t\t\t//O(n),binarySearch and Dp\n\t\t\t/*\n\t\t\t    The idea is that as you iterate the sequence, you keep track of the minimum value a subsequence of given length might end with, \n\t\t\t    for all so far possible subsequence lengths. So dp[i] is the minimum value a subsequence of length i+1 might end with. Having this info,\n\t\t\t     for each new number we iterate to, we can determine the longest subsequence where it can be appended using binary search. \n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int lengthOfLIS(int[] nums) {\n\t\t\t        int[] dp = new int[nums.length];\n\t\t\t        int len = 0;\n\t\t\t        for (int num : nums) {\n\t\t\t            int i = binarySearch(dp, 0, len, num);\n\t\t\t            dp[i] = num;\n\t\t\t            if (i == len) {\n\t\t\t                len++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return len;\n\t\t\t    }\n\t\t\t    private int binarySearch(int[] nums, int start, int end, int target) {\n\t\t\t        while (start < end) {\n\t\t\t            int mid = start + (end - start)/2;\n\t\t\t            if (nums[mid] >= target) {\n\t\t\t                end = mid;\n\t\t\t            } else {\n\t\t\t                start = mid + 1;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return end;\n\t\t\t    }\n\t\t\t}\n\t\t\n\t\t"
    }
  ]
}