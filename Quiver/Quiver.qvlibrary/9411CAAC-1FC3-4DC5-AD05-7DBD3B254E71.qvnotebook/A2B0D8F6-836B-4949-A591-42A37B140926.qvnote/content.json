{
  "title": "HashTable",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "/*\n\tHashTable\n*/\n\n\n\n\n1. String And Word Problem\n\t\t1.1 Palindrome Permutation\n\t\t\t/*\n\t\t\t\tGiven a string, determine if a permutation of the string could form a palindrome.\n\t\t\t\tFor example,\n\t\t\t\t\"code\" -> False, \"aab\" -> True, \"carerac\" -> True.\n\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean canPermutePalindrome(String s) {\n\t\t\t\t        int[] letter = new int[256];\n\t\t\t\t        int count = 0;\n\t\t\t\t        for (char c : s.toCharArray()) {\n\t\t\t\t            if (letter[c] == 0) {\n\t\t\t\t                letter[c]++;\n\t\t\t\t            } else {\n\t\t\t\t                letter[c]--;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        for (int i : letter) {\n\t\t\t\t            count += i;\n\t\t\t\t        }\n\t\t\t\t        return count > 1 ? false : true;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t1.2 Valid Anagram\n\t\t\t/*\n\t\t\t\tFor example,\n\t\t\t\t\ts = \"anagram\", t = \"nagaram\", return true.\n\t\t\t\t\ts = \"rat\", t = \"car\", return false.\n\n\t\t\t\tNote:\n\t\t\t\t\tYou may assume the string contains only lowercase alphabets.\n\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean isAnagram(String s, String t) {\n\t\t\t\t        if (s.length() != t.length()) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        int[] arr = new int[26];\n\t\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t\t            arr[s.charAt(i) - 'a']++;\n\t\t\t\t            arr[t.charAt(i) - 'a']--;\n\t\t\t\t        }\n\t\t\t\t        for (int value : arr) {\n\t\t\t\t            if (value != 0) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t1.2 Group Shifted Strings\n\t\t\t/*\n\t\t\t\tFor example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], \n\t\t\t\tReturn:\n\n\t\t\t\t[\n\t\t\t\t  [\"abc\",\"bcd\",\"xyz\"],\n\t\t\t\t  [\"az\",\"ba\"],\n\t\t\t\t  [\"acef\"],\n\t\t\t\t  [\"a\",\"z\"]\n\t\t\t\t]\n\t\t\t*/\n\t\t\t// (s.charAt(i) - s.charAt(0) + 26) % 26\n\t\t\t\tpublic List<List<String>> groupStrings(String[] strings) {\n\t\t\t        List<List<String>> res = new ArrayList<>();\n\t\t\t        Map<String, List<String>> map = new HashMap<>();        \n\t\t\t        for (String s : strings) {\n\t\t\t            String key = \"\";\n\t\t\t            for (int i = 0; i < s.length(); i++) {\n\t\t\t                char c = (char)((s.charAt(i) - s.charAt(0) + 26) % 26);\n\t\t\t                key += c;\n\t\t\t            }\n\t\t\t            if (!map.containsKey(key)) {\n\t\t\t                map.put(key, new ArrayList<String>());\n\t\t\t            }\n\t\t\t            map.get(key).add(s);\n\t\t\t        }\n\t\t\t        for (List<String> item : map.values()) {\n\t\t\t            Collections.sort(item);\n\t\t\t            res.add(item);\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t1.3 Shortest Word Distance II\n\t\t\t/*\n\t\t\t\tFor example,\n\t\t\t\t\tAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\n\t\t\t\t\tGiven word1 = “coding”, word2 = “practice”, return 3.\n\t\t\t\t\tGiven word1 = \"makes\", word2 = \"coding\", return 1.\n\t\t\t\tNote:\n\t\t\t\t\tYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\n\t\t\t\t\tCall mutiple time\n\t\t\t*/\n\t\t\tpublic class WordDistance {\n\t\t\t    private HashMap<String, ArrayList<Integer>> map;\n\t\t\t    public WordDistance(String[] words) {\n\t\t\t        map = new HashMap<String, ArrayList<Integer>>();\n\t\t\t        for (int i = 0; i < words.length; i++) {\n\t\t\t            if (!map.containsKey(words[i])) {\n\t\t\t                map.put(words[i], new ArrayList<>());\n\t\t\t            }\n\t\t\t            map.get(words[i]).add(i);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    public int shortest(String word1, String word2) {\n\t\t\t        List<Integer> list1 = map.get(word1);\n\t\t\t        List<Integer> list2 = map.get(word2);\n\t\t\t        int minLen = Integer.MAX_VALUE;\n\t\t\t        int i = 0;\n\t\t\t        int j = 0;\n\t\t\t        while (i < list1.size() && j < list2.size()) {\n\t\t\t            minLen = Math.min(minLen, Math.abs(list1.get(i) - list2.get(j)));\n\t\t\t            if (list1.get(i) > list2.get(j)) {\n\t\t\t                j++;\n\t\t\t            } else {\n\t\t\t                i++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return minLen;\n\t\t\t    }\n\t\t\t}\n\n2. Array Problem\n\t\t2.1 Duplicate Problem\n\t\t\t2.1.1 Contains Duplicate I\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean containsDuplicate(int[] nums) {\n\t\t\t\t        if (nums.length == 0 || nums == null) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        HashSet<Integer> set = new HashSet<Integer>();\n\t\t\t\t        for (int i : nums) {\n\t\t\t\t            if (set.contains(i)) {\n\t\t\t\t                return true;\n\t\t\t\t            } else {\n\t\t\t\t                set.add(i);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t2.1.2 Contains Duplicate II\n\t\t\t\t/*\n\t\t\t\t\tGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] \n\t\t\t\t\tand the difference between i and j is at most k.\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean containsNearbyDuplicate(int[] nums, int k) {\n\t\t\t\t        if (nums == null || nums.length <= 1) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        HashMap<Integer, Integer> map = new HashMap<>();\n\t\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t\t            if (map.containsKey(nums[i])) {\n\t\t\t\t                if (i - map.get(nums[i]) <= k) {\n\t\t\t\t                    return true;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            map.put(nums[i], i);\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t2.1.3 Contains Duplicate III\n\t\t\t\t/*\n\t\t\t\t\tGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t \n\t\t\t\t\tand the difference between i and j is at most k.\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n\t\t\t\t        if (t < 0) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        HashMap<Integer, Integer> map = new HashMap<>();//key存储的是nums[i]的值，value是下标\n\t\t\t\t        t++;\n\t\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t\t            //距离只要超过k就移除最左边界限的数\n\t\t\t\t            if (i > k) {\n\t\t\t\t                map.remove(getID(nums[i - k - 1], t));\n\t\t\t\t            }\n\t\t\t\t            int m = getID(nums[i], t);\n\t\t\t\t            //只要存在duplicate则一定会在下标范围k以内，因为上一句已确保\n\t\t\t\t            if (map.containsKey(m)) {\n\t\t\t\t                return true;\n\t\t\t\t            }\n\t\t\t\t            if (map.containsKey(m - 1) && Math.abs(nums[i] - map.get(m - 1)) < t) {\n\t\t\t\t                return true;\n\t\t\t\t            }\n\t\t\t\t            if (map.containsKey(m + 1) && Math.abs(nums[i] - map.get(m + 1)) < t) {\n\t\t\t\t                return true;\n\t\t\t\t            }\n\t\t\t\t            map.put(m, nums[i]);\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t    //ID是根据数组的值计算bucket，而不是下标！\n\t\t\t\t    private int getID(int i, int t) {\n\t\t\t\t        return i < 0 ? (i + 1)/t - 1 : i / t;\n\t\t\t\t        //为什么要这么做？因为在java中 -3/5 == 0 而不是-1\n\t\t\t\t        /*\n\t\t\t\t            比如t = 4， 则 （-5，-4， -3， -2， -1） 在bucket为 -1的桶里， \n\t\t\t\t                         （0， 1， 2， 3， 4）在bucket为0的桶里， \n\t\t\t\t                          （-10， -9， -8， -7， -6） 在bucket为-2 的桶里，   i < 0 == (i + 1) / t - 1, 解决负数时的索引问题\n\t\t\t\t        */\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\n3. Math Problem\n\t3.1\tHappy Number\n\t\t/*\n\t\t\tA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\t\t\tExample: 19 is a happy number\n\t\t\t\t12 + 92 = 82\n\t\t\t\t82 + 22 = 68\n\t\t\t\t62 + 82 = 100\n\t\t\t\t12 + 02 + 02 = 1\n\t\t*/\t\n\t\tpublic class Solution {\n\t\t    public boolean isHappy(int n) {\n\t\t        HashSet<Integer> set = new HashSet<>();\n\t\t        int sum = 0;\n\t\t        int remain = 0;\n\t\t        while (set.add(n)) {\n\t\t            sum = 0;\n\t\t            while (n > 0) {\n\t\t                remain = n % 10;\n\t\t                sum += remain * remain;\n\t\t                n = n / 10;\n\t\t            }\n\t\t            if (sum == 1) {\n\t\t                return true;\n\t\t            } else {\n\t\t                n = sum;\n\t\t            }\n\t\t        }\n\t\t        return false;\n\t\t    }\n\t\t}\n\t3.2 Strobogrammatic Number I\n\t\t/*\n\t\t\tA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\t\t\tWrite a function to determine if a number is strobogrammatic. The number is represented as a string.\n\t\t\tFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.\n\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isStrobogrammatic(String num) {\n\t\t\t        if (num == null || num.length() == 0) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        HashMap<Character, Character> map = new HashMap<>();\n\t\t\t        map.put('6', '9');\n\t\t\t        map.put('9', '6');\n\t\t\t        map.put('8', '8');\n\t\t\t        map.put('0', '0');\n\t\t\t        map.put('1', '1');\n\t\t\t        int start = 0;\n\t\t\t        int end = num.length() - 1;\n\t\t\t        while (start <= end) {\n\t\t\t            char c1 = num.charAt(start);\n\t\t\t            char c2 = num.charAt(end);\n\t\t\t            if (!map.containsKey(c1) || !map.containsKey(c2)) {\n\t\t\t                return false;\n\t\t\t            } else if (map.get(c1) == c2) {\n\t\t\t                start++;\n\t\t\t                end--;\n\t\t\t            } else {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5. Appendix Implement HashTable\npublic class HashTable {\n    public Bucket[] buckets;\n    public int entryNum;\n    public static final int DEFAULT_SIZE = 2029;\n    /**\n     * default constructor with size 2029\n     */\n    public HashTable(){\n    \tbuckets = new Bucket[DEFAULT_SIZE];\n    \tentryNum = 0;\n    }\n\t\n    /**\n     * constructor for hash table with a given size\n     * @param size\n     */\n    public HashTable(int size){\n    \tbuckets = new Bucket[size];\n    \tentryNum = 0;\n    }\n    \n    /**\n     * hash function using double hashing\n     * for the collision resolution function, we choose\n     * hash_2(k) = R - (k mod R) \n     * where R is a prime number that is smaller than the size of the table\n     * since we know the size of hash table will grow larger than the default size\n     * as we keep inserting, we can choose R to be 2027 \n     * \n     * We choose this collision resolution function because it never evaluates to zero and \n     * all cells in the table can be probed.\n     * This function is also easy and quick to compute and achieves even distribution\n     * Also, the lecture slide says it is a popular hash function for double addressing\n     * @param b\n     * @param j\n     * @return value of hash function\n     */\n    public int hashFunction(Bucket b, int j){\n    \tint i = b.getKey();\n    \tint m = buckets.length;\n    \tint hash_1 = i % m;\n    \tint hash_2 = 2027 - (i % 2027);\n    \treturn (hash_1 + j*hash_2) % m;\n    }\n    \n    /**\n     * insert a process as a bucket\n     * @param b\n     * @return index of the inserted item\n     *         -1 if it is a duplicate\n     */\n    public int insert(Bucket b){\n    \t//if table not large enough, do rehasing\n    \tif(1.0*entryNum/buckets.length >= 0.5){\n    \t\trehash();\n    \t}\n    \n    \tint i = 0;\n    \tdo{\n    \t\tint j = hashFunction(b,i);\n    \t\t//find duplicate\n    \t\tif(buckets[j] != null){\n    \t\t\tif(b.getKey() == buckets[j].getKey()){\n    \t\t\t\treturn -1;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t//find right position to insert\n    \t\tif(buckets[j]==null || buckets[j].getLive()==false){\n    \t\t\tbuckets[j] = b;\n    \t\t\tentryNum ++;\n    \t\t\treturn j;\n    \t\t}\n    \t\t//keep probing\n    \t\telse{\n    \t\t\ti ++;\n    \t\t}\n    \t}while(i!=buckets.length-1);\n    \treturn -1;\n    }\n    \n    /**\n     * remove process from hash table\n     * @param b\n     */\n    public void remove(Bucket b){\n    \t//find the index of the process to be removed\n    \tint index = findIndex(b);\n    \t//set the bucket to dead\n    \tif(isLive(index)){\n    \t\tbuckets[index].setLive(false);\n    \t\tentryNum --;\n    \t}\n    }\n    \n    \n    /**\n     * search for a process in the hash table\n     * @param b\n     * @return index of process to be searched and -1 otherwise\n     */\n    public int search(Bucket b){\n    \tint i = 0;\n    \tint j = hashFunction(b,i);\n    \twhile(buckets[j]!=null || i!=buckets.length-1){\n    \t\tif(b.equals(buckets[j])){\n    \t\t\treturn j;\n    \t\t}else{\n    \t\t\ti ++;\n    \t\t\tj = hashFunction(b,i);\n    \t\t}\t\n    \t}\n    \treturn -1;\n    }\n    \n   \n    /**\n     * find the index of a given bucket\n     * @param b\n     * @return index of the given bucket\n     */\n    public int findIndex(Bucket b){\n    \tint i = 0;\n  \n    \tint curr = hashFunction(b,i);\n    \twhile(buckets[curr]!=null & !b.equals(buckets[curr])){\n    \t\ti ++;\n    \t\tcurr = hashFunction(b,i);\n    \t}\n    \treturn curr;\n    }\n    \n\n    \n    /**\n     * check if the bucket is live\n     * @param i\n     * @return true if the bucket is live and false otherwise\n     */\n    public boolean isLive(int i){\n    \tif(buckets[i]!=null && buckets[i].getLive()){\n    \t\treturn true;\n    \t}else{\n    \t\treturn false;\n    \t}\n    }\n    \n    /**\n     * make hash table empty\n     */\n    public void makeEmpty(){\n    \tentryNum = 0;\n    \tfor(int i=0; i<buckets.length; i++){\n    \t\tbuckets[i] = null;\n    \t}\n    }\n    \n    /**\n     * rehashing the table\n     */\n    public void rehash(){\n    \tBucket[] oldBuckets = buckets;\n    \t//enlarge the table\n    \t//the new size is the next prime larger than twice the old size\n    \tbuckets = new Bucket[2*oldBuckets.length];\n    \tentryNum = 0;\n    \t//insert old buckets into the new hash table\n    \tfor(int i=0; i<oldBuckets.length; i++){\n    \t\tif(oldBuckets[i]!=null && oldBuckets[i].getLive()){\n    \t\t\tinsert(oldBuckets[i]);\n    \t\t}\n    \t}\n    }\n    \n    \n    /**\n     * get the size of hash table\n     * @return size of hash table\n     */\n    public int getSize(){\n    \treturn entryNum;\n    }\n}\n\n"
    }
  ]
}