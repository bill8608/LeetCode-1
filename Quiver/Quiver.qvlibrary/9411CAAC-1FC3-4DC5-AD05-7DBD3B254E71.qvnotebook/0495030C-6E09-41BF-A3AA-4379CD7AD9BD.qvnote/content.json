{
  "title": "Linked List",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "1. Reverse Linked List\n\t1.1\t最普通的reverse，给你一个ListNode，然后reverse从这个ListNode 开始的所有节点\n\t\tpublic ListNode reverse(ListNode head) {\n\t\t\tListNode pre = null;\n\t\t\twhile (head != null) {\n\t\t\t\tListNode next = head.next;\n\t\t\t\thead.next = pre;\n\t\t\t\tpre = head;\n\t\t\t\thead = next;\n\t\t\t}\n\t\t}\n\n\t1.2\t反转从链表的第m个结点至第n个结点，1 <= m <= n <= length of list\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < m - 1) {//先找到m-1这个点\n\t\t\t\tpremNode = premNode.next;\n\t\t\t} else if (i == m - 1) {//这样才方便后续reverse \n\t\t\t\t\t\t\t\t\t//initial: 1 ->  2  -> 3 ->  4 -> 5 -> NULL, m = 2 and n = 4， final：1->4->3->2->5->NULL.\n\t\t\t\t\t\t\t\t\t        //preM mNode nNode\n\t\t\t\tmNode = premNode.next;\n\t\t\t\tnNode = mNode.next;\n\t\t\t} else {\n\t\t\t\tmNode.next = nNode.next;\n\t\t\t\tnNode.next = premNode.next;\n\t\t\t\tpremNode.next = nNode;\n\t\t\t\tnNode = mNode.next;\n\t\t\t}\n\t\t}\n\n\t\n\t1.3 按照一组k个翻转结点， 比如 1 2 3 4 5 6 7 8 9 ,k = 3 就是每3个节点一组reverse， 3 2 1 6 5 4 9 8 7\n\t\tpublic ListNode reverseKGroup(ListNode head, int k) {\n\t        if (head == null || k == 1) {\n\t            return head;\n\t        }\n\t        ListNode newhead = new ListNode(0);\n\t        newhead.next = head;\n\t        ListNode cur = head;\n\t        ListNode pre = newhead;\n\t        int count = 0;\n\t        while (cur != null) {\n\t            count++;\n\t            ListNode next = cur.next;\n\t            if (count == k) {\n\t                pre = reverse(pre, next);\n\t                count = 0;\n\t            }\n\t            cur = next;\n\t        }\n\t        return newhead.next;\n\t    }\n\t    //关键部分，pre是要开始reverse的点的前一个点， next是范围内最后一个点的next点，last是翻转以后最后面的点\n\t    public ListNode reverse(ListNode pre, ListNode next) {\n\t    \t//\n\t        ListNode last = pre.next;\n\t        ListNode cur = last.next;\n\t        while (cur != next) {\n\t            last.next = cur.next;\n\t            cur.next = pre.next;\n\t            pre.next = cur;\n\t            cur = last.next;\n\t        }\n\t        return last;//正好 返回给下一次reverse的 rpe\n\t    }\n\t1.4 将所有的结点两两swap，比如 1-2-3-4 返回 4-3-2-1\n\t\tpublic class Solution {\n\t\t    public ListNode swapPairs(ListNode head) {\n\t\t        ListNode newhead = new ListNode(0);\n\t\t        newhead.next = head;\n\t\t        ListNode cur = newhead;\n\t\t        while (cur.next != null && cur.next.next != null) {\n\t\t            cur.next = swap(cur.next, cur.next.next);\n\t\t            cur = cur.next.next;\n\t\t        }\n\t\t        return newhead.next;\n\t\t    }\n\t\t    public ListNode swap(ListNode l1, ListNode l2) {\n\t\t        l1.next = l2.next;\n\t\t        l2.next = l1;\n\t\t        return l2;\n\t    }\n\t1.5 反转第二段链表\n\t\tpublic class solution {\n\t\t\tpublic static ListNode reverseSecondHalfList(ListNode head) {\n\t\t\t\tif (head == null || head.next == null)\t\n\t\t\t\t\treturn head;\n\t\t\t\tListNode fast = head;\n\t\t\t\tListNode slow = head;\n\t\t\t\twhile (fast.next != null && fast.next.next != null) {\n\t\t\t\t\tfast = fast.next.next;\n\t\t\t\t\tslow = slow.next;\n\t\t\t\t}\n\t\t\t\tListNode pre = slow.next;\n\t\t\t\tListNode cur = pre.next;\n\t\t\t\twhile (cur != null) {\n\t\t\t\t\tpre.next = cur.next;\n\t\t\t\t\tcur.next = slow.next;\n\t\t\t\t\tslow.next = cur;\n\t\t\t\t\tcur = pre.next;\n\t\t\t\t}\n\t\t\t\treturn head;\n\t\t\t}\n\t\t}\n\t}\n\t1.6 Rotate List //Given a list, rotate the list to the right by k places, where k is non-negative.\n\t\t// For example:\n\t\t// \tGiven  1->2->3->4->5->NULL and k = 2,\n\t\t// \treturn 4->5->1->2->3->NULL.\n\t\tpublic class Solution {\n\t\t    public ListNode rotateRight(ListNode head, int k) {\n\t\t        if (head == null || head.next == null) {\n\t\t            return head;\n\t\t        }\n\t\t        ListNode dummy = new ListNode(0);\n\t\t        dummy.next = head;\n\t\t        ListNode fast = dummy;\n\t\t        ListNode slow = dummy;\n\t\t        int len = 0;\n\t\t        while (fast.next != null) {\n\t\t            fast = fast.next;\n\t\t            len++;\n\t\t        }\n\t\t        for (int i = 0; i < len - k % len; i++) {\n\t\t            slow = slow.next;\n\t\t        }\n\t\t        fast.next = dummy.next;\n\t\t        dummy.next = slow.next;\n\t\t        slow.next = null;\n\t\t        return dummy.next;\n\t\t    }\n\t\t}\n\n2. Double Pointer Method\n\t2.1 Find Median\n\t   \tListNode slow = head;\n\t   \tListNode fast = head;\n\t   \twhile (fast.next != null && fast.next.next != null) {\n\t\t   \tfast = fast.next.next;\n\t\t   \tslow = slow.next;\n\t    }\n\t    链表为奇数时slow就是median，链表为偶数时,\n\t2.2 Find The Last Nth Nodepublic ListNode \n\t\tpublic ListNode removeNthFromEnd(ListNode head, int n) {\n\t\t\tListNode fast = head;\n\t\t\tListNode slow = head;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfast = fast.next;\n\t\t\t//移除头结点的情况\n\t\t\tif (fast == null)\n\t\t\t\thead = head.next;\n\t\t\t\treturn head;\n\t\t\twhile (fast.next != null) {\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next;\n\t\t\t}\n\t\t\tslow.next = slow.next.next;\n\t\t\treturn head;\n\t\t}\n\t2.3 Linked List CycleI\n\t\t设置slow = slow.next，fast = fast.next.next，只要相遇就是有cycle否则没有\n\t\tpublic class FindLoopsInLinkedList {\n\t\t\tpublic boolean hasCycle(ListNode head) {\n\t\t\t\tif (head == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tListNode slow = head;\n\t\t\t\tListNode fast = head;\n\t\t\t\twhile (fast != null && fast.next != null) {\n\t\t\t\t\tslow = slow.next;\n\t\t\t\t\tfast = fast.next.next;\n\t\t\t\t\tif (slow == fast) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\t\n\t\t}\n\n\t2.4 Linked List CycleII\n\t\tstep1: fast走两步，slow走一步，\n\t\tstep2: 第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b\n\t\t\t\ta:头结点到环入口的距离\n\t\t\t\tb:slow在环里走的距离\n\t\t\t\tc:环总距离减去b\n\t\tstep3: 2(a + b) = a + b + c + b   ===> a = c，\n\t\tstep4: 因此slow和fast相遇后，将slow指向头结点，slow 和fast 分别继续走，第二次相遇时的点就是环入口\n\t\tpublic ListNode detectCycleStartPosition(ListNode head) {  \n\t\t \tListNode slow = head;\n\t\t \tListNode fast = head;\n\t\t \twhile (fast != null && fast.next != null) {\n\t\t \t\tfast = fast.next.next;\n\t\t \t\tslow = slow.next;\n\t\t \t\tif (fast == slow) {\n\t\t \t\t\tslow = head;\n\t\t \t\t\twhile (fast != slow) {\n\t\t \t\t\t\tfast = fast.next;\n\t\t \t\t\t\tslow = slow.next;\n\t\t \t\t\t}\n\t\t \t\t\treturn slow;\n\t\t \t\t}\n\t\t \t}\n\t\t \treturn null;\n\t\t}\n\n    2.5 Reorder List  //Given {1,2,3,4}, reorder it to {1,4,2,3}.\n\t\tpublic class Solution {\n\t\t    public void reorderList(ListNode head) {\n\t\t        if (head == null || head.next == null) {\n\t\t            return;\n\t\t        }\n\t\t        ListNode slow = head;\n\t\t        ListNode fast = head;\n\t\t        while (fast.next != null && fast.next.next != null) {\n\t\t            fast = fast.next.next;\n\t\t            slow = slow.next;\n\t\t        }\n\t\t        ListNode secondHalf = slow.next;\n\t\t        slow.next = null;\n\t\t        secondHalf = reverse(secondHalf);// Using 1.1 reverse\n\t\t        merge(head, secondHalf);//Using 3.1 merge Method\n\t\t    }\n\t\t}\n\n\t2.6 Palindrome Linked List\n\t\tpublic class Solution {\n\t\t    public boolean isPalindrome(ListNode head) {\n\t\t        if (head == null || head.next == null) {\n\t\t            return true;\n\t\t        }\n\t\t        ListNode fast = head;\n\t\t        ListNode slow = head;\n\t\t        while (fast.next != null && fast.next.next != null) {\n\t\t            slow = slow.next;\n\t\t            fast = fast.next.next;\n\t\t        }\n\t\t        ListNode secondList = slow.next;\n\t\t        slow.next = null;\n\t\t        ListNode partTwo = reverse(secondList);//1.1 普通Reverse \n\t\t        ListNode partOne = head;\n\t\t        while (partTwo != null) {\n\t\t            if (partOne.val != partTwo.val) {\n\t\t                return false;\n\t\t            }\n\t\t            partOne = partOne.next;\n\t\t            partTwo = partTwo.next;\n\t\t        }\n\t\t        return true;\n\t\t    }\n\t\t}\n\n3. Merge Two List\n\t3.1 Just Merge (without order)\n\t\tpublic void merge(ListNode l1, ListNode l2) {\n\t\t\twhile (l1 != null && l2 != null) {\n\t\t\t\tListNode temp1 = l1.next;\n\t\t\t\tListNode temp2 = l2.next;\n\t\t\t\tl1.next = l2;\n\t\t\t\tl2.next = temp1;\n\t\t\t\tl1 = temp1;\n\t\t\t\tl2 = temp2;\n\t\t\t}\n\t\t}\n\n\t3.2 Merge With Order\n\t\tpublic ListNode merge(ListNode l1, ListNode l2) {\n\t        if (l1 == null) {\n\t            return l2;\n\t        }\n\t        if (l2 == null) {\n\t            return l1;\n\t        }\n\t        ListNode dummy = new ListNode(0);\n\t        ListNode l3 = dummy;\n\t        while (l1 != null && l2 != null) {\n\t            if (l1.val < l2.val) {\n\t                l3.next = l1;\n\t                l1 = l1.next;\n\t            } else {\n\t                l3.next = l2;\n\t                l2 = l2.next;\n\t            }\n\t            l3 = l3.next;\n\t        }\n\t        if (l1 != null) {\n\t            l3.next = l1;\n\t        }\n\t        if (l2 != null) {\n\t            l3.next = l2;\n\t        }\n\t        return dummy.next;\n\t    }\n4. Find Length Of Linked List\n\t4.1\tint len = 0; \n\t\tListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n\t\twhile (fast.next != null) {\n\t\t \tfast = fast.next;\n\t\t \tlen++;\n\t\t}//上面的这种方法求出来 pointer是指向最后一个结点，因此我们还可以借由fast.next 执行一些比如反转的操作\n\n    4.2 while (fast != null) {\n    \t\tfast = fast.next;\n    \t\tlen++\n    \t}//这种方法求出来 fast最后会是最后一个结点的next，也就是null，所以fast结点就废了，没有用处\n\n5. LinkedList Sort\n\t5.1 Sort One LinkedList(Merge Sort)\n\t\tpublic ListNode sortList(ListNode head) {\n\t\t\t//How it works?\n\t\t\t/*\n\t\t\t\t1. Find the median so that we can separate the List to two part\n\t\t\t\t2. recursively seperate the list and merge then\n\t\t\t*/\n\t        if (head == null || head.next == null) {\n\t            return head;\n\t        }\n\t        ListNode slow = head;\n\t        ListNode fast = head;\n\t        ListNode firsthalf = head;\n\t        //find median method\n\t        while (fast.next != null && fast.next.next != null) {\n\t            slow = slow.next;\n\t            fast = fast.next.next;\n\t        }\n\t        ListNode secondhalf = slow.next;\n\t        slow.next = null;\n\t        ListNode leftlists = sortList(firsthalf);\n\t        ListNode rightlists = sortList(secondhalf);\n\t        return merger(leftlists, rightlists);\n\t    }\n\t5.2 Sort K Sorted LinkedlList(Merge Sort)\n\t    public ListNode mergeSort(ListNode[] lists, int start, int end) {\n\t        if (start >= end) {\n\t            return lists[start];\n\t        }\n\t        int mid = start + (end - start) / 2;\n\t        ListNode leftlist = mergeSort(lists, start, mid);\n\t        ListNode rightlist = mergeSort(lists, mid + 1, end);\n\t        return merge(leftlist, rightlist);\n    \t}\n\n    5.3 Insertion Sort\n    \tpublic ListNode insertionSortList(ListNode head) {\n\t        if (head == null || head.next == null) {\n\t            return head;\n\t        }\n\t        //一定纳闷为什么这里dummy没有 dummy.next = head吧？\n\t        //因为在下面会将dummy赋值给pre，并且后面还有pre.next = cur， 因此在第一次while循环时就已将将dummy.next = cur!\n\t        ListNode dummy = new ListNode(-1);\n\t        ListNode cur = head;\n\t        while (cur != null) {\n\t            ListNode next = cur.next;\n\t            ListNode pre = dummy;\n\t            while (pre.next != null && pre.next.val < cur.val) { // 将cur 插入到 pre 以及 pre.next 之间， pre < cur < pre.next\n\t                pre = pre.next;\n\t            }\n\t            cur.next = pre.next;\n\t            pre.next = cur;\n\t            cur = next;\n\t        }\n        \treturn dummy.next;\n    \t}\n    5.4 Partition List  //Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\n\t\t\t  \t\t\t//Given 1->4->3->2->5->2 and x = 3,\n\t\t\t\t\t    //return 1->2->2->4->3->5.\n\t\tpublic class Solution {\n\t\t    public ListNode partition(ListNode head, int x) {\n\t\t        if (head == null || head.next == null) {\n\t\t            return head;\n\t\t        }\n\t\t        ListNode small = new ListNode(-1);\n\t\t        ListNode smallHead = small;\n\t\t        ListNode larger = new ListNode(-1);\n\t\t        ListNode largerHead = larger;\n\t\t        while (head != null) {\n\t\t            if (head.val < x) {\n\t\t                small.next = head;\n\t\t                small = small.next;\n\t\t            } else {\n\t\t                larger.next = head;\n\t\t                larger = larger.next;\n\t\t            }\n\t\t            head = head.next;\n\t\t        }\n\t\t        larger.next = null;\n\t\t        small.next = largerHead.next;\n\t\t        return smallHead.next;\n\t\t    }\n\t\t}\n\n\n6. Remove Elements\n\t6.1  在有序的链表中移除重复结点使得每个结点只出现一次\n\tpublic ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode cur = head;\n        while (cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n\n    6.2 在有序的链表中移除所有的重复结点（全部清空）\n    public static ListNode deleteDuplicates(ListNode head) {\n        // write your code here\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if(cur.next.val == cur.next.next.val) {\n                int val = cur.next.val;\n                while (cur.next != null && cur.next.val == val) {\n                    cur.next = cur.next.next;\n                }\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n\n    6.3 删除所有node.val == val的结点\n    public ListNode removeElements(ListNode head, int val) {\n        // Write your code here\n        if (head == null) {\n            return head;\n        }\n        ListNode newhead = new ListNode(0);\n        newhead.next = head;\n        ListNode cur = newhead;\n        while (cur.next != null) {\n            if (cur.next.val == val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return newhead.next;\n    }\n\n    6.4 移除从后数起第n个结点\n    \tpublic ListNode removeNthFromEnd(ListNode head, int n) {\n\t\t\tListNode fast = head;\n\t\t\tListNode slow = head;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfast = fast.next;\n\t\t\t//移除头结点的情况\n\t\t\tif (fast == null)\n\t\t\t\thead = head.next;\n\t\t\t\treturn head;\n\t\t\twhile (fast.next != null) {\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next;\n\t\t\t}\n\t\t\tslow.next = slow.next.next;\n\t\t\treturn head;\n\t\t}\n\n7. LinkedList Insert, Delete Operation\n\t7.1 Insert Node In A Loop Linked List\n\t\tpublic class LinkedListInsert {\n\t\t\tpublic ListNode Solution(ListNode head, int val) {\n\t\t\t\tif (head == null) {\n\t\t\t\t\tListNode rvalue = new ListNode(val);\n\t\t\t\t\trvalue.next = rvalue;\n\t\t\t\t\treturn rvalue;\n\t\t\t\t}\n\t\t\t\tListNode cur = head;\n\t\t\t\tdo {\n\t\t\t\t\tif (val <= cur.next.val && val >= cur.val)\tbreak;\n\t\t\t\t\tif (cur.val > cur.next.val && (val < cur.next.val || val > cur.val))\tbreak;\n\t\t\t\t\tcur = cur.next;\n\t\t\t\t} while (cur != head);\n\t\t\t\tListNode newNode = new ListNode(val);\n\t\t\t\tnewNode.next = cur.next;\n\t\t\t\tcur.next = newNode;\n\t\t\t\treturn newNode;\n\t\t\t}\n\t\t}\n\t7.2 Delete Node In A Linked List\n\tpublic class Solution {\n\t    public void deleteNode(ListNode node) {\n\t        if (node == null || node.next == null) {\n\t            return;\n\t        }\n\t        node.val = node.next.val;\n\t        node.next = node.next.next;\n\t    }\n\t}\n\n8. Math Operation In LinkedList\n\t8.1 Add Two Numbers\n\t\tInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n\t\tOutput: 7 -> 0 -> 8\n\t\tpublic class Solution {\n\t\t    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\t\t        if (l1 == null) {\n\t\t            return l2;\n\t\t        }\n\t\t        if (l2 == null) {\n\t\t            return l1;\n\t\t        }\n\t\t        ListNode newhead = new ListNode(-1);\n\t\t        ListNode l3 = newhead;\n\t\t        int sum = 0;\n\t\t        while (l1 != null || l2 != null) {\n\t\t            if (l1 != null) {\n\t\t                sum += l1.val;\n\t\t                l1 = l1.next;\n\t\t            }\n\t\t            if (l2 != null) {\n\t\t                sum += l2.val;\n\t\t                l2 = l2.next;\n\t\t            }\n\t\t            l3.next = new ListNode(sum % 10);\n\t\t            sum = sum / 10;\n\t\t            l3 = l3.next;\n\t\t        }\n\t\t        if (sum == 1) {\n\t\t            l3.next = new ListNode(1);\n\t\t        }\n\t\t        return newhead.next;\n\t\t    }\n\t\t}\n\n9. Two LinkedList Operation\n\t9.1 Intersection Of Two Linked Lists\n\t\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\t    \t/*\n\t            1.分别算出A 和 B链表的长度\n\t            2. 比较A 和B 哪个长，哪个长就走 长 - 短的 路程\n\t            3. 短的从开头开始走， 长的从长减短的位置开始走\n\t            4. 此时遇到的\n\t        */\n\t        int lenA = 0;\n\t    \tint lenB = 0;\n\t    \tListNode h1 = headA;\n\t    \tListNode h2 = headB;\n\t    \twhile (h1 != null) {\n\t    \t\tlenA++;\n\t    \t\th1 = h1.next;\n\t    \t}\n\t    \twhile (h2 != null) {\n\t    \t\tlenB++;\n\t    \t\th2 = h2.next;\n\t    \t}\n\t    \th1 = headA;\n\t    \th2 = headB;\n\t    \tif (lenA > lenB) {\n\t    \t\tfor (int i = 0; i < lenA - lenB; i++) {\n\t    \t\t\th1 = h1.next;\n\t    \t\t}\n\t    \t} else { \n\t    \t\tfor (int i = 0; i < lenB - lenA; i++) {\n\t    \t\t\th2 = h2.next;\n\t    \t\t}\n\t    \t}\n\t    \twhile (h1 != null && h2 != null) {\n\t    \t\tif (h1.val == h2.val) {\n\t    \t\t\treturn h1;\n\t    \t\t} else {\n\t    \t\t\th1 = h1.next;\n\t    \t\t\th2 = h2.next;\n\t    \t\t}\n\n\t    \t}\n\t    \treturn null;\n\t    }\n\t9.2 Copy List With Random Pointer\n\tpublic class Solution {\n\t    public RandomListNode copyRandomList(RandomListNode head) {\n\t        if (head == null) {\n\t            return head;\n\t        }\n\t        //copy every ListNode\n\t        RandomListNode oldNode = head;\n\t        while (oldNode != null) {\n\t            RandomListNode copyNode = new RandomListNode(oldNode.label);\n\t            copyNode.next = oldNode.next;\n\t            oldNode.next = copyNode;\n\t            oldNode = copyNode.next;\n\t        }\n\t        //set the random value\n\t        oldNode = head;\n\t        while (oldNode != null && oldNode.next != null) {\n\t            if (oldNode.random != null) {\n\t                oldNode.next.random =  oldNode.random.next;\n\t            }\n\t            oldNode = oldNode.next.next;\n\t        }\n\t        //divide the ListNode\n\t        oldNode = head;\n\t        RandomListNode newhead = head.next;\n\t        RandomListNode copyList = newhead;\n\t        while (copyList != null) {\n\t            oldNode.next = copyList.next;\n\t            oldNode = oldNode.next;\n\t            if (copyList.next != null) {\n\t                copyList.next = copyList.next.next;\n\t            }\n\t            copyList = copyList.next;\n\t        }\n\t        return newhead;\n\t    }\n\t}\n\n\n\n\n"
    }
  ]
}