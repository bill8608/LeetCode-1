{
  "title": "Design",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "/*\n\tDesign \n*/\n\n\n\n/*\n\tJava中的Iterator功能比较简单，并且只能单向移动：\n　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n　　(2) 使用next()获得序列中的下一个元素。\n　　(3) 使用hasNext()检查序列中是否还有元素。\n　　(4) 使用remove()将迭代器新返回的元素删除。\n\n\t\n\tlist l = new ArrayList();\n\tl.add(\"aa\");\n\tl.add(\"bb\");\n\tl.add(\"cc\");\n\tfor (Iterator iter = l.iterator(); iter.hasNext();) {\n\t  \tString str = (String)iter.next();\n\t \tSystem.out.println(str);\n\t}\n\t/*迭代器用于while循环\n\tIterator iter = l.iterator();\n\twhile(iter.hasNext()){\n\t\tString str = (String) iter.next();\n\t \tSystem.out.println(str);\n\t}\n*/\n\n1. Iterator Problem\n\t\t1.1 List Iterator\n\t\t\t1.1.1 Zigzag Iterator\n\t\t\t\t/*\n\t\t\t\t\tFor example, given two 1d vectors:\n\t\t\t\t\tv1 = [1, 2]\n\t\t\t\t\tv2 = [3, 4, 5, 6]\n\t\t\t\t\tBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\n\n\t\t\t\t\tThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example, given the following input:\n\n\t\t\t\t\t[1,2,3]\n\t\t\t\t\t[4,5,6,7]\n\t\t\t\t\t[8,9]\n\t\t\t\t\tIt should return [1,4,8,2,5,9,3,6,7].\n\t\t\t\t*/\n\t\t\t\t/**\n\t\t\t\t * Your ZigzagIterator object will be instantiated and called as such:\n\t\t\t\t * ZigzagIterator i = new ZigzagIterator(v1, v2);\n\t\t\t\t * while (i.hasNext()) v[f()] = i.next();\n\t\t\t\t */\n\t\t\t\t//Simple Version\n\t\t\t\tpublic class ZigzagIterator {\n\t\t\t\t    private Iterator<Integer> i1, i2, temp;\n\t\t\t\t    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n\t\t\t\t        i1 = v1.iterator();\n\t\t\t\t        i2 = v2.iterator();\n\t\t\t\t    }\n\t\t\t\t    public int next() {\n\t\t\t\t        if (i1.hasNext()) {\n\t\t\t\t            temp = i1;\n\t\t\t\t            i1 = i2;\n\t\t\t\t            i2 = temp;\n\t\t\t\t        }\n\t\t\t\t        return i2.next();\n\t\t\t\t    }\n\t\t\t\t    public boolean hasNext() {\n\t\t\t\t        return i1.hasNext() || i2.hasNext();\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t\t//Can be used to k-D vector\n\t\t\t\tpublic class ZigzagIterator {\n\t\t\t\t    private LinkedList<Iterator> queue;\n\t\t\t\t    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n\t\t\t\t        queue = new LinkedList<Iterator>();\n\t\t\t\t        if (!v1.isEmpty()) {\n\t\t\t\t            queue.offer(v1.iterator());\n\t\t\t\t        }\n\t\t\t\t        if (!v2.isEmpty()) {\n\t\t\t\t            queue.offer(v2.iterator());\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public int next() {\n\t\t\t\t        Iterator head = queue.poll();// using queue, every time poll the head iterator and get the next() value, if hasNext(),and offer to the queue again\n\t\t\t\t        int res = (Integer)head.next();\n\t\t\t\t        if (head.hasNext()) {\n\t\t\t\t            queue.offer(head);\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public boolean hasNext() {\n\t\t\t\t        return !queue.isEmpty();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.1.2 Flatten 2D Vector\n\t\t\t\t/*\n\t\t\t\t\tGiven 2d vector =\n\t\t\t\t\t[\n\t\t\t\t\t  [1,2],\n\t\t\t\t\t  [3],\n\t\t\t\t\t  [4,5,6]\n\t\t\t\t\t]\n\t\t\t\t\tBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].\n\t\t\t\t*/\n\t\t\t\t/*\n\t\t\t\t\t思路： 1. \n\t\t\t\t*/\n\t\t\t\tpublic class Vector2D {\n\t\t\t\t    Iterator<List<Integer>> listIter;\n\t\t\t\t    Iterator<Integer> numIter;\n\t\t\t\t    public Vector2D(List<List<Integer>> vec2d) {\n\t\t\t\t        listIter = vec2d.iterator();\n\t\t\t\t    }\n\t\t\t\t    public int next() {\n\t\t\t\t        hasNext();\n\t\t\t\t        return numIter.next();\n\t\t\t\t    }\n\t\t\t\t    public boolean hasNext() {\n\t\t\t\t        while ((numIter == null || !numIter.hasNext()) && listIter.hasNext()) {\n\t\t\t\t            numIter = listIter.next().iterator();\n\t\t\t\t        }\n\t\t\t\t        return numIter != null && numIter.hasNext();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t1.2 Iterator Interface\n\t\t\t\t// Java Iterator interface reference:\n\t\t\t\t// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\n\t\t\t\tclass PeekingIterator implements Iterator<Integer> {\n\t\t\t\t    Integer nextVal;\n\t\t\t\t    Iterator<Integer> iter ;\n\t\t\t\t\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t\t\t\t\t    // initialize any member here.\n\t\t\t\t\t    iter = iterator;\n\t\t\t\t\t    if (iter.hasNext()) {\n\t\t\t\t\t         nextVal = iter.next();\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    // Returns the next element in the iteration without advancing the iterator.\n\t\t\t\t\tpublic Integer peek() {\n\t\t\t\t        return nextVal;\n\t\t\t\t\t}\n\t\t\t\t\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t\t\t\t\t// Override them if needed.\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Integer next() {\n\t\t\t\t\t    Integer res = nextVal;\n\t\t\t\t\t    nextVal = iter.hasNext() ? iter.next() : null;\n\t\t\t\t\t    return res;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t    return nextVal != null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t1.3 Binary Search Tree Iterator\n\t\t\t/*\n\t\t\t\tNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\n\t\t\t*/\n\t\t\tpublic class BSTIterator {\n\t\t\t\tprivate Stack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\t\tpublic BSTIterator(TreeNode root) {\n\t\t\t\t\tpushAll(root);\n\t\t\t\t}\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn !stack.isEmpty();\n\t\t\t\t}\n\t\t\t\tpublic int next() {\n\t\t\t\t\tTreeNode curNode = stack.pop();\n\t\t\t\t\tpushAll(curNode.right);\n\t\t\t\t\treturn curNode.val;\n\t\t\t\t}\n\t\t\t\tprivate void pushAll(TreeNode node) {\n\t\t\t\t\twhile (node != null) {\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t\tnode = node.left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n2. Stack And Queue Design\n\t\t2.1 Implement Queue Using Stacks\n\t\t\t/*\n\t\t\t    O(1) amortized for each operation\n\t\t\t    Each element only ever gets moved like that once, though, and only after we already spent time pushing it, \n\t\t\t    so the overall amortized cost for each operation is O(1).\n\t\t\t*/\n\t\t\tclass MyQueue {\n\t\t\t    Stack<Integer> input = new Stack();\n\t\t\t    Stack<Integer> output = new Stack();\n\t\t\t    // Push element x to the back of queue.\n\t\t\t    public void push(int x) {\n\t\t\t        input.push(x);\n\t\t\t    }\n\n\t\t\t    // Removes the element from in front of queue.\n\t\t\t    public void pop() {\n\t\t\t        peek();\n\t\t\t        output.pop();\n\t\t\t    }\n\n\t\t\t    // Get the front element.\n\t\t\t    public int peek() {\n\t\t\t        if (output.empty()) {\n\t\t\t            while (!input.empty()) {\n\t\t\t                output.push(input.pop());\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return output.peek();\n\t\t\t    }\n\t\t\t    // Return whether the queue is empty.\n\t\t\t    public boolean empty() {\n\t\t\t        return input.isEmpty() && output.isEmpty();\n\t\t\t    }\n\t\t\t}\n\t\t2.2 Implement Stack Using Queues\n\t\t\tclass MyStack {\n\t\t\t    // Push element x onto stack.\n\t\t\t    Queue<Integer> queue;\n\t\t\t    public MyStack() {\n\t\t\t        queue = new LinkedList<>();\n\t\t\t    }\n\t\t\t    public void push(int x) {\n\t\t\t        queue.offer(x);\n\t\t\t        for (int i = 0; i < queue.size() - 1; i++) {\n\t\t\t            queue.offer(queue.poll());\n\t\t\t        }\n\t\t\t    }\n\t\t\t    // Removes the element on top of the stack.\n\t\t\t    public void pop() {\n\t\t\t        queue.poll();\n\t\t\t    }\n\t\t\t    // Get the top element.\n\t\t\t    public int top() {\n\t\t\t        return queue.peek();\n\t\t\t    }\n\t\t\t    // Return whether the stack is empty.\n\t\t\t    public boolean empty() {\n\t\t\t        return queue.isEmpty();\n\t\t\t    }\n\t\t\t}\n\t\t2.3 Min Stack\n\t\t\t//Solution1: Two Stack\n\t\t\t\tclass MinStack {\n\t\t\t\t    Stack<Integer> stack = new Stack<>();\n\t\t\t\t    Stack<Integer> minStack = new Stack<>();\n\t\t\t\t    public void push(int x) {\n\t\t\t\t        stack.push(x);\n\t\t\t\t        if (minStack.isEmpty() || minStack.peek() >= x) {\n\t\t\t\t            minStack.push(x);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public void pop() {\n\t\t\t\t        int peek = stack.pop();\n\t\t\t\t        if (minStack.peek() == peek) {\n\t\t\t\t            minStack.pop();\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public int top() {\n\t\t\t\t        return stack.peek();\n\t\t\t\t    }\n\t\t\t\t    public int getMin() {\n\t\t\t\t        return minStack.peek();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t//Solution2: One Stack, Store the value and the min's diff\n\t\t\t\tclass MinStack {\n\t\t\t\t    int min;\n\t\t\t\t    Stack<Integer> stack;\n\t\t\t\t    public MinStack () {\n\t\t\t\t        stack = new Stack<>();\n\t\t\t\t    }\n\t\t\t\t    public void push(int x) {\n\t\t\t\t        if (stack.isEmpty()) {\n\t\t\t\t            stack.push(0);\n\t\t\t\t            min = x;\n\t\t\t\t        } else {\n\t\t\t\t            stack.push(x - min);\n\t\t\t\t            if (x < min) {\n\t\t\t\t                min = x;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public void pop() {\n\t\t\t\t        if (stack.isEmpty()) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        int pop = stack.pop();\n\t\t\t\t        if (pop < 0) {\n\t\t\t\t            min = min - pop;\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public int top() {\n\t\t\t\t        int top = stack.peek();\n\t\t\t\t        if (top > 0) {\n\t\t\t\t            return top + min;\n\t\t\t\t        } else {\n\t\t\t\t            return min;\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public int getMin() {\n\t\t\t\t        return min;\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\n3. String, Word, Other Data Structure Design\n\t\t3.1 Shortest Word Distance II \n\t\t\t/*\n\t\t\t\tAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\t\t\t\tGiven word1 = “coding”, word2 = “practice”, return 3.\n\t\t\t\tGiven word1 = \"makes\", word2 = \"coding\", return 1.\n\t\t\t\tNote:\n\t\t\t\tYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\n\t\t\t*/\n\t\t\tpublic class WordDistance {\n\t\t\t    private HashMap<String, ArrayList<Integer>> map;\n\t\t\t    public WordDistance(String[] words) {\n\t\t\t        map = new HashMap<String, ArrayList<Integer>>();\n\t\t\t        for (int i = 0; i < words.length; i++) {\n\t\t\t            if (!map.containsKey(words[i])) {\n\t\t\t                map.put(words[i], new ArrayList<>());\n\t\t\t            }\n\t\t\t            map.get(words[i]).add(i);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    public int shortest(String word1, String word2) {\n\t\t\t        List<Integer> list1 = map.get(word1);\n\t\t\t        List<Integer> list2 = map.get(word2);\n\t\t\t        int minLen = Integer.MAX_VALUE;\n\t\t\t        int i = 0;\n\t\t\t        int j = 0;\n\t\t\t        while (i < list1.size() && j < list2.size()) {\n\t\t\t            minLen = Math.min(minLen, Math.abs(list1.get(i) - list2.get(j)));\n\t\t\t            if (list1.get(i) > list2.get(j)) {\n\t\t\t                j++;\n\t\t\t            } else {\n\t\t\t                i++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return minLen;\n\t\t\t    }\n\t\t\t}\n\n\t\t3.2 Two Sum III - Data Structure Design\n\t\t\tpublic class TwoSum {\n\t\t\t    // Add the number to an internal data structure.\n\t\t\t    HashMap<Integer, Integer> map = new HashMap<>();\n\t\t\t\tpublic void add(int number) {\n\t\t\t\t    map.put(number, map.containsKey(number) ? map.get(number) + 1 : 1);\n\t\t\t\t}\n\t\t\t    // Find if there exists any pair of numbers which sum is equal to the value.\n\t\t\t\tpublic boolean find(int value) {\n\t\t\t\t    for (int key : map.keySet()) {\n\t\t\t\t        if (map.containsKey(value - key)) {\n\t\t\t\t            if (map.get(value - key) >= 2 || (map.get(value - key) == 1 && key != value - key)) {\n\t\t\t\t                return true;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    return false;\n\t\t\t\t}\n\t\t\t}\n\t\t3.3 Find Median From Data Stream\n\t\t\tclass MedianFinder {\n\t\t\t    // Adds a number into the data structure.\n\t\t\t    PriorityQueue<Integer> min = new PriorityQueue<>();\n\t\t\t    PriorityQueue<Integer> max = new PriorityQueue<>(1000, Collections.reverseOrder());\n\t\t\t    public void addNum(int num) {\n\t\t\t        max.offer(num);\n\t\t\t        min.offer(max.poll());\n\t\t\t        if (max.size() < min.size()) {\n\t\t\t            max.offer(min.poll());\n\t\t\t        }\n\t\t\t    }\n\t\t\t    // Returns the median of current data stream\n\t\t\t    public double findMedian() {\n\t\t\t        if (max.size() == min.size()) {\n\t\t\t            return (max.peek() + min.peek()) / 2.0;\n\t\t\t        } else {\n\t\t\t            return max.peek();\n\t\t\t        }\n\t\t\t    }\n\t\t\t};\n\n\t\t\t"
    }
  ]
}