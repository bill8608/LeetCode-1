{
  "title": "Backtracking",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "1.First Part: Introduction Of Backtracking Algorithm\n\t1.0 Overview\n\t\tBacktracking is a systematic way to iterate through all the possible configurations of a search space. \n\t\tThese configurations may represent as:\n\t\t\tPermutations（排列）: all possible arrangements of objects.\n\t\t\tSubsets（子集）: all possible ways of building a collection of them\n\t\t\tCombinations(组合）: a combination is a way of selecting items from a collection, such that the order of selection does not matter.\n\t\tOther situations may demand enumerating all spanning trees of a graph, all paths between two vertices, or all possible ways to partition vertices into color classes.\n\t\tWhat these problems have in common is that we must generate each one possible configuration exactly once.\n\n\n\t\tBacktrack-DFS(A, k)//Pseudocode\n\t\t\tif A = (a1, a2, ..., ak) is a solution, report it. \n\t\t\telse\n\t\t\t\tk = k + 1 \n\t\t\t\tcompute Sk \n\t\t\t\twhile Sk != ∅ do\n\t\t\t\t\tak = an element in Sk \n\t\t\t\t\tSk = Sk − ak \n\t\t\t\t\tBacktrack-DFS(A, k)\n    1.1 Q & A\n\t\t1.1.1 Why use DFS for Backtracking problem ?\n\t\t\t\tAlthough a breadth-first search could also be used to enumerate solutions, a depth-first search is greatly preferred because it uses much less space. \n\t\t\t\tThe current state of a search is completely represented by the path from the root to the current search depth-first node. \n\t\t\t\tThis requires space proportional to the height of the tree.\n\n\t\t1.1.2 Why we dont use BFS for Backtracking problem ?\n\t\t\t\tIn breadth-first search, the queue stores all the nodes at the current level, which is proportional to the width of the search tree. \n\t\t\t\tFor most interesting problems, the width of the tree grows exponentially in its height.\n\n\t\t1.1.3 Why Backtracking works and how?\n\t\t\t\tBacktracking ensures correctness by enumerating all possibilities. \n\t\t\t   It ensures efficiency by never visiting a state more than once.\n\n\t1.2 Implementation(From Skiena The Algorithm Desigen Manual):\n\t\t//The honest working backtrack code is given below:\n\n\t\tpublic class Solution {\n\t\t\tprivate boolean finished = false;/* found all solutions yet? */\n\n\t\t\tpublic void backtrack(int a[], int k, data input) {\n\t\t\t\tint c[MAXCANDIDATES]; /* candidates for next position */\n\t\t\t\tint ncandidates; /* next position candidate count */\n\t\t\t\tint i; /* counter */\n\t\t\t\t\n\t\t\t\tif (is_a_solution(a, k, input)) {\n\t\t\t\t\tprocess_solution(a, k, input);\n\t\t\t\t} else {\n\t\t\t\t\tk = k + 1;\n\t\t\t\t\tconstruct_candidates(a, k, input, c, &ncandidates);\n\t\t\t\t\tfor (int i = 0; i < ncandidates; i++) {\n\t\t\t\t\t\ta[k] = c[i];\n\t\t\t\t\t\tmake_move(a, k, input);\n\t\t\t\t\t\tbacktrack(a, k, input);\n\t\t\t\t\t\tunmake_move(a, k, input);\n\t\t\t\t\t\tif (finished) {\n\t\t\t\t\t\t\treturn ;\n\t\t\t\t\t\t}/* terminate early */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t1.2.1 Backtracking Method Explain\n\t\t\t1.2.1 is_a_solution(a,k,input)\n\t\t\t\tThis Boolean function tests whether the first k elements of vector a from a complete solution for the given problem. \n\t\t\t\tThe last argument, input, allows us to pass general information into the routine. We can use it to specify n---the size of a target solution. \n\t\t\t\tThis makes sense when constructing permutations or subsets of n elements, but other data may be relevant when constructing variable-sized objects such as sequences of moves in a game.\n\t\t\t1.2.2 construct_candidates(a, k, input, c, ncandidates) \n\t\t\t\tThis routine fills an array c with the complete set of possible candidates for the kth position of a, given the contents of the first k − 1 positions. \n\t\t\t\tThe number of candidates returned in this array is denoted by ncandidates. Again, input may be used to pass auxiliary information.\n\t\t\t1.2.3 process solution(a,k,input)\n\t\t\t\tThis routine prints, counts, or however processes a complete solution once it is constructed.\n\t\t\t1.2.4 make_move(a, k, input) and unmake_move(a, k, input)\n\t\t\t\table us to modify a data structure in response to the latest move, as well as clean up this data structure if we decide to take back the move. \n\t\t\t\tSuch a data structure could be rebuilt from scratch from the solution vector a as needed, but this is inefficient when each move involves incremental changes that can easily be undone.\n\n\n\n\n\n\n2. Second Part: Problems Set\n\t\t1. Permutations 排列 //[1,2,3] have the following permutations:[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].\n\t\t\t1.1 Permutations I, II //Permutations II 只需要加入下面2行代码\n\t\t\t\t//Recursive, the key is boolean[] array!\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> permute(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (nums == null || nums.length == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        //Arrays.sort(nums); Permutations II\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        boolean[] visited = new boolean[nums.length];\n\t\t\t\t        helper(nums, res, item, visited);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(int[] nums, List<List<Integer>> res, List<Integer> item, boolean[] visited) {\n\t\t\t\t        if (item.size() == nums.length) {\n\t\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t\t        \t//if (i != 0 && nums[i] == nums[i - 1] && nums[i - 1] == false) Permutations II\n\t\t\t\t            if (visited[i] == false) {\n\t\t\t\t                visited[i] = true;\n\t\t\t\t                item.add(nums[i]);\n\t\t\t\t                helper(nums, res, item, visited);\n\t\t\t\t                item.remove(item.size() - 1);\n\t\t\t\t                visited[i] = false;\n\t\t\t\t            }\n\t\t\t\t           \n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic List<List<Integer>> permute(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\t\t\t        if (nums.length == 0 || nums == null) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        // Collections.sort(nums) //Permutations II\n\t\t\t\t        List<Integer> initList = new ArrayList<>();\n\t\t\t\t        initList.add(nums[0]);\n\t\t\t\t        res.add(initList);\t\t\t\t   \n\t\t\t\t        /*\t\n\t\t\t\t    \t\tif nums[] = {1, 2, 3}\n\t\t\t\t    \t\tAt first \t\t\t  : ans = { (1) }\n\t\t\t\t    \t\tAfter second for loop : ans = { (2, 1), (1, 2)}\n\t\t\t\t    \t\tFinaly:    \t\t\t  :\tans = { (3,2,1) (3,1,2) (2,3,1) (1,3,2) (2,1,3) (1,2,3)}\n\t\t\t\t    \t*/\n\t\t\t\t        for (int i = 1; i < nums.length; i++) { //遍历待插入元素\n\t\t\t\t            List<List<Integer>> tempRes = new ArrayList<>();\n\t\t\t\t            for (int j = 0; j <= i; j++) { //遍历插入位置\n\t\t\t\t                for (List<Integer> list : res) {//遍历res里的 list，取出来插入\n\t\t\t\t                    List<Integer> newList = new ArrayList<>(list);//这样是copy的用法，如果直接把newList = list,将会导致错误\n\t\t\t\t                    newList.add(j, nums[i]);\n\t\t\t\t                    // if (!tempRes.contains) {  //Permutations II \n\t\t\t\t                    // \ttempRes.add(newList);\n\t\t\t\t                    // }\n\t\t\t\t                    tempRes.add(newList);\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            res = tempRes;\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.2 Permutation Sequence \n\t\t\t\t/*\n\t\t\t\t\tThe logic is as follows: \n\t\t\t\t\t\t1. For n numbers, permutations can be divided into n groups with (n - 1)! elements in each group. \n\t\t\t\t\t\t2. Thus, k / (n - 1)! is the group index among the current n (to be) sorted groups\n\t\t\t\t\t\t3. and k % (n - 1)! is the sequence number k for next iteration.    \n\t\t\t\t*/\n\t\t\t\t/*\n\t\t\t\t\tExample:\n\t\t\t\t\t\t1. n = 4, k = 13;\n\t\t\t\t\t\t2. 将1~4加入list中， fact = 1 * 2 * 3 * 4 = 24;\n\t\t\t\t\t\t   fact /= n 是因为，在由1，2，3，4 组成的permutation如下所示：\n\t\t\t\t\t\t\t\t   \t\t\t\t1 + (permutations of 2, 3, 4) \n\t\t\t\t\t\t\t\t\t\t\t\t2 + (permutations of 1, 3, 4) \n\t\t\t\t\t\t\t\t\t\t\t\t3 + (permutations of 1, 2, 4) \n\t\t\t\t\t\t\t\t\t\t\t\t4 + (permutations of 1, 2, 3)，\n\t\t\t\t\t\t\t\t\t\t\t\t后面三位组成的permutation数量= fact / n = 24 / 4;\n\t\t\t\t\t\t\t\t\t\t\t\t我们只需要将 k / (fact / n) ,就可以得到第一位数字的序号。\n\t\t\t\t\t\t\t\t\t\t\t\t13 / (24 / 4) = 13 / 6 = 2, 也就是取3.\n\t\t\t\t\t\t3. k--,是因为数组下标从0开始，方便计算。\n\t\t\t\t\t\t4. k %= fact 是因为， k = 13 % 6 = 1, \n\t\t\t\t\t\t    fact = 6 / 3 = 2;\n\t\t\t\t\t\t    k / (fact / n) : 1 / (6 / 3) = 0, 我们要在剩余的3位permutation数字中确定首位的序号，首位取0，\n\t\t\t\t\t\t    3，1\n\t\t\t\t\t\t5. 如此循环直到n == 0;\n\n\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic String getPermutation(int n, int k) {\n\t\t\t\t\t    LinkedList<Integer> list = new LinkedList<>();\n\t\t\t\t\t    for (int i = 1; i <= n; i++) {\n\t\t\t\t\t    \tlist.add(i);\n\t\t\t\t\t    }\n\t\t\t\t\t    int fact = 1;\n\t\t\t\t\t    for (int i = 2; i <= n; i++) {\n\t\t\t\t\t    \tfact *= i; // factorial\n\t\t\t\t\t    }\n\t\t\t\t\t    StringBuilder sb = new StringBuilder();\n\t\t\t\t\t    for (k--; n > 0; n--) {\n\t\t\t\t\t        fact /= n;\n\t\t\t\t\t        sb.append(list.remove(k / fact));\n\t\t\t\t\t        k %= fact;\n\t\t\t\t\t    }\n\t\t\t\t    \treturn sb.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t1.3 Next Permutation\n\t\t\t\t/*\n\t\t\t\t\t1. find the first element which A[i] <= A[i + 1], the index i start from num.length - 2;\n\t\t\t\t\t2. find the smallest one which make A[j] > A[i] , j start from the index i + 1 to A.length - 1;\n\t\t\t\t\t\t(notice, i + 1 ~ A.length - 1,must be a descending order, since the step 1)\n\t\t\t\t\t3. swap(i, j)\n\t\t\t\t\t4. reverse from i + 1 to nums.length - 1;\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic void nextPermutation(int[] num) {\n\t\t\t\t        if (num == null || num.length <= 1) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        int i = num.length - 2;\n\t\t\t\t        while (i >= 0 && num[i + 1] <= num[i]) {\n\t\t\t\t            i--;\n\t\t\t\t        }\n\t\t\t\t        if (i >= 0) {\n\t\t\t\t        \t//the adjacent number of j\n\t\t\t\t            int j = i + 1;\n\t\t\t\t            //Why we don't need to compare the value?cause from j to length - 1, that is the descending array so the last large one is smallest one\n\t\t\t\t            while (j < num.length && num[j] > num[i]) {\n\t\t\t\t                j++;\n\t\t\t\t            }\n\t\t\t\t            j--;\n\t\t\t\t            swap(num, i, j);\n\t\t\t\t        }\n\t\t\t\t        reverse(num, i + 1, num.length - 1);\n\t\t\t\t    } \n\t\t\t\t    public void reverse(int[] num, int i, int j) {\n\t\t\t\t        while (i < j) {\n\t\t\t\t            swap(num, i++, j--);\n\t\t\t\t        }   \n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t1.4 Previous Permutation\n\t\t\t\t/*\n\t\t\t\t\t思路：和next permutation完全一致的思路。\n\t\t\t\t\t1. 从右往左扫，找到的第一个增长pivot，这个大的数字就是即将被换掉的位置i\n\t\t\t\t\t2. 从这个数字往右必然是一个递增序列，往右扫，直到找到一个数比这个pivot小而且是所有右边数字中最大的（递增序列，因此最后一个比pivot大的就是）\n\t\t\t\t\t3. 然后交换pivot和该数字。\n\t\t\t\t\t4. reverse from i + 1 ~ nums.len - 1;\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic void previousPermutation(int[] num) {\n\t\t\t\t        if (num == null || num.length <= 1) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        int i = num.length - 2;\n\t\t\t\t        while (i >= 0 && num[i + 1] >= num[i]) {//只有两处区别，第一处\n\t\t\t\t            i--;\n\t\t\t\t        }\n\t\t\t\t        if (i >= 0) {\n\t\t\t\t        \t//the adjacent number of j\n\t\t\t\t            int j = i + 1;\n\t\t\t\t            //Why we don't need to compare the value?cause from j to length - 1, that is the descending array so the last large one is smallest one\n\t\t\t\t            while (j < num.length && num[j] < num[i]) {//第二处\n\t\t\t\t                j++;\n\t\t\t\t            }\n\t\t\t\t            j--;\n\t\t\t\t            swap(num, i, j);\n\t\t\t\t        }\n\t\t\t\t        reverse(num, i + 1, num.length - 1);\n\t\t\t\t    }   \n\t\t\t\t}\n\t\t\t1.5 Palindrome Permutation II\n\t\t\t\t/*\n\t\t\t\t\tGiven a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\n\t\t\t\t\tFor example:\n\t\t\t\t\t\tGiven s = \"aabb\", return [\"abba\", \"baab\"].\n\t\t\t\t\t\tGiven s = \"abc\", return [].\n\t\t\t\t*/\n\t\t\t\t/*\n\t\t\t\t\t关键部分： 1. 判断这个String 是否能够palindrome，这里用一个hashmap，value存每一个字符出现的次数\n\t\t\t\t\t\t\t\t字符数量为奇数的字符最多只允许一个，用odd去记录奇数字符的个数，大于1就返回空list。（\n\t\t\t\t\t\t\t 2. 用一个list去保存hashmap里的字符，记住只需要保存一半即可，\n\t\t\t\t\t\t\t \t比如 aaaa bb ccc dddd,只需要保存 aabcdd, 再对这个一半的字符串进行backtracking\n\t\t\t\t\t\t\t \taabcdd + c + ddcbaa.....\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> generatePalindromes(String s) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        int odd = 0;\n\t\t\t\t        String mid = \"\";\n\t\t\t\t        List<Character> item = new ArrayList<>();\n\t\t\t\t        HashMap<Character, Integer> map = new HashMap<>();\n\t\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t\t            char c = s.charAt(i);\n\t\t\t\t            if (map.containsKey(c)) {\n\t\t\t\t                map.put(c, map.get(c) + 1);\n\t\t\t\t            } else {\n\t\t\t\t                map.put(c, 1);\n\t\t\t\t            }\n\t\t\t\t            odd += map.get(c) % 2 != 0 ? 1 : -1;//char的数量只要是偶数就会抵消\n\t\t\t\t        }\n\t\t\t\t        if (odd > 1) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n\t\t\t\t            char key = entry.getKey();\n\t\t\t\t            int val = entry.getValue();\n\t\t\t\t            \n\t\t\t\t            if (val % 2 != 0) {\n\t\t\t\t                mid += key;\n\t\t\t\t            }\n\t\t\t\t            //only need to find the first half\n\t\t\t\t            for (int i = 0; i < val / 2; i++) {\n\t\t\t\t                item.add(key);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        helper(item, mid, new boolean[item.size()], new StringBuilder(), res);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<Character> item, String mid, boolean[] visited, StringBuilder sb, List<String> res) {\n\t\t\t\t        //only need to find the first half\n\t\t\t\t        if (sb.length() == item.size()) {\n\t\t\t\t            res.add(sb.toString() + mid + sb.reverse().toString());\n\t\t\t\t            sb.reverse();\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < item.size(); i++) {\n\t\t\t\t            if (i != 0 && item.get(i) == item.get(i - 1) && !visited[i - 1]) {//去重\n\t\t\t\t                continue;\n\t\t\t\t            }\n\t\t\t\t            //Backtracking\n\t\t\t\t            if (!visited[i]) {\n\t\t\t\t                visited[i] = true;\n\t\t\t\t                sb.append(item.get(i));\n\t\t\t\t                helper(item, mid, visited, sb, res);\n\t\t\t\t                visited[i] = false;\n\t\t\t\t                sb.deleteCharAt(sb.length() - 1);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t2. Combination\n\t\t\t2.1 Combinations\n\t\t\t\t/*\n\t\t\t\t\tGiven two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n\t\t\t\t\tFor example,\n\t\t\t\t\tIf n = 4 and k = 2, a solution is:\n\t\t\t\t\t[\n\t\t\t\t\t  [2,4],\n\t\t\t\t\t  [3,4],\n\t\t\t\t\t  [2,3],\n\t\t\t\t\t  [1,2],\n\t\t\t\t\t  [1,3],\n\t\t\t\t\t  [1,4],\n\t\t\t\t\t]\n\t\t\t\t*/\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> combine(int n, int k) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (n == 0 || k == 0 || n < k) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        helper(res, item, n, k, 1);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<List<Integer>> res, List<Integer> item, int n, int k, int start) {\n\t\t\t\t        if (item.size() == k) {\n\t\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = start; i <= n; i++) {\n\t\t\t\t            item.add(i);\n\t\t\t\t            helper(res, item, n, k, i + 1);\n\t\t\t\t            item.remove(item.size() - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic List<List<Integer>> combine(int n, int k) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (k == 0 || n == 0 || k > n) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 1; i <= n; i++) {\n\t\t\t\t            res.add(Arrays.asList(i));\n\t\t\t\t        }\n\t\t\t\t        for (int i = 2; i <= k; i++) {\n\t\t\t\t            List<List<Integer>> tempRes = new ArrayList<>();\n\t\t\t\t            for (int j = i; j <= n; j++) {\n\t\t\t\t                for (List<Integer> item : res) {\n\t\t\t\t                    if (item.get(item.size() - 1) < j) {\n\t\t\t\t                        List<Integer> newItem = new ArrayList<>(item);\n\t\t\t\t                        newItem.add(j);\n\t\t\t\t                        tempRes.add(newItem);\n\t\t\t\t                    } \n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            res = tempRes;\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t2.2 Combination Sum I & II\n\t\t\t\t/*\n\t\t\t\t\tI ：candidates没有重复的数字，但是每个数字可以重复使用，因此递归下一层的时候，还是传递本身的位置\n\t\t\t\t\t\tO(k * 2^n) time.\n\t\t\t\t\tII：candidates有重复的数字，每个数字仅能使用一次，因此递归下一层的时候，数字从下一个开始\n\t\t\t\t\t\tO(k * 2^n) time.\n\t\t\t\t*/\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (candidates == null || candidates.length == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        Arrays.sort(candidates);\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        helper(candidates, res, item, target, 0);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(int[] candidates, List<List<Integer>> res, List<Integer> item, int target, int start) {\n\t\t\t\t        if (target < 0) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        if (target == 0) {\n\t\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = start; i < candidates.length; i++) {\n\t\t\t\t        \t// if (i > start && candidates[i - 1] == candidates[i]) { ---Combination sum II\n\t\t\t\t         //        continue;\n\t\t\t\t         //    }\n\t\t\t\t            int newTarget = target - candidates[i];\n\t\t\t\t            item.add(candidates[i]);\n\t\t\t\t            helper(candidates, res, item, newTarget, i);//helper(candidates, res, item, newTarget, i + 1); ---Combination sum II\n\t\t\t\t            item.remove(item.size() - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\t/*\n                    Example :{2, 3, 6, 7}\n                    dp.get(i) = {candidates[j], dp.get(i - candidates[j] - 1)}\n                    dp.get(0) = {[]};\n                    dp.get(1) = {[2]};\n                    dp.get(2) = {[3]};\n                    dp.get(3) = {[2, 2]};\n                    dp.get(4) = {[2, 3]};\n                    dp.get(5) = {[2, 2, 2], [3, 3], [6]};\n                    \n                    dp.get(5) = {2 + dp.get(3)}, {3 + dp.get(2)}. {6 + dp.get(0));\n\n                    ->  for 循环所有candidates[j], 并且使得candidates[j]要满足 candidates[j] <= item里面的第一个元素\n\n                        dp.get(i) = {candidates[j] + dp.get(i - candidates[j] - 1) }\n                */\n\t\t\t    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n\t\t\t         Arrays.sort(candidates);\n\t\t\t         List<List<List<Integer>>> dp = new ArrayList<>();\n\t\t\t         for (int i = 1; i <= target; i++) {// run through all targets from 1 to target\n\t\t\t             List<List<Integer>> tempRes = new ArrayList<>();\n\t\t\t             // run through all candidates <= i\n\t\t\t             for (int j = 0; j < candidates.length && candidates[j] <= i; j++) {\n\t\t\t                 // special case when cur target is equal to cur candidate\n\t\t\t                 if (i == candidates[j]) {\n\t\t\t                     tempRes.add(Arrays.asList(candidates[j]));\n\t\t\t                 } else {\n\t\t\t                     for (List<Integer> item : dp.get(i - candidates[j] - 1)) {\n\t\t\t                          // if current candidate is less than the target use prev results, since we already get the result\n\t\t\t                         if (candidates[j] <= item.get(0)) {\n\t\t\t                             List<Integer> newList = new ArrayList<>();\n\t\t\t                             newList.add(candidates[j]);\n\t\t\t                             newList.addAll(item);\n\t\t\t                             tempRes.add(newList);\n\t\t\t                         }\n\t\t\t                     }\n\t\t\t                 }\n\t\t\t             }\n\t\t\t             dp.add(tempRes);\n\t\t\t         }\n\t\t\t         return dp.get(target - 1);\n\t\t\t    }\n\t\t\t2.3 Combination Sum III\n\t\t\t\t/*\n\t\t\t\t\tFind all possible combinations of k numbers that add up to a number n, \n\t\t\t\t\tgiven that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\n\t\t\t\t\t\tInput: \t k = 3, n = 9\n\t\t\t\t\t\tOutput:\n\t\t\t\t\t\t\t\t[[1,2,6], [1,3,5], [2,3,4]]\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> combinationSum3(int k, int n) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        helper(res, item, k, n, 1);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<List<Integer>> res, List<Integer> item, int k, int target, int start) {\n\t\t\t\t        if (item.size() == k && target == 0) {\n\t\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = start; i <= 9; i++) {\n\t\t\t\t            int newTarget = target - i;\n\t\t\t\t            item.add(i);\n\t\t\t\t            helper(res, item, k, newTarget, i + 1);\n\t\t\t\t            item.remove(item.size() - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t2.4 Letter Combinations Of A Phone Number\n\t\t\t\t/*\n\t\t\t\t\tO(n * 4^n) OR O(n * 3^p*4^q) time\n\t\t\t\t    Explanation:\n\t\t\t\t    O(n * num of sols) time\n\t\t\t\t    n is the toString() API time complexity which is the same length as input\n\t\t\t\t  \n\t\t\t\t    num of sols:\n\t\t\t\t    O(4^n)\n\t\t\t\t    n is the length of input digits\n\t\t\t\t    \n\t\t\t\t    OR O(3^p*4^q) solutions\n\t\t\t\t    p is the number of digits which has 3 corresponding letters\n\t\t\t\t    q is the number of digits which has 4 corresponding letters\n\t\t\t    */\n\t\t\t\t//Recursive\n\t\t\t    public class Solution {\n\t\t\t\t    public List<String> letterCombinations(String digits) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (digits == null || digits.length() == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        String[] keyboard = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        helper(res, digits, keyboard, sb, 0);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<String> res, String digits, String[] keyboard, StringBuilder sb, int index) {\n\t\t\t\t        if (sb.length() == digits.length()) {\n\t\t\t\t            res.add(sb.toString());\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        int number = digits.charAt(index) - '0';\n\t\t\t\t        for (int i = 0; i < keyboard[number].length(); i++) {\n\t\t\t\t            sb.append(keyboard[number].charAt(i));\n\t\t\t\t            helper(res, digits, keyboard, sb, index + 1);\n\t\t\t\t            sb.deleteCharAt(sb.length() - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\tpublic List<String> letterCombinations(String digits) {\n\t\t\t        List<String> res = new LinkedList<>();\n\t\t\t        if (digits == null || digits.length() == 0) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        String[] keyboard = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\t\t\t        res.add(\"\");\n\t\t\t        for (int i = 0; i < digits.length(); i++) {\n\t\t\t            String letters = keyboard[digits.charAt(i) - '2'];\n\t\t\t            int size = res.size();\n\t\t\t            for (int j = 0; j < size; j++) {\n\t\t\t                String item = res.remove(0);\n\t\t\t                for (int k = 0; k < letters.length(); k++) {\n\t\t\t                    res.add(item + letters.charAt(k));\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t2.5 Factor Combinations\n\t\t\t\t/*\n\t\t\t\t\tEach combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2].\n\t\t\t\t\tYou may assume that n is always positive.\n\t\t\t\t\tFactors should be greater than 1 and less than n.\n\t\t\t\t\tinput: 32\n\t\t\t\t\toutput:\n\t\t\t\t\t[\n\t\t\t\t\t  [2, 16],\n\t\t\t\t\t  [2, 2, 8],\n\t\t\t\t\t  [2, 2, 2, 4],\n\t\t\t\t\t  [2, 2, 2, 2, 2],\n\t\t\t\t\t  [2, 4, 4],\n\t\t\t\t\t  [4, 8]\n\t\t\t\t\t]\n\t\t\t\t*/\n\t\t\t\t//The Key Point is using n / i to recursive, unitl n / i == 1\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> getFactors(int n) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (n == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        helper(res, item, n, 2);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<List<Integer>> res, List<Integer> item, int n, int start) {\n\t\t\t\t        if (n < 1) {\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        if (n == 1 && item.size() > 1) {\n\t\t\t\t            res.add(new ArrayList<>(item));\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = start; i <= n; i++) {\n\t\t\t\t            if (n % i == 0) {\n\t\t\t\t                item.add(i);\n\t\t\t\t                helper(res, item, n / i, i);\n\t\t\t\t                item.remove(item.size() - 1);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t3. Subsets（子集）\n\t\t\t3.1 SubsetsI\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> subsets(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (nums == null || nums.length == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        Arrays.sort(nums);\n\t\t\t\t        res.add(new ArrayList<Integer>());\n\t\t\t\t        helper(nums, res, item, 0);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(int[] nums, List<List<Integer>> res, List<Integer> item, int start) {\n\t\t\t\t        for (int i = start; i < nums.length; i++) {\n\t\t\t\t            item.add(nums[i]);\n\t\t\t\t            res.add(new ArrayList<Integer>(item));\n\t\t\t\t            helper(nums, res, item, i + 1);\n\t\t\t\t            item.remove(item.size() - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iteration\n\t\t\t\t/*\n\t\t\t\t\tres = { {} }\n                    res = { {} } + { {1} }\n                    res = { {}, {1} } + {{2} ,{1, 2} } = {{}, {1}, {2}, {1, 2}};\n                    res = {{}, {1}, {2}, {1, 2}} + {{3}, {1,3}, {2, 3}, {1, 2, 3}};\n\t\t\t\t*/\n                public class Solution {\n\t\t\t\t\tpublic List<List<Integer>> subsets(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        res.add(new ArrayList<>());\n\t\t\t\t        Arrays.sort(nums);\n\t\t\t\t        int size = 0;\n\t\t\t\t\t    for (int i = 0; i < nums.length; i++) {\n\t\t\t\t            size = res.size();\n\t\t\t\t            for (int j = 0; j < size; j++) {\n\t\t\t\t                List<Integer> item = new ArrayList<>(res.get(j));\n\t\t\t\t                item.add(nums[i]);\n\t\t\t\t                res.add(item);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t3.2 SubsetsII\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<Integer>> subsetsWithDup(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        if (nums == null || nums.length == 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        Arrays.sort(nums);\n\t\t\t\t        boolean[] visited = new boolean[nums.length];\n\t\t\t\t        List<Integer> item = new ArrayList<>();\n\t\t\t\t        res.add(new ArrayList<Integer>());\n\t\t\t\t        helper(nums, res, item, visited, 0);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(int[] nums, List<List<Integer>> res, List<Integer> item, boolean[] visited, int start) {\n\t\t\t\t        for (int i = start; i < nums.length; i++) {\n\t\t\t\t            if (i != 0 && nums[i - 1] == nums[i] && !visited[i - 1]) {\n\t\t\t\t                continue;\n\t\t\t\t            }\n\t\t\t\t            if (!visited[i]) {\n\t\t\t\t                item.add(nums[i]);\n\t\t\t\t                visited[i] = true;\n\t\t\t\t                res.add(new ArrayList<>(item));\n\t\t\t\t                helper(nums, res, item, visited, i + 1);\n\t\t\t\t                visited[i] = false;\n\t\t\t\t                item.remove(item.size() - 1);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iteration\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic List<List<Integer>> subsetsWithDup(int[] nums) {\n\t\t\t\t        List<List<Integer>> res = new ArrayList<>();\n\t\t\t\t        res.add(new ArrayList<>());\n\t\t\t\t        Arrays.sort(nums);\n\t\t\t\t        int size = 0;\n\t\t\t\t        int startIndex = 0;\n\t\t\t\t        for (int i = 0; i < nums.length; i++) {\n\t\t\t\t            if (i != 0 && nums[i] == nums[i - 1]) {\n\t\t\t\t                startIndex = size;\n\t\t\t\t            } else {\n\t\t\t\t                startIndex = 0;\n\t\t\t\t            }\n\t\t\t\t            size = res.size();\n\t\t\t\t            for (int j = startIndex; j < size; j++) {\n\t\t\t\t                List<Integer> item = new ArrayList<>(res.get(j));\n\t\t\t\t                item.add(nums[i]);\n\t\t\t\t                res.add(item);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\n\n\t\t4. Bits, Math, Others,Backtracking\n\t\t\t4.1 Gray Code \n\t\t\t\t/*\n\t\t\t\t\t n = 0: 0\n\t\t\t\t\t n = 1: 0 -> 1\n\t\t\t\t\t n = 2: 0 -> 1 -> 3 -> 2\n\t\t\t\t\t n = 3: 0 -> 1 -> 3 -> 2 -> 6 -> 7 -> 5 -> 4 , 规律，每次从res中从后往前取 + 1 << (n - 1)\n\t\t\t\t*/\n\t\t\t\t//Recursive\n\t\t\t\t//O(2^n) time, O(1) space OR O(n) space if consider recursion stack\n\t\t\t\tpublic List<Integer> grayCode(int n) {\n\t\t\t        if (n == 0) {\n\t\t\t            List<Integer> res = new ArrayList<>();\n\t\t\t            res.add(0);\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        List<Integer> res = grayCode(n - 1);\n\t\t\t        int inc = 1 << n - 1;\n\t\t\t        for (int i = res.size() - 1; i >= 0; i--) {\n\t\t\t            res.add(res.get(i) + inc);\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    //Iteration\n\t    \t\t// O(2^n) time, O(1) space\n\t\t\t    public List<Integer> grayCode(int n) {\n\t\t\t        List<Integer> res = new ArrayList<>();\n\t\t\t        res.add(0);\n\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t            int inc = 1 << i;\n\t\t\t            for (int j = res.size() - 1; j >= 0; j--) {\n\t\t\t                res.add(res.get(j) + inc);\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t4.2 Generate Parentheses\n\t\t\t\t//Recursive\n\t\t\t\t/*\n\t\t\t\t\t(n)*h(n) time:\n\t\t\t\t    Explanation:\n\t\t\t\t    \t此题时间复杂度应该是解的个数乘以每个解的长度, 解的个数对应卡特兰数h(n)的通项公式: \n\t\t\t\t\t    h(n) = 2n!/(n!*n+1!) = C(2*n, n)/(n+1)\n\t\t\t\t\t    解的长度是2n, 也就是O(n)\n\n\t\t\t\t    O(n) space:\n\t\t\t\t    path的最大长度也是recursion stack的最高高度, 为2n.\n\t\t\t\t*/ \n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> generateParenthesis(int n) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (n < 1) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        helper(res, \"\", n, n);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(List<String> res, String item, int left, int right) {\n\t\t\t\t        if (left == 0 && right == 0) {\n\t\t\t\t            res.add(item);\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        if (left > 0) {\n\t\t\t\t            helper(res, item + '(', left - 1, right);\n\t\t\t\t        } \n\t\t\t\t        if (left < right) {\n\t\t\t\t            helper(res, item + ')', left, right - 1);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iteration\n\t\t\t\t/*\n\t\t\t\t\tLet the \"(\" always at the first position, to produce a valid result, we can only put \")\" in a way that there will be \n\t\t\t\t\ti pairs () inside the extra () and n - 1 - i pairs () outside the extra pair.\n\n\t\t\t\t\tLet us consider an example to get clear view:\n\t\t\t\t\tf(0): \"\"\n\t\t\t\t\tf(1): \"(\"f(0)\")\"\n\t\t\t\t\tf(2): \"(\"f(0)\")\"f(1), \"(\"f(1)\")\"\n\t\t\t\t\tf(3): \"(\"f(0)\")\"f(2), \"(\"f(1)\")\"f(1), \"(\"f(2)\")\"\n\t\t\t\t\tSo f(n) = \"(\"f(0)\")\"f(n-1) , \"(\"f(1)\")\"f(n-2) \"(\"f(2)\")\"f(n-3) ... \"(\"f(i)\")\"f(n-1-i) ... \"(f(n-1)\")\"\n\t\t\t\t*/\n\t\t\t\tpublic List<String> generateParenthesis(int n) {\n\t\t\t        List<List<String>> lists = new ArrayList<>();\n\t\t\t        List<String> initList = new ArrayList<>();\n\t\t\t        initList.add(\"\");\n\t\t\t        lists.add(initList);\n\t\t\t        for (int i = 1; i <= n; i++) {\n\t\t\t            List<String> res = new ArrayList<>();\n\t\t\t            for (int j = 0; j < i; j++) {\n\t\t\t                for (String first : lists.get(j)) {\n\t\t\t                    for (String second : lists.get(i - 1 - j)) {\n\t\t\t                        res.add(\"(\" + first + \")\" + second);\n\t\t\t                    }\n\t\t\t                }\n\t\t\t            }\n\t\t\t            lists.add(res);\n\t\t\t        }\n\t\t\t        return lists.get(lists.size() - 1);\n\t\t\t    }\n\t\t\t4.3 Restore IP Addresses\n\t\t\t\t//Recursive\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> restoreIpAddresses(String s) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (s == null || s.length() == 0 || s.length() > 12) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        dfs(s, \"\", res, 0);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void dfs(String s, String item, List<String> res, int start) {\n\t\t\t\t        if (start == 3 && isValid(s)) {\n\t\t\t\t            res.add(item + s);\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < 3 && i < s.length(); i++) {\n\t\t\t\t            String subStr = s.substring(0, i + 1);\n\t\t\t\t            if (isValid(subStr)) {\n\t\t\t\t                dfs(s.substring(i + 1), item + subStr + '.', res, start + 1);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public boolean isValid(String s) {\n\t\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        if (s.charAt(0) == '0' && !s.equals(\"0\")) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        if (Integer.valueOf(s) <= 255 && Integer.valueOf(s) >= 0) {\n\t\t\t\t            return true;\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t//Iterative\n\t\t\t\tpublic class Solution {\n\t\t\t\t\tpublic List<String> restoreIpAddresses(String s) {\n\t\t\t\t        List<String> res = new ArrayList<String>();\n\t\t\t\t        int len = s.length();\n\t\t\t\t        for (int i = 1; i < 4 && i < len - 2; i++) {\n\t\t\t\t            for (int j = i + 1; j < i + 4 && j < len - 1; j++) { \n\t\t\t\t                for (int k = j + 1; k < j + 4 && k < len; k++) {\n\t\t\t\t                    String s1 = s.substring(0, i);\n\t\t\t\t                    String s2 = s.substring(i, j);\n\t\t\t\t                    String s3 = s.substring(j, k);\n\t\t\t\t                    String s4 = s.substring(k, len);\n\t\t\t\t                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\n\t\t\t\t                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t5. N-Queen, Sudo, Flip Game I & II\n\t\t\t5.1 N-Queens I\n\t\t\t\t//O(n) space, use matrix[i] to denote i row, matrix[i] col.\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<List<String>> solveNQueens(int n) {\n\t\t\t\t        List<List<String>> res = new ArrayList<>();\n\t\t\t\t        if (n <= 0) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        List<String> item = new ArrayList<>();\n\t\t\t\t        int[] matrix = new int[n];\n\t\t\t\t        dfs(res, 0, n, matrix);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void dfs(List<List<String>> res, int row, int n, int[] matrix) {\n\t\t\t\t        if (row == n) {\n\t\t\t\t            List<String> item = new ArrayList<>();\n\t\t\t\t            for (int i = 0; i < n; i++) {\n\t\t\t\t                StringBuilder sb = new StringBuilder();\n\t\t\t\t                for (int j = 0; j < n; j++) {\n\t\t\t\t                    if (j == matrix[i]) {\n\t\t\t\t                        sb.append('Q');\n\t\t\t\t                    } else {\n\t\t\t\t                        sb.append('.');\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t                item.add(sb.toString());\n\t\t\t\t            }\n\t\t\t\t            res.add(item);\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t\t            matrix[row] = i;\n\t\t\t\t            if (isValid(matrix, row)) {\n\t\t\t\t                dfs(res, row + 1, n, matrix);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public boolean isValid(int[] matrix, int row) {\n\t\t\t\t        for (int i = 0; i < row; i++) {\n\t\t\t\t            if (matrix[i] == matrix[row] || Math.abs(matrix[i] - matrix[row]) == row - i) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t5.2 N-Queens II\t\t\t\n\t\t\t\tpublic class Solution {\n\t\t\t\t    int count;\n\t\t\t\t    public int totalNQueens(int n) {\n\t\t\t\t        count = 0;\n\t\t\t\t        if (n == 0) {\n\t\t\t\t            return count;\n\t\t\t\t        }\n\t\t\t\t        int[] matrix = new int[n];\n\t\t\t\t        dfs(matrix, 0, n);\n\t\t\t\t        return count;\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t    public void dfs(int[] matrix, int row, int n) {\n\t\t\t\t        if (row == n) {\n\t\t\t\t            count++;\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0 ; i < n; i++) {\n\t\t\t\t            matrix[row] = i;\n\t\t\t\t            if (isValid(matrix, row)){\n\t\t\t\t                dfs(matrix, row + 1, n);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    public boolean isValid(int[] matrix, int row) {\n\t\t\t\t        for (int i = 0; i < row; i++) {\n\t\t\t\t            if (matrix[i] == matrix[row] || Math.abs(matrix[i] - matrix[row]) == row - i) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t5.3 Sudo Solver\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public void solveSudoku(char[][] board) {\n\t\t\t\t        if (board == null || board.length == 0 || board[0].length == 0) {\n\t\t\t\t            return ;\n\t\t\t\t        }\n\t\t\t\t        dfs(board);\n\t\t\t\t    }\n\t\t\t\t    public boolean dfs(char[][] board) {\n\t\t\t\t        for (int i = 0; i < board.length; i++) {\n\t\t\t\t            for (int j = 0; j < board[0].length; j++) {\n\t\t\t\t                if (board[i][j] == '.') {\n\t\t\t\t                    for (char c = '1'; c <= '9'; c++) {\n\t\t\t\t                        if (isValid(board, i, j, c)) {\n\t\t\t\t                            board[i][j] = c;\n\t\t\t\t                            if (dfs(board)) {\n\t\t\t\t                                return true;\n\t\t\t\t                            } else {\n\t\t\t\t                            \t//Backtracking\n\t\t\t\t                                board[i][j] = '.';\n\t\t\t\t                            }\n\t\t\t\t                        }\n\t\t\t\t                    }\n\t\t\t\t                    return false;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t    public boolean isValid(char[][] board, int row, int col, char c) {\n\t\t\t\t        for (int i = 0; i < board.length; i++) {\n\t\t\t\t            if (board[i][col] == c) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        for (int i = 0; i < board.length; i++) {\n\t\t\t\t            if (board[row][i] == c) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        //Key Point, use row / 3  + 0 ~ 2  and col / 3 + 0 ~ 2, to verify the small 3 * 3 matrix\n\t\t\t\t        for (int i = (row / 3) * 3; i < (row / 3) * 3 + 3; i++) {\n\t\t\t\t            for (int j = (col / 3) * 3; j < (col / 3) * 3 + 3; j++) {\n\t\t\t\t                if (board[i][j] == c) {\n\t\t\t\t                    return false;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t5.4 Valid Sudo\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean isValidSudoku(char[][] board) {\n\t\t\t\t        if (board == null || board.length == 0) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        return dfs(board);\n\t\t\t\t    }\n\t\t\t\t    public boolean dfs(char[][] board) {\n\t\t\t\t        for (int i = 0; i < 9; i++) {\n\t\t\t\t            for (int j = 0; j < 9; j++) {\n\t\t\t\t               if (board[i][j] != '.') {\n\t\t\t\t                   if (!isValid(board, i, j, board[i][j])){\n\t\t\t\t                       return false;\n\t\t\t\t                   }\n\t\t\t\t               }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t    public boolean isValid (char[][] board, int row, int col, char c) {\n\t\t\t\t    \t//check whole row\n\t\t\t\t        for (int i = 0; i < 9; i++) {\n\t\t\t\t            if (i != row && board[i][col] == c) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        //check whole col\n\t\t\t\t        for (int i = 0; i < 9; i++) {\n\t\t\t\t            if (i != col && board[row][i] == c) {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        //check the block\n\t\t\t\t        for (int i = (row / 3) * 3; i < (row / 3) * 3 + 3; i++) {\n\t\t\t\t            for (int j = (col / 3) * 3; j < (col / 3) * 3 + 3; j++) {\n\t\t\t\t                if ((i != row && j != col) && board[i][j] == c) {\n\t\t\t\t                    return false;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return true;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t5.5 Flip Game I & II\n\t\t\t\t/*\n\t\t\t\t    For the time complexity, here is what I thought, let's say the length of the input string s is n, \n\t\t\t\t    there are at most n - 1 ways to replace \"++\" to \"--\" (imagine s is all \"+++...\"), once we replace one \"++\", \n\t\t\t\t    there are at most (n - 2) - 1 ways to do the replacement, it's a little bit like solving the N-Queens problem, \n\n\t\t\t\t    the time complexity is (n - 1) x (n - 3) x (n - 5) x ..., so it's O(n!!)\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> generatePossibleNextMoves(String s) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (s == null || s.length() < 2) {\n\t\t\t\t            return res;\n\t\t\t\t        }     \n\t\t\t\t        for (int i = 0; i < s.length() - 1; i++) {\n\t\t\t\t            if (s.startsWith(\"++\", i)) {\n\t\t\t\t                res.add(s.substring(0, i) + \"--\" + s.substring(i + 2, s.length()));\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        // Flip Game II 用这句替换上面\n\t\t\t\t        // for (int i = 0; i < s.length() - 1; i++) {\n\t\t\t\t        //     if (s.startsWith(\"++\", i)) {\n\t\t\t\t        //         String item = s.substring(0, i) + \"--\" +s.substring(i + 2);\n\t\t\t\t        //         if (!canWin(item)) {\n\t\t\t\t        //             return true;\n\t\t\t\t        //         }\n\t\t\t\t        //     }\n\t\t\t\t        // }\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t6. Word Backtracking\n\t\t\t6.1 Word Search I\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean exist(char[][] board, String word) {\n\t\t\t\t        if (board == null || board.length == 0) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        if (word == null || word.length() == 0) {\n\t\t\t\t            return true;\n\t\t\t\t        }\n\t\t\t\t        boolean[][] visited = new boolean[board.length][board[0].length];\n\t\t\t\t        for (int i = 0; i < board.length; i++) {\n\t\t\t\t            for (int j = 0; j < board[0].length; j++) {\n\t\t\t\t                if (dfs(i, j, board, word, 0, visited)) {\n\t\t\t\t                    return true;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return false;\n\t\t\t\t    }\n\t\t\t\t    public boolean dfs(int row, int col, char[][] board, String word, int index, boolean[][] visited) {\n\t\t\t\t        if (index == word.length()) {\n\t\t\t\t            return true;\n\t\t\t\t        }\n\t\t\t\t        if (row < 0 || col < 0 || row > board.length - 1 || col > board[0].length - 1 || word.charAt(index) != board[row][col] || visited[row][col]) {\n\t\t\t\t            return false;\n\t\t\t\t        }\n\t\t\t\t        visited[row][col] = true;\n\t\t\t\t        boolean res = dfs(row - 1, col, board, word, index + 1, visited) ||\n\t\t\t\t               dfs(row + 1, col, board, word, index + 1, visited) ||\n\t\t\t\t               dfs(row, col + 1, board, word, index + 1, visited) ||\n\t\t\t\t               dfs(row, col - 1, board, word, index + 1, visited);\n\t\t\t\t        visited[row][col] = false;\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t6.2 Word Search II\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> findWords(char[][] board, String[] words) {\n\t\t\t\t         ArrayList<String> res = new ArrayList<String>();\n\t\t\t\t        if (board == null || board.length == 0 || board[0].length == 0 || words == null) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        // HashSet<String> set = new HashSet<>();\n\t\t\t\t        Trie root = new Trie();\n\t\t\t\t        for (int i = 0; i < words.length; i++) {\n\t\t\t\t            root.insert(words[i]);\n\t\t\t\t        }\n\t\t\t\t        int m = board.length;\n\t\t\t\t        int n = board[0].length;\n\t\t\t\t        boolean[][] visited = new boolean[m][n];\n\t\t\t\t        for (int i = 0; i < m; i++) {\n\t\t\t\t            for (int j = 0; j < n; j++) {\n\t\t\t\t                dfs(res, board, i, j, visited, root, \"\");\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        return res;\n\t\t\t\t     }\n\t\t\t\t     public void dfs(ArrayList<String> res, char[][] board, int row, int col, boolean[][] visited, Trie root, String item) {\n\t\t\t\t         if (row < 0 || col < 0 || row > board.length - 1 || col > board[0].length - 1 || visited[row][col]) {\n\t\t\t\t             return ;\n\t\t\t\t         }\n\t\t\t\t         item = item + board[row][col];\n\t\t\t\t         if (!root.startsWith(item)) {\n\t\t\t\t             return;\n\t\t\t\t         }\n\t\t\t\t         visited[row][col] = true;\n\t\t\t\t         if (root.search(item) && !res.contains(item)) {\n\t\t\t\t             res.add(item);\n\t\t\t\t         }\n\t\t\t\t         dfs(res, board, row + 1, col, visited, root, item);\n\t\t\t\t         dfs(res, board, row - 1, col, visited, root, item);\n\t\t\t\t         dfs(res, board, row, col + 1, visited, root, item);\n\t\t\t\t         dfs(res, board, row, col - 1, visited, root, item);\n\t\t\t\t         visited[row][col] = false;\n\t\t\t\t     }\n\t\t\t\t}\n\t\t\t6.3 Word Break II\n\t\t\t\t/*\n\t\t\t\t\ts = \"catsanddog\", dict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"].\n\t\t\t\t\tA solution is [\"cats and dog\", \"cat sand dog\"].\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public List<String> wordBreak(String s, Set<String> wordDict) {\n\t\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t\t        if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0 || !isWordBreak(s, wordDict)) {\n\t\t\t\t            return res;\n\t\t\t\t        }\n\t\t\t\t        helper(s, wordDict, 0, \"\", res);\n\t\t\t\t        return res;\n\t\t\t\t    }\n\t\t\t\t    public void helper(String s, Set<String> wordDict, int start, String item, List<String> res) {\n\t\t\t\t        if (start == s.length()) {\n\t\t\t\t            res.add(item);\n\t\t\t\t            return;\n\t\t\t\t        }\n\t\t\t\t        //Key point\n\t\t\t\t        StringBuilder sb = new StringBuilder();\n\t\t\t\t        for (int i = start; i < s.length(); i++) {\n\t\t\t\t            sb.append(s.charAt(i));\n\t\t\t\t            if (wordDict.contains(sb.toString())) {\n\t\t\t\t                String newItem = item.length() > 0 ? (item + \" \" + sb.toString()) : sb.toString();\n\t\t\t\t                helper(s, wordDict, i + 1, newItem, res);\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t6.4 Regular Matching\n\t\t\t\t/*\n\t\t\t\t\t'.' Matches any single character.\n\t\t\t\t\t'*' Matches zero or more of the preceding element.\n\t\t\t\t*/\n\t\t\t\tpublic boolean isMatch(String s, String p) {\n\t\t\t        if (p.isEmpty()) {\n\t\t\t            return s.isEmpty();\n\t\t\t        }\n\t\t\t        //check the p.length() == 1 ,or the charAt(1) != '*', easy to do just recursive find the substring(1)\n\t\t\t        if (p.length() == 1 || p.charAt(1) != '*') {\n\t\t\t            if (s.isEmpty() || (p.charAt(0) != '.' && p.charAt(0) != s.charAt(0))) {\n\t\t\t                return false;\n\t\t\t            } else {\n\t\t\t                return isMatch(s.substring(1), p.substring(1));\n\t\t\t            }\n\t\t\t        }\n\t\t\t        //P.length() >=2 and p.charAt(1) must be equals = '*', notice the last if statement\n\t\t\t        while (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')) {\n\t\t\t            if (isMatch(s, p.substring(2))) {\n\t\t\t                return true;\n\t\t\t            }\n\t\t\t            s = s.substring(1);\n\t\t\t        }\n\t\t\t        return isMatch(s, p.substring(2));\n\t\t\t    }\n\t\t\t6.5 Wildcard Matching Greedy\n\t\t\t\t/*\n\t\t\t\t\t'?' Matches any single character.\n\t\t\t\t\t'*' Matches any sequence of characters (including the empty sequence).\n\n\t\t\t\t\t主要是*的匹配问题。p每遇到一个*，就保留住当前*的坐标和s的坐标，然后s从前往后扫描，如果不成功，则s++,重新扫描。\n\t\t\t        1. *s==*p or *p == ? ：匹配，s++ p++。\n\t\t\t        2. p=='*'：也是一个匹配，但可能有0个或者多个字符用于匹配，\n\t\t\t        \t 所以将'*'所在位置保存(star)，并且将s的位置也保存下来(ss)。\n\t\t\t        3. 如果不匹配，查看之前是否有'*'。没有则返回false，有则对ss的下一个位置和start之后的重新匹配。\n\t\t\t\t*/\n\t\t\t\tpublic class Solution {\n\t\t\t\t    public boolean isMatch(String str, String pattern) {\n\t\t\t\t        int s = 0;\n\t\t\t\t        int p = 0;\n\t\t\t\t        int match = 0;\n\t\t\t\t        int starIndex = -1;\n\t\t\t\t        while (s < str.length()) {\n\t\t\t\t            if (p < pattern.length() && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))) {\n\t\t\t\t                s++;\n\t\t\t\t                p++;\n\t\t\t\t            } else if (p < pattern.length() && pattern.charAt(p) == '*') {\n\t\t\t\t                starIndex = p;\n\t\t\t\t                match = s;\n\t\t\t\t                p++;\n\t\t\t\t            } else if (starIndex != -1) {\n\t\t\t\t                p = starIndex + 1;\n\t\t\t\t                match++;\n\t\t\t\t                s = match;\n\t\t\t\t            } else {\n\t\t\t\t                return false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        while (p < pattern.length() && pattern.charAt(p) == '*') {\n\t\t\t\t            p++;\n\t\t\t\t        }\n\t\t\t\t        return p == pattern.length();\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  ]
}