{
  "title": "Sort",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "\n1. Sort\n  1.1 Math\n        1.1.1 Largest Number\n        /*\n          Given a list of non negative integers, arrange them such that they form the largest number.\n          For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.\n          Note: The result may be very large, so you need to return a string instead of an integer.\n        */\n        /*\n           Key Point: How to compare two numbers? Just compare (String)num1 + num2 and (String)num2 + num1, and use compareTo method.\n        */\n        public class Solution {\n          public String largestNumber(int[] nums) {\n              String res = \"\";\n              if (nums == null || nums.length == 0) {\n                  return \"0\";\n              }\n              String[] strNum = new String[nums.length];\n              for (int i = 0; i < nums.length; i++) {\n                  strNum[i] = String.valueOf(nums[i]);\n              }\n              Comparator<String> comp = new Comparator<String>(){\n                  public int compare(String s1, String s2) {\n                      String num1 = s1 + s2;\n                      String num2 = s2 + s1;\n                      return num2.compareTo(num1);\n                  }\n              };\n              Arrays.sort(strNum, comp);\n              for (String s : strNum) {\n                  res += s;\n              }\n              if (res.charAt(0) == '0') {\n                  return \"0\";\n              } else {\n                  return res;\n              }\n          }\n      }\n      1.1.2 H-Index\n        \n\n\n\n\n\n2. Interval Problem\n  2.1 Comparator and Compare Modification Problem\n        2.1.1 Meeting Rooms I\n          /*\n            Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), \n            determine if a person could attend all   meetings.\n    \n            For example,\n            Given [[0, 30],[5, 10],[15, 20]],\n            return false.\n          */\n          public class Solution {\n            public boolean canAttendMeetings(Interval[] intervals) {\n                if (intervals == null || intervals.length == 0) {\n                    return true;\n                }\n                // Sort the intervals by start time\n                // Arrays.sort(intervals, new Comparator<Interval>() {\n                //   public int compare(Interval a, Interval b) { return a.start - b.start; }\n                // });\n                Comparator<Interval> comp = new Comparator<Interval>(){\n                    @Override\n                    public int compare(Interval i1, Interval i2) {\n                        if (i1.start < i2.start) {\n                            return -1;\n                        } else if (i1.start > i2.start) {\n                            return 1;\n                        } else {\n                            return i1.end - i2.end;\n                        }\n                    }\n                };\n                Arrays.sort(intervals, comp);\n                for (int i = 1; i < intervals.length; i++) {\n                    if (intervals[i].start < intervals[i - 1].end) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n      2.1.2 Meeting Rooms II\n          /*\n              Solution：\n                  1. 先按照interval.start对interval进行排序\n                  2. 建一个PriorityQueue，按照interval的end建最小堆，也就是最小的end在前面\n                  3. 将排序后的intervals数组取出逐一和最小堆的堆顶interval进行比对，\n                      为什么用最小堆，因为此时取出的堆顶元素的pre.start绝对比now.start要小（排序后的数组），\n                      我们只需要比较now.start he pre.end\n                      3.1 如果now.start比pre.end要大，意味着可以共用一个会议室，merge这个时间段再放入最小堆\n                      3.2 如果now.start比pre.end要小，意味着时间重叠，两个都要加入最小堆\n                      注意最小堆每次取出的end都是堆顶最小，所以不可能出现 pre（10, 20)  now(22,25) (after20,23  这样忽略的时间段\n          */\n          public class Solution {\n            public int minMeetingRooms(Interval[] intervals) {\n                if (intervals == null || intervals.length == 0) {\n                    return 0;\n                }\n                Arrays.sort(intervals, new Comparator<Interval>() {\n                   @Override\n                   public int compare(Interval i1, Interval i2) {\n                       return i1.start - i2.start;\n                   }\n                });\n                PriorityQueue<Interval> minHeap = new PriorityQueue<>(new Comparator<Interval>(){\n                    public int compare(Interval i1, Interval i2) {\n                        return i1.end - i2.end;\n                    }\n                });\n                Interval pre = intervals[0];\n                minHeap.offer(pre);\n                int count = 1;\n                for (int i = 1; i < intervals.length; i++) {\n                    pre = minHeap.poll();\n                    if (intervals[i].start >= pre.end) {\n                        pre.end = intervals[i].end;\n                    } else {\n                        minHeap.offer(intervals[i]);\n                    }\n                    minHeap.offer(pre);\n                    \n                }\n                return minHeap.size();\n            }\n        }\n  2.2 Interval Merge And Insert\n      2.2.1 Merge Intervals\n        /*\n          Given a collection of intervals, merge all overlapping intervals.\n\n          For example,\n          Given [1,3],[2,6],[8,10],[15,18],\n          return [1,6],[8,10],[15,18].\n        */\n        public class Solution {\n          public List<Interval> merge(List<Interval> intervals) {\n              List<Interval> res = new ArrayList<>();\n              if (intervals == null || intervals.size() == 0) {\n                  return res;\n              }\n              Collections.sort(intervals, new Comparator<Interval>(){\n                  @Override\n                  public int compare(Interval i1, Interval i2) {\n                      return i1.start - i2.start;\n                  }\n              });\n              res.add(intervals.get(0));\n              for (int i = 1; i < intervals.size(); i++) {\n                  Interval cur = intervals.get(i);\n                  Interval last = res.get(res.size() - 1);\n                  if (last.end < cur.start) {\n                      res.add(cur);\n                  } else {\n                      last.end = Math.max(cur.end, last.end);\n                  }\n              }\n              return res;\n          }\n        }\n      2.2.2 Insert Interval\n        /*\n          Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n          You may assume that the intervals were initially sorted according to their start times.\n          \n          Example 1:\n          Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\n          \n          Example 2:\n          Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\n          \n          This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\n        */\n        public class Solution {\n            public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n                List<Interval> res = new ArrayList<>();\n                for (Interval cur : intervals) {\n                    if (newInterval.end < cur.start) {\n                        res.add(newInterval);\n                        newInterval = cur;\n                    } else if (cur.end < newInterval.start) {\n                        res.add(cur);\n                    } else {\n                        newInterval = new Interval(Math.min(cur.start, newInterval.start), Math.max(cur.end, newInterval.end));\n                       \n                    }\n                }\n                res.add(newInterval);\n                return res;\n            }\n        }\n        \n\n      "
    }
  ]
}