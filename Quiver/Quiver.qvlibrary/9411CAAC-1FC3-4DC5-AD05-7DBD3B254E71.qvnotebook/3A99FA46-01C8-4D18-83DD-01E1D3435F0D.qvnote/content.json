{
  "title": "难题",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "Summary Range\nZigzag Conversion\nCompare Version Numbers\nProduct of Array Except Self\nMissing Range\nZigzag  Iterator\nshortest word distance\nSingle Number III\nSingle Number II\nUnique Binary Search Trees I & II\nMaximum Product of Word Lengths\nConvert Sorted List to Binary Search Tree\nKth Smallest Element in a BST\nBest Time to Buy and Sell Stock with Cooldown\nCount Univalue Subtrees\nInorder Successor in BST\nSwap Nodes in Pairs\nSort Colors (one pass, two pointer method)\nSpiral Matrix II\nGame of Life\nMeeting Rooms II\nClosest Binary Search Tree Value II My Submissions Question\nCount of Range Sum\nCount of Smaller Numbers After Self\nPeeking Iterator\nFind Peak Element //循环条件式一定成立\nH-Index I & II\nReverse Words in a String\n    /*\n        for (int start = s.length() - 1; start >= 0; start--) {\n            if (s.charAt(start) == ' ') {\n                continue;\n            }\n            int end = start;\n            while (start >= 0 && s.charAt(start) != ' ') {\n                start--;\n            }\n            res.append(s.substring(start + 1, end + 1)).append(' ');\n        }\n    */\nPopulating Next Right Pointers In Each Node II(No Need To A Perfect Binary Tree)\nFlatten Binary Tree To Linked List\nBinary Tree Upside Down\nTree Serialize\nClone Graph \nUnique Binary Search Trees II\nInsertion Sort List\nOne Edit Distance\nPatching Array //设一个know_num,表示数组能表示从[1,know_num)范围的所有数。\n               //假如know_num >= num[i]: know_sum += num[i], 否则know_sum += know_sum, 此时count++\nEncode and Decode Strings //最重要的两点， 1：encode成：len+\"/\"+word的形式，\n                          //2：用indexOf(\"/\", i)定位从第i个位置开始的第一个出现的 slash符的下标\nGas Station: /*\n                tank += gas[i] - cost[i];//记录local的油量\n                total += gas[i] - cost[i];//记录global的油量\n                if (tank < 0) { //local的油量不满足，则这个位置一定不满足起始点，设下一个为起始点\n                    start = i + 1;\n                    tank = 0;\n                }\n            */ \nMinimum Size Subarray Sum: //slide window\nCourse Schedule I & II // Topological Sort, 遍历点的邻居，并indegree array-- ,当入度为0 offer到queue中\n                       // return count == numCourses ? res : new int[0]; 最后要设置一个count比较是否等于course number， 刚开始时要为hashmap 初始化 所有course 的 Arraylist \nAdditive Number //dfs + parse the number to long type， check the number is valid(no start with \"0\")\nSqrt\nClone Graph // map.get(oldnode).neighbors.add(map.get(oldneighbor)); 关键\nCoin Change /*\n                if (coins[j] <= i && dp[i - coins[j]] != Integer.MAX_VALUE) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            */\nAdd and Search Word - Data structure design\n        /*\n            \n        */\nWord Break  /*\n                for (int i = 0; i < s.length(); i++) {\n                    for (int j = i + 1; j <= s.length(); j++) {\n                        if (dp[i] && wordDict.contains(s.substring(i, j))) {\n                            dp[j] = true;\n                        }\n                    }\n                }\n            */\nCount Complete Tree Nodes //计算树的高度\nSort List//\nRepeated DNA Sequences \n                        /*\n                            hash = (hash << 2) + dict.get(c);\n                            hash &= (1 << 20) - 1;\n                            if (map.containsKey(hash) && map.get(hash) == 1) {\n                                map.put(hash, map.get(hash) + 1);\n                                res.add(s.substring(i - 9, i + 1));\n                            } \n                            if (!map.containsKey(hash)) {\n                                map.put(hash, 1);\n                            }\n                        */\nRemove Duplicate Letters //\nNumber of Digit One  还是没太懂\nBasic Calculator II //栈里存数，每次遇到符号时，坚持上个符号是什么，再对之前的数进行相应操作压栈\nReconstruct Itinerary //HashMap<String, PriorityQueue<String>>, 关键，每次poll priorityqueue中排序最小的城市压入栈中遍历\nWord Search  //关键点，用index 记录word的遍历的位置，当index == word.length() 时 意味着match\nSpiral Matrix /*\n                key point1 :\n                1. while (m > 0 && n > 0) {\n                2. if (m == 1) -> for (int i = 0; i < n; i++) \n                   if (n == 1) -> for (int i = 0; i < m; i++) \n                3. 每次loop 完后 x++, y++, m = m - 2; n = n - 2;\n             */\nRange Sum Query 2D - Immutable\n        /*\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= n; j++) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n                }\n            }\n                \n            int sumRegion(int row1, int col1, int row2, int col2) {\n                return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n            }\n            关键点： 以为上面的dp的数组大小是m + 1, n + 1, 因此 这里的row col必须要相应的+1\n        */\nSimplify Path  //res += \"/\" + stack.removeLast();\n    /*\n         根据这些要求，我需要两个栈来解决问题。\n        1. 先将字符串依\"/\"分割出来，然后检查每个分割出来的字符串。\n\t        当字符串为空或者为\".\"，不做任何操作。\n\t        当字符串不为\"..\"，则将字符串入栈。\n\t        当字符串为\"..\", 则弹栈（返回上级目录）。\n        2. 当对所有分割成的字符串都处理完后，检查第一个栈是否为空，如果栈为空，则证明没有可以重建的目录名，返回\"/\"即可。\n        当第一个栈不为空时，这时候我们需要还原path。但是不能弹出栈，因为按照要求栈底元素应该为最先还原的目录path。\n    */\nWiggle Sort II\nAdd and Search Word - Data structure design\n    /*\n            public boolean match(char[] arr, int index, TrieNode node) {\n                if (index == arr.length) {\n                    return !node.word.equals(\"\");\n                }\n                if (arr[index] != '.') {\n                    TrieNode nextNode = node.children[arr[index] - 'a'];\n                    return nextNode != null && match(arr, index + 1, nextNode);\n                } else if (arr[index] == '.') {\n                    for (int i = 0; i < node.children.length; i++) {\n                        if (node.children[i] != null) {\n                            if (match(arr, index + 1, node.children[i])) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                return false;\n            }\n    */\nWord Ladder //每次新生从new word时，就要从dict中remove\nRange Sum Query - Mutable //Binary Index Tree, Frewick Tree\nValidate Binary Search Tree // use pre and cur node, if pre >= cur ,return false, using preorder iterative\nLargest Number \n    /*\n        Keypoint: \n        //compare 按照两个字符相加后的结果排序\n        (1) Comparator<String> comp = new Comparator<String>(){\n            @Override\n            public int compare(String i1, String i2) {\n                String s1 = i1 + i2;\n                String s2 = i2 + i1;\n                return s2.compareTo(s1);\n            }\n        };\n        \n        //如果为0\n        (2) if (res.charAt(0) == '0') {\n            return \"0\";\n        }\n    */\nDivide Two Integers //要检查corner case，比如除数等于0，被除数等于0， 被除数等于最小负整数并且除数等于-1\n    /*  \n        Key Point:\n        (1) 要将除数和被除数转化为long\n        (2) 运算过程\n            while (a >= b) {\n                int shift = 1;\n                while (a >= (b << shift)) {\n                    shift++;\n                }\n                a -= b << (shift - 1);\n                res += 1 << (shift - 1);\n            }\n    */\nFraction to Recurring Decimal\nBest Meeting Point\n        /*\n            如何求最短的Manhattan Distance？(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\n            1. 将所有点的x轴和y轴的值分别提取到list中进行排序，\n            2. x的median值和y的median值就是所求最短距离点\n            3. 然而这里只让求的是最短距离，以下就是巧妙的求所有点到median点的计算方法\n                while (start < end) {\n                    sum += list.get(end--) - list.get(start++); \n                }\n        */\nSmallest Rectangle Enclosing Black Pixels //binary search方法是难点\nFind the Duplicate Number//不对数组元素进行比较，直接比较1 ~ N；\n        /*\n            int start = 1;\n            int end = nums.length - 1;\n            while (start < end) {\n                int mid = start + (end - start) / 2;\n                if (noGreater(nums, mid) <= mid) {\n                    start = mid + 1;\n                } else {\n                    end = mid;\n                }\n            }\n            return start;\n        */\nN-Queens I & II \n        /* key point：用一维数组表示二维棋盘， 检查行列是否有重复值\n            if (arr[row] == arr[i] || Math.abs(arr[row] - arr[i]) == (row - i)) {\n                return false;\n            }\n        */\nWord Pattern II\n/*\n    1. 用 hashmap 和set 进行backtracking， 每次将pattern的c和对应的s.substring放入 hashmap和set进行dfs，如果返回false，则remove set和hashmap的value进行backtracking.\n    2. 用两个index 去遍历pattern 和 str，进行backtracking\n*/\nNumber of Islands II // 用root[m * n] 去index matrix里的所有position\nRemove Invalid Parentheses //\nSearch in Rotated Sorted Array\n    /*\n            if (nums[start] < nums[mid]) {\n                if (nums[start] <= target && target <= nums[mid]) {\n                    end = mid;\n                } else {\n                    start = mid;\n                }\n            } else {\n                if (nums[mid] <= target && target <= nums[end]) {\n                    start = mid;\n                } else {\n                    end = mid;\n                }\n            }\n    */\nDistinct Subsequences\n    /*\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n    */\nMaximum Gap\nMerge Intervals\nLargest Rectangle in Histogram\nSudoku Solver\nExpression Add Operators\nFirst Missing Positive//O(n) time and uses constant space.\n    /*\n        for (int i = 0; i < len; i++) {\n            while (nums[i] > 0 && nums[i] <= len && nums[i] != nums[nums[i] - 1]) {\n                swap(nums, i, nums[i] - 1);\n            }\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return len + 1;\n    */\nInsert Interval\nLongest Valid Parentheses3\nFind Median from Data Stream\nThe Skyline Problem\nRange Sum Query 2D - Mutable //Binary Index Tree\nShortest Palindrome\nDungeon Game Word Break II\nWord Ladder II\nSubstring with Concatenation of All Words\nMinimum Window Substring"
    }
  ]
}