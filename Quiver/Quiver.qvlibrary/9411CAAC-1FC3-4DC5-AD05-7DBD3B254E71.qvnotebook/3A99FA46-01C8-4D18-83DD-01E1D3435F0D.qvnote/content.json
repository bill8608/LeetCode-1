{
  "title": "难题",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "Summary Range\nZigzag Conversion\nCompare Version Numbers\nProduct of Array Except Self\nMissing Range\nZigzag  Iterator\nshortest word distance\nSingle Number III\nSingle Number II\nUnique Binary Search Trees I & II\nMaximum Product of Word Lengths\nConvert Sorted List to Binary Search Tree\nKth Smallest Element in a BST\nBest Time to Buy and Sell Stock with Cooldown\nCount Univalue Subtrees\nInorder Successor in BST\nSwap Nodes in Pairs\nSort Colors (one pass, two pointer method)\nSpiral Matrix II\nGame of Life\nMeeting Rooms II\nClosest Binary Search Tree Value II My Submissions Question\nCount of Range Sum\nCount of Smaller Numbers After Self\nPeeking Iterator\nFind Peak Element //循环条件式一定成立\nH-Index I & II\nReverse Words in a String\nPopulating Next Right Pointers In Each Node II(No Need To A Perfect Binary Tree)\nFlatten Binary Tree To Linked List\nBinary Tree Upside Down\nTree Serialize\nClone Graph \nUnique Binary Search Trees II\nInsertion Sort List\nOne Edit Distance\nPatching Array //设一个know_num,表示数组能表示从[1,know_num)范围的所有数。\n               //假如know_num >= num[i]: know_sum += num[i], 否则know_sum += know_sum, 此时count++\nEncode and Decode Strings //最重要的两点， 1：encode成：len+\"/\"+word的形式，\n                          //2：用indexOf(\"/\", i)定位从第i个位置开始的第一个出现的 slash符的下标\nGas Station: /*\n                tank += gas[i] - cost[i];//记录local的油量\n                total += gas[i] - cost[i];//记录global的油量\n                if (tank < 0) { //local的油量不满足，则这个位置一定不满足起始点，设下一个为起始点\n                    start = i + 1;\n                    tank = 0;\n                }\n            */ \nMinimum Size Subarray Sum: //slide window\nCourse Schedule // Topological Sort, 遍历点的邻居，并indegree array-- ,当入度为0 offer到queue中\nAdditive Number //dfs + parse the number to long type， check the number is valid(no start with \"0\")\nSqrt\nClone Graph // map.get(oldnode).neighbors.add(map.get(oldneighbor)); 关键\nCoin Change /*\n                if (coins[j] <= i && dp[i - coins[j]] != Integer.MAX_VALUE) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            */\nWord Break  /*\n                for (int i = 0; i < s.length(); i++) {\n                    for (int j = i + 1; j <= s.length(); j++) {\n                        if (dp[i] && wordDict.contains(s.substring(i, j))) {\n                            dp[j] = true;\n                        }\n                    }\n                }\n            */\nCount Complete Tree Nodes //计算树的高度\nSort List//\nRepeated DNA Sequences \n                        /*\n                            hash = (hash << 2) + dict.get(c);\n                            hash &= (1 << 20) - 1;\n                            if (map.containsKey(hash) && map.get(hash) == 1) {\n                                map.put(hash, map.get(hash) + 1);\n                                res.add(s.substring(i - 9, i + 1));\n                            } \n                            if (!map.containsKey(hash)) {\n                                map.put(hash, 1);\n                            }\n                        */\nRemove Duplicate Letters //\nNumber of Digit One  还是没太懂\nBasic Calculator II //栈里存数，每次遇到符号时，坚持上个符号是什么，再对之前的数进行相应操作压栈\nReconstruct Itinerary"
    }
  ]
}