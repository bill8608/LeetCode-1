{
  "title": "Stack",
  "cells": [
    {
      "type": "code",
      "language": "java",
      "data": "/*\n\tDynamic Programming\n*/\n\n\n\n1. Parentheses Problem\n\t\t1.1\tValid Parentheses\n\t\t\t/*\n\t\t\t\tGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', \n\t\t\t\tdetermine if the input string is valid.The brackets must close in the correct order, \n\t\t\t\t\"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public boolean isValid(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return true;\n\t\t\t        }\n\t\t\t        Stack<Character> stack = new Stack<>();\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (c == '(' || c == '[' || c == '{') {\n\t\t\t                stack.push(c);\n\t\t\t            } else {\n\t\t\t                if (stack.isEmpty()) {\n\t\t\t                    return false;\n\t\t\t                }\n\t\t\t                char peek = stack.pop();\n\t\t\t                if (peek == '(' && c == ')') {\n\t\t\t                    continue;\n\t\t\t                } else if (peek == '[' && c == ']') {\n\t\t\t                    continue;\n\t\t\t                } else if (peek == '{' && c == '}') {\n\t\t\t                    continue;\n\t\t\t                } else {\n\t\t\t                    return false;\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        if (!stack.isEmpty()) {\n\t\t\t            return false;\n\t\t\t        }\n\t\t\t        return true;\n\t\t\t    }\n\t\t\t}\n\n\t\t1.2 Generate Parentheses\n\t\t\t//Recursive\n\t\t    public List<String> generateParenthesis(int n) {\n\t\t        List<String> res = new ArrayList<>();\n\t\t        if (n < 1) {\n\t\t            return res;\n\t\t        }\n\t\t        helper(res, \"\", n, n);\n\t\t        return res;\n\t\t    }\n\t\t    public void helper(List<String> res, String item, int left, int right) {\n\t\t        if (left == 0 && right == 0) {\n\t\t            res.add(item);\n\t\t            return;\n\t\t        }\n\t\t        if (left > 0) {\n\t\t            helper(res, item + '(', left - 1, right);\n\t\t        } \n\t\t        if (left < right) {\n\t\t            helper(res, item + ')', left, right - 1);\n\t\t        }\n\t\t    }\n\t\t    //Iteration\n\t\t    public List<String> generateParenthesis(int n) {\n\t\t        List<List<String>> lists = new ArrayList<>();\n\t\t        List<String> initList = new ArrayList<>();\n\t\t        initList.add(\"\");\n\t\t        lists.add(initList);\n\t\t        for (int i = 1; i <= n; i++) {\n\t\t            List<String> res = new ArrayList<>();\n\t\t            for (int j = 0; j < i; j++) {\n\t\t                for (String first : lists.get(j)) {\n\t\t                    for (String second : lists.get(i - 1 - j)) {\n\t\t                        res.add(\"(\" + first + \")\" + second);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            lists.add(res);\n\t\t        }\n\t\t        return lists.get(lists.size() - 1);\n\t\t    }\n\t\t1.3\tLongest Valid Parentheses\n\t\t\t/*\n\t\t\t\tGiven a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n\t\t\t\tFor \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.Another example is \")()())\", \n\t\t\t\twhere the longest valid parentheses substring is \"()()\", which has length = 4.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int longestValidParentheses(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;  \n\t\t\t        }\n\t\t\t        Stack<Integer> stack = new Stack<Integer>();\n\t\t\t        int start = -1;\n\t\t\t        int maxLen = 0;\n\t\t\t    \n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            if (s.charAt(i) == '(') {\n\t\t\t                stack.push(i);\n\t\t\t            } else {\n\t\t\t                if (stack.isEmpty()) {\n\t\t\t                    start = i;\n\t\t\t                } else {\n\t\t\t                    stack.pop();\n\t\t\t                    maxLen = stack.isEmpty() ? Math.max(maxLen, i - start) : Math.max(maxLen, i - stack.peek());\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return maxLen;\n\t\t\t    }\n\t\t\t}\n\t\t1.4 Balance Parentheses\n\t\t\tpublic class Solution  {\n\t\t\t\tpublic String balance(String s) {\n\t\t\t\t\t//use stack to store the position information of parentheses\n\t\t\t\t\t//at last , if the stack is not empty, \n\t\t\t\t\t//that's mean these parentheses need to delete from tht orginial string\n\t\t\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\t\t\tStringBuilder sb = new StringBuilder(s);\n\t\t\t\t\t\n\t\t\t\t\tfor (int i=0; i< s.length(); i++) {\n\t\t\t\t\t\tint c = s.charAt(i);\n\t\t\t\t\t\t//when the stack is empty and c equals '(', stack push the index of String\n\t\t\t\t\t\tif (stack.isEmpty() || c == '(') {\n\t\t\t\t\t\t\tstack.push(i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint top = stack.peek();\n\t\t\t\t\t\t\tif (s.charAt(top) == ')') {\n\t\t\t\t\t\t\t\tstack.push(i);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\tsb.deleteCharAt(stack.pop());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t1.5 Remove Invalid Parentheses\n\t\t\t/*\n\t\t\t\t\"()())()\" -> [\"()()()\", \"(())()\"]\n\t\t\t\t\"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\n\t\t\t\t\")(\" -> [\"\"]\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public List<String> removeInvalidParentheses(String s) {\n\t\t\t        List<String> res = new ArrayList<>();\n\t\t\t        if (s == null) {\n\t\t\t            return res;\n\t\t\t        }\n\t\t\t        Set<String> visited = new HashSet<>();\n\t\t\t        Queue<String> queue = new LinkedList<>();\n\t\t\t        queue.add(s);\n\t\t\t        visited.add(s);\n\t\t\t        boolean found = false;\n\t\t\t        while (!queue.isEmpty()) {\n\t\t\t            s = queue.poll();\n\t\t\t            \n\t\t\t            if (isValid(s)) {\n\t\t\t                res.add(s);\n\t\t\t                found = true;\n\t\t\t            }\n\t\t\t            //一旦找到了有效的s，一定是最大长度的，因此只需要判断在同一层入队列的s，不需要再往下删除生成子字符串\n\t\t\t            if (found) {\n\t\t\t                continue;\n\t\t\t            }\n\t\t\t            //遍历字符串所有位置，删除'('或者')'之后压入队列\n\t\t\t            for (int i = 0; i < s.length(); i++) {\n\t\t\t                if (s.charAt(i) != '(' && s.charAt(i) != ')') {\n\t\t\t                    continue;\n\t\t\t                }\n\t\t\t                String subStr = s.substring(0, i) + s.substring(i + 1);\n\t\t\t                if (!visited.contains(subStr)) {\n\t\t\t                    queue.add(subStr);\n\t\t\t                    visited.add(subStr);\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t    public boolean isValid(String s) {\n\t\t\t        int count = 0;\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (c == '(') {\n\t\t\t                count++;\n\t\t\t            } else if (c == ')' && count-- == 0) {\n\t\t\t                return false;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        return count == 0;\n\t\t\t    }\n\t\t\t}\n\n\n\n\n\n2. Math\n\t\t2.1\tBasic Calculator I\n\t\t\t/*\n\t\t\t    Principle:\n\t\t\t        (Sign before '+'/'-') = (This context sign);\n\t\t\t        (Sign after '+'/'-') = (This context sign) * (1 or -1);\n\t\t\t    Algorithm:\n\t\t\t        Start from +1 sign and scan s from left to right;\n\t\t\t        if c == digit: This number = Last digit * 10 + This digit;\n\t\t\t        if c == '+': Add num to result before this sign; This sign = Last context sign * 1; clear num;\n\t\t\t        if c == '-': Add num to result before this sign; This sign = Last context sign * -1; clear num;\n\t\t\t        if c == '(': Push this context sign to stack;\n\t\t\t        if c == ')': Pop this context and we come back to last context;\n\t\t\t        Add the last num. This is because we only add number after '+' / '-'.\n\t\t\t*/\n\t\t\tpublic class Solution {\n\t\t\t    public int calculate(String s) {\n\t\t\t        if (s == null) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        int res = 0;\n\t\t\t        int sign = 1;\n\t\t\t        int num = 0;\n\t\t\t        Stack<Integer> stack = new Stack<Integer>();\n\t\t\t        stack.push(sign);\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            char c = s.charAt(i);\n\t\t\t            if (c >= '0' && c <= '9') {\n\t\t\t                num = num * 10 + (c - '0');\n\t\t\t            } else if (c == '+' || c == '-') {\n\t\t\t                res += sign * num;\n\t\t\t                sign = stack.peek() * (c == '+' ? 1 : -1);\n\t\t\t                num = 0;\n\t\t\t            } else if (c == '(') {\n\t\t\t                stack.push(sign);\n\t\t\t            } else if (c == ')') {\n\t\t\t                stack.pop();\n\t\t\t            }\n\t\t\t        }\n\t\t\t        res += sign * num;\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\t\t2.2 Basic Calculator II\n    \t\t/*\n\t\t    \tSolution: 算法逻辑\n\t\t             1.运用stack， 遍历String上的所有character，如果遇到数字字符um = num * 10 + s.charAt(i) - '0'，为什么要这样，当遇见多位的数时，需要这样处理\n\t\t             2.接下来如果遇到以下两种情况就对栈进行进栈操作\n\t\t                1）  如果该字符非数字，且该字符不为空，根据sign，我们注意这个时候的sign是前次运算的sign，根据上次的sign来决定对前个num是采用何种操作。\n\t\t                     之后将sign赋值为当前字符，num设为0\n\t\t                2)   如果i遍历到字符串尾部。\n\t\t            3. 将stack的所有项相加，就是ressult\n            */\n\t\t\tpublic class Solution {\n\t\t\t    public int calculate(String s) {\n\t\t\t        if (s == null || s.length() == 0) {\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t        Stack<Integer> stack = new Stack<Integer>();\n\t\t\t        int num = 0;\n\t\t\t        char sign = '+';\n\t\t\t        for (int i = 0; i < s.length(); i++) {\n\t\t\t            if (Character.isDigit(s.charAt(i))) {\n\t\t\t                num = num * 10 + s.charAt(i) - '0';\n\t\t\t            }\n\t\t\t            if ((!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ') || i == s.length() - 1) {\n\t\t\t                if (sign == '-') {\n\t\t\t                    stack.push(-num);\n\t\t\t                }\n\t\t\t                if (sign == '+') {\n\t\t\t                    stack.push(num);\n\t\t\t                }\n\t\t\t                if (sign == '*') {\n\t\t\t                    stack.push(stack.pop() * num);\n\t\t\t                }\n\t\t\t                if (sign == '/') {\n\t\t\t                    stack.push(stack.pop() / num);\n\t\t\t                }\n\t\t\t                sign = s.charAt(i);\n\t\t\t                num = 0;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        int res = 0;\n\t\t\t        for (int i : stack) {\n\t\t\t            res += i;\n\t\t\t        }\n\t\t\t        return res;\n\t\t\t    }\n\t\t\t}\n\n3. String Problem\n\t\t3.1 Simplify Path\n\t\t/*\t\t\n\t\t\t当遇到“/../\"则需要返回上级目录，需检查上级目录是否为空。\n\t        当遇到\"/./\"则表示是本级目录，无需做任何特殊操作。 \n\t        当遇到\"//\"则表示是本级目录，无需做任何操作。\n\t        当遇到其他字符则表示是文件夹名，无需简化。\n\t        当字符串是空或者遇到”/../”，则需要返回一个\"/\"。\n\t        当遇见\"/a//b\"，则需要简化为\"/a/b\"。\n\t\t*/\n\t\tpublic class Solution {\n\t\t    public String simplifyPath(String path) {\n\t\t        String res = \"\";\n\t\t        if (path == null || path.length() == 0) {\n\t\t            return res;\n\t\t        }\n\t\t        String[] pathArr = path.split(\"/\");\n\t\t        LinkedList<String> stack = new LinkedList<String>();\n\t\t        for (String s : pathArr) {\n\t\t            if (s.length() == 0 || s.equals(\".\")) {\n\t\t                continue;\n\t\t            } else if (s.equals(\"..\")) {\n\t\t                if (!stack.isEmpty()) {\n\t\t                    stack.pop();\n\t\t                }\n\t\t            } else {\n\t\t                stack.push(s);\n\t\t            }\n\t\t        }\n\t\t        if (stack.isEmpty()) {\n\t\t            return \"/\";\n\t\t        }\n\t\t        while (!stack.isEmpty()) {\n\t\t            res += \"/\" + stack.removeLast();\n\t\t        }\n\t\t        return res;\n\t\t    }\n\t\t}\n\n\n\n\n"
    }
  ]
}